// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.27.1
// source: tiktok-schema.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "TikTok";

/** Data structure from im/fetch/ response */
export interface WebcastResponse {
  messages: Message[];
  cursor: string;
  fetchInterval: number;
  serverTimestamp: string;
  internalExt: string;
  /** ws (1) or polling (2) */
  fetchType: number;
  wsParams: WebsocketParam[];
  heartbeatDuration: number;
  needAck: boolean;
  wsUrl: string;
}

export interface Message {
  type: string;
  binary: Uint8Array;
}

export interface WebsocketParam {
  name: string;
  value: string;
}

/** Message types depending on Message.tyoe */
export interface WebcastControlMessage {
  action: number;
}

/** Statistics like viewer count */
export interface WebcastRoomUserSeqMessage {
  topViewers: TopUser[];
  viewerCount: number;
}

export interface TopUser {
  coinCount: string;
  user: User | undefined;
}

export interface WebcastChatMessage {
  event: WebcastMessageEvent | undefined;
  user: User | undefined;
  comment: string;
  emotes: WebcastSubEmote[];
}

/** Chat Emotes (Subscriber) */
export interface WebcastEmoteChatMessage {
  user: User | undefined;
  emote: EmoteDetails | undefined;
}

export interface WebcastSubEmote {
  /** starting at 0, you insert the emote itself into the comment at that place */
  placeInComment: number;
  emote: EmoteDetails | undefined;
}

export interface WebcastMemberMessage {
  event: WebcastMessageEvent | undefined;
  user: User | undefined;
  actionId: number;
}

export interface WebcastGiftMessage {
  event: WebcastMessageEvent | undefined;
  giftId: number;
  repeatCount: number;
  user: User | undefined;
  repeatEnd: number;
  groupId: string;
  giftDetails: WebcastGiftMessageGiftDetails | undefined;
  monitorExtra: string;
  giftExtra: WebcastGiftMessageGiftExtra | undefined;
}

export interface WebcastGiftMessageGiftDetails {
  giftImage: WebcastGiftMessageGiftImage | undefined;
  giftName: string;
  describe: string;
  giftType: number;
  diamondCount: number;
}

/** Taken from https://github.com/Davincible/gotiktoklive/blob/da4630622bc586629a53faae64e8c53509af29de/proto/tiktok.proto#L57 */
export interface WebcastGiftMessageGiftExtra {
  timestamp: string;
  receiverUserId: string;
}

export interface WebcastGiftMessageGiftImage {
  giftPictureUrl: string;
}

/** Battle start */
export interface WebcastLinkMicBattle {
  battleUsers: WebcastLinkMicBattleItems[];
}

export interface WebcastLinkMicBattleItems {
  battleGroup: WebcastLinkMicBattleGroup | undefined;
}

export interface WebcastLinkMicBattleGroup {
  user: LinkUser | undefined;
}

/** Battle status */
export interface WebcastLinkMicArmies {
  battleItems: WebcastLinkMicArmiesItems[];
  battleStatus: number;
}

export interface WebcastLinkMicArmiesItems {
  hostUserId: string;
  battleGroups: WebcastLinkMicArmiesGroup[];
}

export interface WebcastLinkMicArmiesGroup {
  users: User[];
  points: number;
}

/** Follow & share event */
export interface WebcastSocialMessage {
  event: WebcastMessageEvent | undefined;
  user: User | undefined;
}

/** Like event (is only sent from time to time, not with every like) */
export interface WebcastLikeMessage {
  event: WebcastMessageEvent | undefined;
  user: User | undefined;
  likeCount: number;
  totalLikeCount: number;
}

/** New question event */
export interface WebcastQuestionNewMessage {
  questionDetails: QuestionDetails | undefined;
}

export interface QuestionDetails {
  questionText: string;
  user: User | undefined;
}

export interface WebcastMessageEvent {
  msgId: string;
  createTime: string;
  eventDetails: WebcastMessageEventDetails | undefined;
}

/** Contains UI information */
export interface WebcastMessageEventDetails {
  displayType: string;
  label: string;
}

/** Source: Co-opted https://github.com/zerodytrash/TikTok-Livestream-Chat-Connector/issues/19#issuecomment-1074150342 */
export interface WebcastLiveIntroMessage {
  id: string;
  description: string;
  user: User | undefined;
}

export interface SystemMessage {
  description: string;
}

export interface WebcastInRoomBannerMessage {
  data: string;
}

export interface RankItem {
  colour: string;
  id: string;
}

export interface WeeklyRanking {
  type: string;
  label: string;
  rank: RankItem | undefined;
}

export interface RankContainer {
  rankings: WeeklyRanking | undefined;
}

export interface WebcastHourlyRankMessage {
  data: RankContainer | undefined;
}

export interface EmoteDetails {
  emoteId: string;
  image: EmoteImage | undefined;
}

export interface EmoteImage {
  imageUrl: string;
}

/**
 * Envelope (treasure boxes)
 * Taken from https://github.com/ThanoFish/TikTok-Live-Connector/blob/9b215b96792adfddfb638344b152fa9efa581b4c/src/proto/tiktokSchema.proto
 */
export interface WebcastEnvelopeMessage {
  treasureBoxData: TreasureBoxData | undefined;
  treasureBoxUser: TreasureBoxUser | undefined;
}

export interface TreasureBoxUser {
  user2: TreasureBoxUser2 | undefined;
}

export interface TreasureBoxUser2 {
  user3: TreasureBoxUser3[];
}

export interface TreasureBoxUser3 {
  user4: TreasureBoxUser4 | undefined;
}

export interface TreasureBoxUser4 {
  user: User | undefined;
}

export interface TreasureBoxData {
  coins: number;
  canOpen: number;
  timestamp: string;
}

/** New Subscriber message */
export interface WebcastSubNotifyMessage {
  event: WebcastMessageEvent | undefined;
  user: User | undefined;
  exhibitionType: number;
  subMonth: number;
  subscribeType: number;
  oldSubscribeStatus: number;
  subscribingStatus: number;
}

export interface User {
  userId: string;
  nickname: string;
  profilePicture: ProfilePicture | undefined;
  uniqueId: string;
  secUid: string;
  badges: UserBadgesAttributes[];
  createTime: string;
  bioDescription: string;
  followInfo: FollowInfo | undefined;
}

export interface FollowInfo {
  followingCount: number;
  followerCount: number;
  followStatus: number;
  pushStatus: number;
}

export interface LinkUser {
  userId: string;
  nickname: string;
  profilePicture: ProfilePicture | undefined;
  uniqueId: string;
}

export interface ProfilePicture {
  urls: string[];
}

export interface UserBadgesAttributes {
  badgeSceneType: number;
  imageBadges: UserImageBadge[];
  badges: UserBadge[];
  privilegeLogExtra: PrivilegeLogExtra | undefined;
}

export interface PrivilegeLogExtra {
  privilegeId: string;
  level: string;
}

export interface UserBadge {
  type: string;
  name: string;
}

export interface UserImageBadge {
  displayType: number;
  image: UserImageBadgeImage | undefined;
}

export interface UserImageBadgeImage {
  url: string;
}

/** Websocket incoming message structure */
export interface WebcastWebsocketMessage {
  id: string;
  type: string;
  binary: Uint8Array;
}

/** Websocket acknowledgment message */
export interface WebcastWebsocketAck {
  id: string;
  type: string;
}

function createBaseWebcastResponse(): WebcastResponse {
  return {
    messages: [],
    cursor: "",
    fetchInterval: 0,
    serverTimestamp: "0",
    internalExt: "",
    fetchType: 0,
    wsParams: [],
    heartbeatDuration: 0,
    needAck: false,
    wsUrl: "",
  };
}

export const WebcastResponse: MessageFns<WebcastResponse> = {
  encode(message: WebcastResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      Message.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.cursor !== "") {
      writer.uint32(18).string(message.cursor);
    }
    if (message.fetchInterval !== 0) {
      writer.uint32(24).int32(message.fetchInterval);
    }
    if (message.serverTimestamp !== "0") {
      writer.uint32(32).int64(message.serverTimestamp);
    }
    if (message.internalExt !== "") {
      writer.uint32(42).string(message.internalExt);
    }
    if (message.fetchType !== 0) {
      writer.uint32(48).int32(message.fetchType);
    }
    for (const v of message.wsParams) {
      WebsocketParam.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.heartbeatDuration !== 0) {
      writer.uint32(64).int32(message.heartbeatDuration);
    }
    if (message.needAck !== false) {
      writer.uint32(72).bool(message.needAck);
    }
    if (message.wsUrl !== "") {
      writer.uint32(82).string(message.wsUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cursor = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fetchInterval = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.serverTimestamp = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.internalExt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.fetchType = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.wsParams.push(WebsocketParam.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.heartbeatDuration = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.needAck = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.wsUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastResponse {
    return {
      messages: globalThis.Array.isArray(object?.messages) ? object.messages.map((e: any) => Message.fromJSON(e)) : [],
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
      fetchInterval: isSet(object.fetchInterval) ? globalThis.Number(object.fetchInterval) : 0,
      serverTimestamp: isSet(object.serverTimestamp) ? globalThis.String(object.serverTimestamp) : "0",
      internalExt: isSet(object.internalExt) ? globalThis.String(object.internalExt) : "",
      fetchType: isSet(object.fetchType) ? globalThis.Number(object.fetchType) : 0,
      wsParams: globalThis.Array.isArray(object?.wsParams)
        ? object.wsParams.map((e: any) => WebsocketParam.fromJSON(e))
        : [],
      heartbeatDuration: isSet(object.heartbeatDuration) ? globalThis.Number(object.heartbeatDuration) : 0,
      needAck: isSet(object.needAck) ? globalThis.Boolean(object.needAck) : false,
      wsUrl: isSet(object.wsUrl) ? globalThis.String(object.wsUrl) : "",
    };
  },

  toJSON(message: WebcastResponse): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => Message.toJSON(e));
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    if (message.fetchInterval !== 0) {
      obj.fetchInterval = Math.round(message.fetchInterval);
    }
    if (message.serverTimestamp !== "0") {
      obj.serverTimestamp = message.serverTimestamp;
    }
    if (message.internalExt !== "") {
      obj.internalExt = message.internalExt;
    }
    if (message.fetchType !== 0) {
      obj.fetchType = Math.round(message.fetchType);
    }
    if (message.wsParams?.length) {
      obj.wsParams = message.wsParams.map((e) => WebsocketParam.toJSON(e));
    }
    if (message.heartbeatDuration !== 0) {
      obj.heartbeatDuration = Math.round(message.heartbeatDuration);
    }
    if (message.needAck !== false) {
      obj.needAck = message.needAck;
    }
    if (message.wsUrl !== "") {
      obj.wsUrl = message.wsUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastResponse>, I>>(base?: I): WebcastResponse {
    return WebcastResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastResponse>, I>>(object: I): WebcastResponse {
    const message = createBaseWebcastResponse();
    message.messages = object.messages?.map((e) => Message.fromPartial(e)) || [];
    message.cursor = object.cursor ?? "";
    message.fetchInterval = object.fetchInterval ?? 0;
    message.serverTimestamp = object.serverTimestamp ?? "0";
    message.internalExt = object.internalExt ?? "";
    message.fetchType = object.fetchType ?? 0;
    message.wsParams = object.wsParams?.map((e) => WebsocketParam.fromPartial(e)) || [];
    message.heartbeatDuration = object.heartbeatDuration ?? 0;
    message.needAck = object.needAck ?? false;
    message.wsUrl = object.wsUrl ?? "";
    return message;
  },
};

function createBaseMessage(): Message {
  return { type: "", binary: new Uint8Array(0) };
}

export const Message: MessageFns<Message> = {
  encode(message: Message, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.binary.length !== 0) {
      writer.uint32(18).bytes(message.binary);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.binary = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      binary: isSet(object.binary) ? bytesFromBase64(object.binary) : new Uint8Array(0),
    };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.binary.length !== 0) {
      obj.binary = base64FromBytes(message.binary);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Message>, I>>(base?: I): Message {
    return Message.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message {
    const message = createBaseMessage();
    message.type = object.type ?? "";
    message.binary = object.binary ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWebsocketParam(): WebsocketParam {
  return { name: "", value: "" };
}

export const WebsocketParam: MessageFns<WebsocketParam> = {
  encode(message: WebsocketParam, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebsocketParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebsocketParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebsocketParam {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: WebsocketParam): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebsocketParam>, I>>(base?: I): WebsocketParam {
    return WebsocketParam.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebsocketParam>, I>>(object: I): WebsocketParam {
    const message = createBaseWebsocketParam();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseWebcastControlMessage(): WebcastControlMessage {
  return { action: 0 };
}

export const WebcastControlMessage: MessageFns<WebcastControlMessage> = {
  encode(message: WebcastControlMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== 0) {
      writer.uint32(16).int32(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastControlMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastControlMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.action = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastControlMessage {
    return { action: isSet(object.action) ? globalThis.Number(object.action) : 0 };
  },

  toJSON(message: WebcastControlMessage): unknown {
    const obj: any = {};
    if (message.action !== 0) {
      obj.action = Math.round(message.action);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastControlMessage>, I>>(base?: I): WebcastControlMessage {
    return WebcastControlMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastControlMessage>, I>>(object: I): WebcastControlMessage {
    const message = createBaseWebcastControlMessage();
    message.action = object.action ?? 0;
    return message;
  },
};

function createBaseWebcastRoomUserSeqMessage(): WebcastRoomUserSeqMessage {
  return { topViewers: [], viewerCount: 0 };
}

export const WebcastRoomUserSeqMessage: MessageFns<WebcastRoomUserSeqMessage> = {
  encode(message: WebcastRoomUserSeqMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.topViewers) {
      TopUser.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.viewerCount !== 0) {
      writer.uint32(24).int32(message.viewerCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastRoomUserSeqMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastRoomUserSeqMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.topViewers.push(TopUser.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.viewerCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastRoomUserSeqMessage {
    return {
      topViewers: globalThis.Array.isArray(object?.topViewers)
        ? object.topViewers.map((e: any) => TopUser.fromJSON(e))
        : [],
      viewerCount: isSet(object.viewerCount) ? globalThis.Number(object.viewerCount) : 0,
    };
  },

  toJSON(message: WebcastRoomUserSeqMessage): unknown {
    const obj: any = {};
    if (message.topViewers?.length) {
      obj.topViewers = message.topViewers.map((e) => TopUser.toJSON(e));
    }
    if (message.viewerCount !== 0) {
      obj.viewerCount = Math.round(message.viewerCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastRoomUserSeqMessage>, I>>(base?: I): WebcastRoomUserSeqMessage {
    return WebcastRoomUserSeqMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastRoomUserSeqMessage>, I>>(object: I): WebcastRoomUserSeqMessage {
    const message = createBaseWebcastRoomUserSeqMessage();
    message.topViewers = object.topViewers?.map((e) => TopUser.fromPartial(e)) || [];
    message.viewerCount = object.viewerCount ?? 0;
    return message;
  },
};

function createBaseTopUser(): TopUser {
  return { coinCount: "0", user: undefined };
}

export const TopUser: MessageFns<TopUser> = {
  encode(message: TopUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coinCount !== "0") {
      writer.uint32(8).uint64(message.coinCount);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.coinCount = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopUser {
    return {
      coinCount: isSet(object.coinCount) ? globalThis.String(object.coinCount) : "0",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: TopUser): unknown {
    const obj: any = {};
    if (message.coinCount !== "0") {
      obj.coinCount = message.coinCount;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopUser>, I>>(base?: I): TopUser {
    return TopUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopUser>, I>>(object: I): TopUser {
    const message = createBaseTopUser();
    message.coinCount = object.coinCount ?? "0";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseWebcastChatMessage(): WebcastChatMessage {
  return { event: undefined, user: undefined, comment: "", emotes: [] };
}

export const WebcastChatMessage: MessageFns<WebcastChatMessage> = {
  encode(message: WebcastChatMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== undefined) {
      WebcastMessageEvent.encode(message.event, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    for (const v of message.emotes) {
      WebcastSubEmote.encode(v!, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastChatMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = WebcastMessageEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.emotes.push(WebcastSubEmote.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastChatMessage {
    return {
      event: isSet(object.event) ? WebcastMessageEvent.fromJSON(object.event) : undefined,
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      emotes: globalThis.Array.isArray(object?.emotes)
        ? object.emotes.map((e: any) => WebcastSubEmote.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WebcastChatMessage): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = WebcastMessageEvent.toJSON(message.event);
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.emotes?.length) {
      obj.emotes = message.emotes.map((e) => WebcastSubEmote.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastChatMessage>, I>>(base?: I): WebcastChatMessage {
    return WebcastChatMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastChatMessage>, I>>(object: I): WebcastChatMessage {
    const message = createBaseWebcastChatMessage();
    message.event = (object.event !== undefined && object.event !== null)
      ? WebcastMessageEvent.fromPartial(object.event)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.comment = object.comment ?? "";
    message.emotes = object.emotes?.map((e) => WebcastSubEmote.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWebcastEmoteChatMessage(): WebcastEmoteChatMessage {
  return { user: undefined, emote: undefined };
}

export const WebcastEmoteChatMessage: MessageFns<WebcastEmoteChatMessage> = {
  encode(message: WebcastEmoteChatMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.emote !== undefined) {
      EmoteDetails.encode(message.emote, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastEmoteChatMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastEmoteChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.emote = EmoteDetails.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastEmoteChatMessage {
    return {
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      emote: isSet(object.emote) ? EmoteDetails.fromJSON(object.emote) : undefined,
    };
  },

  toJSON(message: WebcastEmoteChatMessage): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.emote !== undefined) {
      obj.emote = EmoteDetails.toJSON(message.emote);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastEmoteChatMessage>, I>>(base?: I): WebcastEmoteChatMessage {
    return WebcastEmoteChatMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastEmoteChatMessage>, I>>(object: I): WebcastEmoteChatMessage {
    const message = createBaseWebcastEmoteChatMessage();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.emote = (object.emote !== undefined && object.emote !== null)
      ? EmoteDetails.fromPartial(object.emote)
      : undefined;
    return message;
  },
};

function createBaseWebcastSubEmote(): WebcastSubEmote {
  return { placeInComment: 0, emote: undefined };
}

export const WebcastSubEmote: MessageFns<WebcastSubEmote> = {
  encode(message: WebcastSubEmote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.placeInComment !== 0) {
      writer.uint32(8).int32(message.placeInComment);
    }
    if (message.emote !== undefined) {
      EmoteDetails.encode(message.emote, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastSubEmote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastSubEmote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.placeInComment = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.emote = EmoteDetails.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastSubEmote {
    return {
      placeInComment: isSet(object.placeInComment) ? globalThis.Number(object.placeInComment) : 0,
      emote: isSet(object.emote) ? EmoteDetails.fromJSON(object.emote) : undefined,
    };
  },

  toJSON(message: WebcastSubEmote): unknown {
    const obj: any = {};
    if (message.placeInComment !== 0) {
      obj.placeInComment = Math.round(message.placeInComment);
    }
    if (message.emote !== undefined) {
      obj.emote = EmoteDetails.toJSON(message.emote);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastSubEmote>, I>>(base?: I): WebcastSubEmote {
    return WebcastSubEmote.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastSubEmote>, I>>(object: I): WebcastSubEmote {
    const message = createBaseWebcastSubEmote();
    message.placeInComment = object.placeInComment ?? 0;
    message.emote = (object.emote !== undefined && object.emote !== null)
      ? EmoteDetails.fromPartial(object.emote)
      : undefined;
    return message;
  },
};

function createBaseWebcastMemberMessage(): WebcastMemberMessage {
  return { event: undefined, user: undefined, actionId: 0 };
}

export const WebcastMemberMessage: MessageFns<WebcastMemberMessage> = {
  encode(message: WebcastMemberMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== undefined) {
      WebcastMessageEvent.encode(message.event, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.actionId !== 0) {
      writer.uint32(80).int32(message.actionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMemberMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMemberMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = WebcastMessageEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.actionId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastMemberMessage {
    return {
      event: isSet(object.event) ? WebcastMessageEvent.fromJSON(object.event) : undefined,
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      actionId: isSet(object.actionId) ? globalThis.Number(object.actionId) : 0,
    };
  },

  toJSON(message: WebcastMemberMessage): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = WebcastMessageEvent.toJSON(message.event);
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.actionId !== 0) {
      obj.actionId = Math.round(message.actionId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastMemberMessage>, I>>(base?: I): WebcastMemberMessage {
    return WebcastMemberMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastMemberMessage>, I>>(object: I): WebcastMemberMessage {
    const message = createBaseWebcastMemberMessage();
    message.event = (object.event !== undefined && object.event !== null)
      ? WebcastMessageEvent.fromPartial(object.event)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.actionId = object.actionId ?? 0;
    return message;
  },
};

function createBaseWebcastGiftMessage(): WebcastGiftMessage {
  return {
    event: undefined,
    giftId: 0,
    repeatCount: 0,
    user: undefined,
    repeatEnd: 0,
    groupId: "0",
    giftDetails: undefined,
    monitorExtra: "",
    giftExtra: undefined,
  };
}

export const WebcastGiftMessage: MessageFns<WebcastGiftMessage> = {
  encode(message: WebcastGiftMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== undefined) {
      WebcastMessageEvent.encode(message.event, writer.uint32(10).fork()).join();
    }
    if (message.giftId !== 0) {
      writer.uint32(16).int32(message.giftId);
    }
    if (message.repeatCount !== 0) {
      writer.uint32(40).int32(message.repeatCount);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(58).fork()).join();
    }
    if (message.repeatEnd !== 0) {
      writer.uint32(72).int32(message.repeatEnd);
    }
    if (message.groupId !== "0") {
      writer.uint32(88).uint64(message.groupId);
    }
    if (message.giftDetails !== undefined) {
      WebcastGiftMessageGiftDetails.encode(message.giftDetails, writer.uint32(122).fork()).join();
    }
    if (message.monitorExtra !== "") {
      writer.uint32(178).string(message.monitorExtra);
    }
    if (message.giftExtra !== undefined) {
      WebcastGiftMessageGiftExtra.encode(message.giftExtra, writer.uint32(186).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = WebcastMessageEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.giftId = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.repeatCount = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.repeatEnd = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.groupId = reader.uint64().toString();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.giftDetails = WebcastGiftMessageGiftDetails.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.monitorExtra = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.giftExtra = WebcastGiftMessageGiftExtra.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastGiftMessage {
    return {
      event: isSet(object.event) ? WebcastMessageEvent.fromJSON(object.event) : undefined,
      giftId: isSet(object.giftId) ? globalThis.Number(object.giftId) : 0,
      repeatCount: isSet(object.repeatCount) ? globalThis.Number(object.repeatCount) : 0,
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      repeatEnd: isSet(object.repeatEnd) ? globalThis.Number(object.repeatEnd) : 0,
      groupId: isSet(object.groupId) ? globalThis.String(object.groupId) : "0",
      giftDetails: isSet(object.giftDetails) ? WebcastGiftMessageGiftDetails.fromJSON(object.giftDetails) : undefined,
      monitorExtra: isSet(object.monitorExtra) ? globalThis.String(object.monitorExtra) : "",
      giftExtra: isSet(object.giftExtra) ? WebcastGiftMessageGiftExtra.fromJSON(object.giftExtra) : undefined,
    };
  },

  toJSON(message: WebcastGiftMessage): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = WebcastMessageEvent.toJSON(message.event);
    }
    if (message.giftId !== 0) {
      obj.giftId = Math.round(message.giftId);
    }
    if (message.repeatCount !== 0) {
      obj.repeatCount = Math.round(message.repeatCount);
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.repeatEnd !== 0) {
      obj.repeatEnd = Math.round(message.repeatEnd);
    }
    if (message.groupId !== "0") {
      obj.groupId = message.groupId;
    }
    if (message.giftDetails !== undefined) {
      obj.giftDetails = WebcastGiftMessageGiftDetails.toJSON(message.giftDetails);
    }
    if (message.monitorExtra !== "") {
      obj.monitorExtra = message.monitorExtra;
    }
    if (message.giftExtra !== undefined) {
      obj.giftExtra = WebcastGiftMessageGiftExtra.toJSON(message.giftExtra);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastGiftMessage>, I>>(base?: I): WebcastGiftMessage {
    return WebcastGiftMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastGiftMessage>, I>>(object: I): WebcastGiftMessage {
    const message = createBaseWebcastGiftMessage();
    message.event = (object.event !== undefined && object.event !== null)
      ? WebcastMessageEvent.fromPartial(object.event)
      : undefined;
    message.giftId = object.giftId ?? 0;
    message.repeatCount = object.repeatCount ?? 0;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.repeatEnd = object.repeatEnd ?? 0;
    message.groupId = object.groupId ?? "0";
    message.giftDetails = (object.giftDetails !== undefined && object.giftDetails !== null)
      ? WebcastGiftMessageGiftDetails.fromPartial(object.giftDetails)
      : undefined;
    message.monitorExtra = object.monitorExtra ?? "";
    message.giftExtra = (object.giftExtra !== undefined && object.giftExtra !== null)
      ? WebcastGiftMessageGiftExtra.fromPartial(object.giftExtra)
      : undefined;
    return message;
  },
};

function createBaseWebcastGiftMessageGiftDetails(): WebcastGiftMessageGiftDetails {
  return { giftImage: undefined, giftName: "", describe: "", giftType: 0, diamondCount: 0 };
}

export const WebcastGiftMessageGiftDetails: MessageFns<WebcastGiftMessageGiftDetails> = {
  encode(message: WebcastGiftMessageGiftDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftImage !== undefined) {
      WebcastGiftMessageGiftImage.encode(message.giftImage, writer.uint32(10).fork()).join();
    }
    if (message.giftName !== "") {
      writer.uint32(130).string(message.giftName);
    }
    if (message.describe !== "") {
      writer.uint32(18).string(message.describe);
    }
    if (message.giftType !== 0) {
      writer.uint32(88).int32(message.giftType);
    }
    if (message.diamondCount !== 0) {
      writer.uint32(96).int32(message.diamondCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessageGiftDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessageGiftDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.giftImage = WebcastGiftMessageGiftImage.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.giftName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.describe = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.giftType = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.diamondCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastGiftMessageGiftDetails {
    return {
      giftImage: isSet(object.giftImage) ? WebcastGiftMessageGiftImage.fromJSON(object.giftImage) : undefined,
      giftName: isSet(object.giftName) ? globalThis.String(object.giftName) : "",
      describe: isSet(object.describe) ? globalThis.String(object.describe) : "",
      giftType: isSet(object.giftType) ? globalThis.Number(object.giftType) : 0,
      diamondCount: isSet(object.diamondCount) ? globalThis.Number(object.diamondCount) : 0,
    };
  },

  toJSON(message: WebcastGiftMessageGiftDetails): unknown {
    const obj: any = {};
    if (message.giftImage !== undefined) {
      obj.giftImage = WebcastGiftMessageGiftImage.toJSON(message.giftImage);
    }
    if (message.giftName !== "") {
      obj.giftName = message.giftName;
    }
    if (message.describe !== "") {
      obj.describe = message.describe;
    }
    if (message.giftType !== 0) {
      obj.giftType = Math.round(message.giftType);
    }
    if (message.diamondCount !== 0) {
      obj.diamondCount = Math.round(message.diamondCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastGiftMessageGiftDetails>, I>>(base?: I): WebcastGiftMessageGiftDetails {
    return WebcastGiftMessageGiftDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastGiftMessageGiftDetails>, I>>(
    object: I,
  ): WebcastGiftMessageGiftDetails {
    const message = createBaseWebcastGiftMessageGiftDetails();
    message.giftImage = (object.giftImage !== undefined && object.giftImage !== null)
      ? WebcastGiftMessageGiftImage.fromPartial(object.giftImage)
      : undefined;
    message.giftName = object.giftName ?? "";
    message.describe = object.describe ?? "";
    message.giftType = object.giftType ?? 0;
    message.diamondCount = object.diamondCount ?? 0;
    return message;
  },
};

function createBaseWebcastGiftMessageGiftExtra(): WebcastGiftMessageGiftExtra {
  return { timestamp: "0", receiverUserId: "0" };
}

export const WebcastGiftMessageGiftExtra: MessageFns<WebcastGiftMessageGiftExtra> = {
  encode(message: WebcastGiftMessageGiftExtra, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== "0") {
      writer.uint32(48).uint64(message.timestamp);
    }
    if (message.receiverUserId !== "0") {
      writer.uint32(64).uint64(message.receiverUserId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessageGiftExtra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessageGiftExtra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.timestamp = reader.uint64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.receiverUserId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastGiftMessageGiftExtra {
    return {
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "0",
      receiverUserId: isSet(object.receiverUserId) ? globalThis.String(object.receiverUserId) : "0",
    };
  },

  toJSON(message: WebcastGiftMessageGiftExtra): unknown {
    const obj: any = {};
    if (message.timestamp !== "0") {
      obj.timestamp = message.timestamp;
    }
    if (message.receiverUserId !== "0") {
      obj.receiverUserId = message.receiverUserId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastGiftMessageGiftExtra>, I>>(base?: I): WebcastGiftMessageGiftExtra {
    return WebcastGiftMessageGiftExtra.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastGiftMessageGiftExtra>, I>>(object: I): WebcastGiftMessageGiftExtra {
    const message = createBaseWebcastGiftMessageGiftExtra();
    message.timestamp = object.timestamp ?? "0";
    message.receiverUserId = object.receiverUserId ?? "0";
    return message;
  },
};

function createBaseWebcastGiftMessageGiftImage(): WebcastGiftMessageGiftImage {
  return { giftPictureUrl: "" };
}

export const WebcastGiftMessageGiftImage: MessageFns<WebcastGiftMessageGiftImage> = {
  encode(message: WebcastGiftMessageGiftImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftPictureUrl !== "") {
      writer.uint32(10).string(message.giftPictureUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessageGiftImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessageGiftImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.giftPictureUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastGiftMessageGiftImage {
    return { giftPictureUrl: isSet(object.giftPictureUrl) ? globalThis.String(object.giftPictureUrl) : "" };
  },

  toJSON(message: WebcastGiftMessageGiftImage): unknown {
    const obj: any = {};
    if (message.giftPictureUrl !== "") {
      obj.giftPictureUrl = message.giftPictureUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastGiftMessageGiftImage>, I>>(base?: I): WebcastGiftMessageGiftImage {
    return WebcastGiftMessageGiftImage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastGiftMessageGiftImage>, I>>(object: I): WebcastGiftMessageGiftImage {
    const message = createBaseWebcastGiftMessageGiftImage();
    message.giftPictureUrl = object.giftPictureUrl ?? "";
    return message;
  },
};

function createBaseWebcastLinkMicBattle(): WebcastLinkMicBattle {
  return { battleUsers: [] };
}

export const WebcastLinkMicBattle: MessageFns<WebcastLinkMicBattle> = {
  encode(message: WebcastLinkMicBattle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.battleUsers) {
      WebcastLinkMicBattleItems.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.battleUsers.push(WebcastLinkMicBattleItems.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastLinkMicBattle {
    return {
      battleUsers: globalThis.Array.isArray(object?.battleUsers)
        ? object.battleUsers.map((e: any) => WebcastLinkMicBattleItems.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WebcastLinkMicBattle): unknown {
    const obj: any = {};
    if (message.battleUsers?.length) {
      obj.battleUsers = message.battleUsers.map((e) => WebcastLinkMicBattleItems.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastLinkMicBattle>, I>>(base?: I): WebcastLinkMicBattle {
    return WebcastLinkMicBattle.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastLinkMicBattle>, I>>(object: I): WebcastLinkMicBattle {
    const message = createBaseWebcastLinkMicBattle();
    message.battleUsers = object.battleUsers?.map((e) => WebcastLinkMicBattleItems.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWebcastLinkMicBattleItems(): WebcastLinkMicBattleItems {
  return { battleGroup: undefined };
}

export const WebcastLinkMicBattleItems: MessageFns<WebcastLinkMicBattleItems> = {
  encode(message: WebcastLinkMicBattleItems, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.battleGroup !== undefined) {
      WebcastLinkMicBattleGroup.encode(message.battleGroup, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattleItems {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattleItems();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.battleGroup = WebcastLinkMicBattleGroup.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastLinkMicBattleItems {
    return {
      battleGroup: isSet(object.battleGroup) ? WebcastLinkMicBattleGroup.fromJSON(object.battleGroup) : undefined,
    };
  },

  toJSON(message: WebcastLinkMicBattleItems): unknown {
    const obj: any = {};
    if (message.battleGroup !== undefined) {
      obj.battleGroup = WebcastLinkMicBattleGroup.toJSON(message.battleGroup);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastLinkMicBattleItems>, I>>(base?: I): WebcastLinkMicBattleItems {
    return WebcastLinkMicBattleItems.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastLinkMicBattleItems>, I>>(object: I): WebcastLinkMicBattleItems {
    const message = createBaseWebcastLinkMicBattleItems();
    message.battleGroup = (object.battleGroup !== undefined && object.battleGroup !== null)
      ? WebcastLinkMicBattleGroup.fromPartial(object.battleGroup)
      : undefined;
    return message;
  },
};

function createBaseWebcastLinkMicBattleGroup(): WebcastLinkMicBattleGroup {
  return { user: undefined };
}

export const WebcastLinkMicBattleGroup: MessageFns<WebcastLinkMicBattleGroup> = {
  encode(message: WebcastLinkMicBattleGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      LinkUser.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattleGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattleGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = LinkUser.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastLinkMicBattleGroup {
    return { user: isSet(object.user) ? LinkUser.fromJSON(object.user) : undefined };
  },

  toJSON(message: WebcastLinkMicBattleGroup): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = LinkUser.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastLinkMicBattleGroup>, I>>(base?: I): WebcastLinkMicBattleGroup {
    return WebcastLinkMicBattleGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastLinkMicBattleGroup>, I>>(object: I): WebcastLinkMicBattleGroup {
    const message = createBaseWebcastLinkMicBattleGroup();
    message.user = (object.user !== undefined && object.user !== null) ? LinkUser.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseWebcastLinkMicArmies(): WebcastLinkMicArmies {
  return { battleItems: [], battleStatus: 0 };
}

export const WebcastLinkMicArmies: MessageFns<WebcastLinkMicArmies> = {
  encode(message: WebcastLinkMicArmies, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.battleItems) {
      WebcastLinkMicArmiesItems.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.battleStatus !== 0) {
      writer.uint32(56).int32(message.battleStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicArmies {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicArmies();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.battleItems.push(WebcastLinkMicArmiesItems.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.battleStatus = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastLinkMicArmies {
    return {
      battleItems: globalThis.Array.isArray(object?.battleItems)
        ? object.battleItems.map((e: any) => WebcastLinkMicArmiesItems.fromJSON(e))
        : [],
      battleStatus: isSet(object.battleStatus) ? globalThis.Number(object.battleStatus) : 0,
    };
  },

  toJSON(message: WebcastLinkMicArmies): unknown {
    const obj: any = {};
    if (message.battleItems?.length) {
      obj.battleItems = message.battleItems.map((e) => WebcastLinkMicArmiesItems.toJSON(e));
    }
    if (message.battleStatus !== 0) {
      obj.battleStatus = Math.round(message.battleStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastLinkMicArmies>, I>>(base?: I): WebcastLinkMicArmies {
    return WebcastLinkMicArmies.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastLinkMicArmies>, I>>(object: I): WebcastLinkMicArmies {
    const message = createBaseWebcastLinkMicArmies();
    message.battleItems = object.battleItems?.map((e) => WebcastLinkMicArmiesItems.fromPartial(e)) || [];
    message.battleStatus = object.battleStatus ?? 0;
    return message;
  },
};

function createBaseWebcastLinkMicArmiesItems(): WebcastLinkMicArmiesItems {
  return { hostUserId: "0", battleGroups: [] };
}

export const WebcastLinkMicArmiesItems: MessageFns<WebcastLinkMicArmiesItems> = {
  encode(message: WebcastLinkMicArmiesItems, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostUserId !== "0") {
      writer.uint32(8).uint64(message.hostUserId);
    }
    for (const v of message.battleGroups) {
      WebcastLinkMicArmiesGroup.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicArmiesItems {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicArmiesItems();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hostUserId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.battleGroups.push(WebcastLinkMicArmiesGroup.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastLinkMicArmiesItems {
    return {
      hostUserId: isSet(object.hostUserId) ? globalThis.String(object.hostUserId) : "0",
      battleGroups: globalThis.Array.isArray(object?.battleGroups)
        ? object.battleGroups.map((e: any) => WebcastLinkMicArmiesGroup.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WebcastLinkMicArmiesItems): unknown {
    const obj: any = {};
    if (message.hostUserId !== "0") {
      obj.hostUserId = message.hostUserId;
    }
    if (message.battleGroups?.length) {
      obj.battleGroups = message.battleGroups.map((e) => WebcastLinkMicArmiesGroup.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastLinkMicArmiesItems>, I>>(base?: I): WebcastLinkMicArmiesItems {
    return WebcastLinkMicArmiesItems.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastLinkMicArmiesItems>, I>>(object: I): WebcastLinkMicArmiesItems {
    const message = createBaseWebcastLinkMicArmiesItems();
    message.hostUserId = object.hostUserId ?? "0";
    message.battleGroups = object.battleGroups?.map((e) => WebcastLinkMicArmiesGroup.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWebcastLinkMicArmiesGroup(): WebcastLinkMicArmiesGroup {
  return { users: [], points: 0 };
}

export const WebcastLinkMicArmiesGroup: MessageFns<WebcastLinkMicArmiesGroup> = {
  encode(message: WebcastLinkMicArmiesGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.users) {
      User.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.points !== 0) {
      writer.uint32(16).int32(message.points);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicArmiesGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicArmiesGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.points = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastLinkMicArmiesGroup {
    return {
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => User.fromJSON(e)) : [],
      points: isSet(object.points) ? globalThis.Number(object.points) : 0,
    };
  },

  toJSON(message: WebcastLinkMicArmiesGroup): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users.map((e) => User.toJSON(e));
    }
    if (message.points !== 0) {
      obj.points = Math.round(message.points);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastLinkMicArmiesGroup>, I>>(base?: I): WebcastLinkMicArmiesGroup {
    return WebcastLinkMicArmiesGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastLinkMicArmiesGroup>, I>>(object: I): WebcastLinkMicArmiesGroup {
    const message = createBaseWebcastLinkMicArmiesGroup();
    message.users = object.users?.map((e) => User.fromPartial(e)) || [];
    message.points = object.points ?? 0;
    return message;
  },
};

function createBaseWebcastSocialMessage(): WebcastSocialMessage {
  return { event: undefined, user: undefined };
}

export const WebcastSocialMessage: MessageFns<WebcastSocialMessage> = {
  encode(message: WebcastSocialMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== undefined) {
      WebcastMessageEvent.encode(message.event, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastSocialMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastSocialMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = WebcastMessageEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastSocialMessage {
    return {
      event: isSet(object.event) ? WebcastMessageEvent.fromJSON(object.event) : undefined,
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: WebcastSocialMessage): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = WebcastMessageEvent.toJSON(message.event);
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastSocialMessage>, I>>(base?: I): WebcastSocialMessage {
    return WebcastSocialMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastSocialMessage>, I>>(object: I): WebcastSocialMessage {
    const message = createBaseWebcastSocialMessage();
    message.event = (object.event !== undefined && object.event !== null)
      ? WebcastMessageEvent.fromPartial(object.event)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseWebcastLikeMessage(): WebcastLikeMessage {
  return { event: undefined, user: undefined, likeCount: 0, totalLikeCount: 0 };
}

export const WebcastLikeMessage: MessageFns<WebcastLikeMessage> = {
  encode(message: WebcastLikeMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== undefined) {
      WebcastMessageEvent.encode(message.event, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.likeCount !== 0) {
      writer.uint32(16).int32(message.likeCount);
    }
    if (message.totalLikeCount !== 0) {
      writer.uint32(24).int32(message.totalLikeCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLikeMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLikeMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = WebcastMessageEvent.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.likeCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalLikeCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastLikeMessage {
    return {
      event: isSet(object.event) ? WebcastMessageEvent.fromJSON(object.event) : undefined,
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      likeCount: isSet(object.likeCount) ? globalThis.Number(object.likeCount) : 0,
      totalLikeCount: isSet(object.totalLikeCount) ? globalThis.Number(object.totalLikeCount) : 0,
    };
  },

  toJSON(message: WebcastLikeMessage): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = WebcastMessageEvent.toJSON(message.event);
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.likeCount !== 0) {
      obj.likeCount = Math.round(message.likeCount);
    }
    if (message.totalLikeCount !== 0) {
      obj.totalLikeCount = Math.round(message.totalLikeCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastLikeMessage>, I>>(base?: I): WebcastLikeMessage {
    return WebcastLikeMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastLikeMessage>, I>>(object: I): WebcastLikeMessage {
    const message = createBaseWebcastLikeMessage();
    message.event = (object.event !== undefined && object.event !== null)
      ? WebcastMessageEvent.fromPartial(object.event)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.likeCount = object.likeCount ?? 0;
    message.totalLikeCount = object.totalLikeCount ?? 0;
    return message;
  },
};

function createBaseWebcastQuestionNewMessage(): WebcastQuestionNewMessage {
  return { questionDetails: undefined };
}

export const WebcastQuestionNewMessage: MessageFns<WebcastQuestionNewMessage> = {
  encode(message: WebcastQuestionNewMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.questionDetails !== undefined) {
      QuestionDetails.encode(message.questionDetails, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastQuestionNewMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastQuestionNewMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.questionDetails = QuestionDetails.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastQuestionNewMessage {
    return {
      questionDetails: isSet(object.questionDetails) ? QuestionDetails.fromJSON(object.questionDetails) : undefined,
    };
  },

  toJSON(message: WebcastQuestionNewMessage): unknown {
    const obj: any = {};
    if (message.questionDetails !== undefined) {
      obj.questionDetails = QuestionDetails.toJSON(message.questionDetails);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastQuestionNewMessage>, I>>(base?: I): WebcastQuestionNewMessage {
    return WebcastQuestionNewMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastQuestionNewMessage>, I>>(object: I): WebcastQuestionNewMessage {
    const message = createBaseWebcastQuestionNewMessage();
    message.questionDetails = (object.questionDetails !== undefined && object.questionDetails !== null)
      ? QuestionDetails.fromPartial(object.questionDetails)
      : undefined;
    return message;
  },
};

function createBaseQuestionDetails(): QuestionDetails {
  return { questionText: "", user: undefined };
}

export const QuestionDetails: MessageFns<QuestionDetails> = {
  encode(message: QuestionDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.questionText !== "") {
      writer.uint32(18).string(message.questionText);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuestionDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.questionText = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionDetails {
    return {
      questionText: isSet(object.questionText) ? globalThis.String(object.questionText) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: QuestionDetails): unknown {
    const obj: any = {};
    if (message.questionText !== "") {
      obj.questionText = message.questionText;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuestionDetails>, I>>(base?: I): QuestionDetails {
    return QuestionDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuestionDetails>, I>>(object: I): QuestionDetails {
    const message = createBaseQuestionDetails();
    message.questionText = object.questionText ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseWebcastMessageEvent(): WebcastMessageEvent {
  return { msgId: "0", createTime: "0", eventDetails: undefined };
}

export const WebcastMessageEvent: MessageFns<WebcastMessageEvent> = {
  encode(message: WebcastMessageEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msgId !== "0") {
      writer.uint32(16).uint64(message.msgId);
    }
    if (message.createTime !== "0") {
      writer.uint32(32).uint64(message.createTime);
    }
    if (message.eventDetails !== undefined) {
      WebcastMessageEventDetails.encode(message.eventDetails, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMessageEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMessageEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.msgId = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.createTime = reader.uint64().toString();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.eventDetails = WebcastMessageEventDetails.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastMessageEvent {
    return {
      msgId: isSet(object.msgId) ? globalThis.String(object.msgId) : "0",
      createTime: isSet(object.createTime) ? globalThis.String(object.createTime) : "0",
      eventDetails: isSet(object.eventDetails) ? WebcastMessageEventDetails.fromJSON(object.eventDetails) : undefined,
    };
  },

  toJSON(message: WebcastMessageEvent): unknown {
    const obj: any = {};
    if (message.msgId !== "0") {
      obj.msgId = message.msgId;
    }
    if (message.createTime !== "0") {
      obj.createTime = message.createTime;
    }
    if (message.eventDetails !== undefined) {
      obj.eventDetails = WebcastMessageEventDetails.toJSON(message.eventDetails);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastMessageEvent>, I>>(base?: I): WebcastMessageEvent {
    return WebcastMessageEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastMessageEvent>, I>>(object: I): WebcastMessageEvent {
    const message = createBaseWebcastMessageEvent();
    message.msgId = object.msgId ?? "0";
    message.createTime = object.createTime ?? "0";
    message.eventDetails = (object.eventDetails !== undefined && object.eventDetails !== null)
      ? WebcastMessageEventDetails.fromPartial(object.eventDetails)
      : undefined;
    return message;
  },
};

function createBaseWebcastMessageEventDetails(): WebcastMessageEventDetails {
  return { displayType: "", label: "" };
}

export const WebcastMessageEventDetails: MessageFns<WebcastMessageEventDetails> = {
  encode(message: WebcastMessageEventDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayType !== "") {
      writer.uint32(10).string(message.displayType);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMessageEventDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMessageEventDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastMessageEventDetails {
    return {
      displayType: isSet(object.displayType) ? globalThis.String(object.displayType) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
    };
  },

  toJSON(message: WebcastMessageEventDetails): unknown {
    const obj: any = {};
    if (message.displayType !== "") {
      obj.displayType = message.displayType;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastMessageEventDetails>, I>>(base?: I): WebcastMessageEventDetails {
    return WebcastMessageEventDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastMessageEventDetails>, I>>(object: I): WebcastMessageEventDetails {
    const message = createBaseWebcastMessageEventDetails();
    message.displayType = object.displayType ?? "";
    message.label = object.label ?? "";
    return message;
  },
};

function createBaseWebcastLiveIntroMessage(): WebcastLiveIntroMessage {
  return { id: "0", description: "", user: undefined };
}

export const WebcastLiveIntroMessage: MessageFns<WebcastLiveIntroMessage> = {
  encode(message: WebcastLiveIntroMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(16).uint64(message.id);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLiveIntroMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLiveIntroMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastLiveIntroMessage {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "0",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: WebcastLiveIntroMessage): unknown {
    const obj: any = {};
    if (message.id !== "0") {
      obj.id = message.id;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastLiveIntroMessage>, I>>(base?: I): WebcastLiveIntroMessage {
    return WebcastLiveIntroMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastLiveIntroMessage>, I>>(object: I): WebcastLiveIntroMessage {
    const message = createBaseWebcastLiveIntroMessage();
    message.id = object.id ?? "0";
    message.description = object.description ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseSystemMessage(): SystemMessage {
  return { description: "" };
}

export const SystemMessage: MessageFns<SystemMessage> = {
  encode(message: SystemMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SystemMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemMessage {
    return { description: isSet(object.description) ? globalThis.String(object.description) : "" };
  },

  toJSON(message: SystemMessage): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SystemMessage>, I>>(base?: I): SystemMessage {
    return SystemMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SystemMessage>, I>>(object: I): SystemMessage {
    const message = createBaseSystemMessage();
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseWebcastInRoomBannerMessage(): WebcastInRoomBannerMessage {
  return { data: "" };
}

export const WebcastInRoomBannerMessage: MessageFns<WebcastInRoomBannerMessage> = {
  encode(message: WebcastInRoomBannerMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== "") {
      writer.uint32(18).string(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastInRoomBannerMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastInRoomBannerMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastInRoomBannerMessage {
    return { data: isSet(object.data) ? globalThis.String(object.data) : "" };
  },

  toJSON(message: WebcastInRoomBannerMessage): unknown {
    const obj: any = {};
    if (message.data !== "") {
      obj.data = message.data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastInRoomBannerMessage>, I>>(base?: I): WebcastInRoomBannerMessage {
    return WebcastInRoomBannerMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastInRoomBannerMessage>, I>>(object: I): WebcastInRoomBannerMessage {
    const message = createBaseWebcastInRoomBannerMessage();
    message.data = object.data ?? "";
    return message;
  },
};

function createBaseRankItem(): RankItem {
  return { colour: "", id: "0" };
}

export const RankItem: MessageFns<RankItem> = {
  encode(message: RankItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.colour !== "") {
      writer.uint32(10).string(message.colour);
    }
    if (message.id !== "0") {
      writer.uint32(32).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RankItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRankItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.colour = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.id = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RankItem {
    return {
      colour: isSet(object.colour) ? globalThis.String(object.colour) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "0",
    };
  },

  toJSON(message: RankItem): unknown {
    const obj: any = {};
    if (message.colour !== "") {
      obj.colour = message.colour;
    }
    if (message.id !== "0") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RankItem>, I>>(base?: I): RankItem {
    return RankItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RankItem>, I>>(object: I): RankItem {
    const message = createBaseRankItem();
    message.colour = object.colour ?? "";
    message.id = object.id ?? "0";
    return message;
  },
};

function createBaseWeeklyRanking(): WeeklyRanking {
  return { type: "", label: "", rank: undefined };
}

export const WeeklyRanking: MessageFns<WeeklyRanking> = {
  encode(message: WeeklyRanking, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.rank !== undefined) {
      RankItem.encode(message.rank, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WeeklyRanking {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWeeklyRanking();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rank = RankItem.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WeeklyRanking {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      rank: isSet(object.rank) ? RankItem.fromJSON(object.rank) : undefined,
    };
  },

  toJSON(message: WeeklyRanking): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.rank !== undefined) {
      obj.rank = RankItem.toJSON(message.rank);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WeeklyRanking>, I>>(base?: I): WeeklyRanking {
    return WeeklyRanking.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WeeklyRanking>, I>>(object: I): WeeklyRanking {
    const message = createBaseWeeklyRanking();
    message.type = object.type ?? "";
    message.label = object.label ?? "";
    message.rank = (object.rank !== undefined && object.rank !== null) ? RankItem.fromPartial(object.rank) : undefined;
    return message;
  },
};

function createBaseRankContainer(): RankContainer {
  return { rankings: undefined };
}

export const RankContainer: MessageFns<RankContainer> = {
  encode(message: RankContainer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rankings !== undefined) {
      WeeklyRanking.encode(message.rankings, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RankContainer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRankContainer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rankings = WeeklyRanking.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RankContainer {
    return { rankings: isSet(object.rankings) ? WeeklyRanking.fromJSON(object.rankings) : undefined };
  },

  toJSON(message: RankContainer): unknown {
    const obj: any = {};
    if (message.rankings !== undefined) {
      obj.rankings = WeeklyRanking.toJSON(message.rankings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RankContainer>, I>>(base?: I): RankContainer {
    return RankContainer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RankContainer>, I>>(object: I): RankContainer {
    const message = createBaseRankContainer();
    message.rankings = (object.rankings !== undefined && object.rankings !== null)
      ? WeeklyRanking.fromPartial(object.rankings)
      : undefined;
    return message;
  },
};

function createBaseWebcastHourlyRankMessage(): WebcastHourlyRankMessage {
  return { data: undefined };
}

export const WebcastHourlyRankMessage: MessageFns<WebcastHourlyRankMessage> = {
  encode(message: WebcastHourlyRankMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      RankContainer.encode(message.data, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastHourlyRankMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastHourlyRankMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = RankContainer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastHourlyRankMessage {
    return { data: isSet(object.data) ? RankContainer.fromJSON(object.data) : undefined };
  },

  toJSON(message: WebcastHourlyRankMessage): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = RankContainer.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastHourlyRankMessage>, I>>(base?: I): WebcastHourlyRankMessage {
    return WebcastHourlyRankMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastHourlyRankMessage>, I>>(object: I): WebcastHourlyRankMessage {
    const message = createBaseWebcastHourlyRankMessage();
    message.data = (object.data !== undefined && object.data !== null)
      ? RankContainer.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function createBaseEmoteDetails(): EmoteDetails {
  return { emoteId: "", image: undefined };
}

export const EmoteDetails: MessageFns<EmoteDetails> = {
  encode(message: EmoteDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.emoteId !== "") {
      writer.uint32(10).string(message.emoteId);
    }
    if (message.image !== undefined) {
      EmoteImage.encode(message.image, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmoteDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmoteDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.emoteId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.image = EmoteImage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmoteDetails {
    return {
      emoteId: isSet(object.emoteId) ? globalThis.String(object.emoteId) : "",
      image: isSet(object.image) ? EmoteImage.fromJSON(object.image) : undefined,
    };
  },

  toJSON(message: EmoteDetails): unknown {
    const obj: any = {};
    if (message.emoteId !== "") {
      obj.emoteId = message.emoteId;
    }
    if (message.image !== undefined) {
      obj.image = EmoteImage.toJSON(message.image);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmoteDetails>, I>>(base?: I): EmoteDetails {
    return EmoteDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmoteDetails>, I>>(object: I): EmoteDetails {
    const message = createBaseEmoteDetails();
    message.emoteId = object.emoteId ?? "";
    message.image = (object.image !== undefined && object.image !== null)
      ? EmoteImage.fromPartial(object.image)
      : undefined;
    return message;
  },
};

function createBaseEmoteImage(): EmoteImage {
  return { imageUrl: "" };
}

export const EmoteImage: MessageFns<EmoteImage> = {
  encode(message: EmoteImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageUrl !== "") {
      writer.uint32(10).string(message.imageUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmoteImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmoteImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmoteImage {
    return { imageUrl: isSet(object.imageUrl) ? globalThis.String(object.imageUrl) : "" };
  },

  toJSON(message: EmoteImage): unknown {
    const obj: any = {};
    if (message.imageUrl !== "") {
      obj.imageUrl = message.imageUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmoteImage>, I>>(base?: I): EmoteImage {
    return EmoteImage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmoteImage>, I>>(object: I): EmoteImage {
    const message = createBaseEmoteImage();
    message.imageUrl = object.imageUrl ?? "";
    return message;
  },
};

function createBaseWebcastEnvelopeMessage(): WebcastEnvelopeMessage {
  return { treasureBoxData: undefined, treasureBoxUser: undefined };
}

export const WebcastEnvelopeMessage: MessageFns<WebcastEnvelopeMessage> = {
  encode(message: WebcastEnvelopeMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.treasureBoxData !== undefined) {
      TreasureBoxData.encode(message.treasureBoxData, writer.uint32(18).fork()).join();
    }
    if (message.treasureBoxUser !== undefined) {
      TreasureBoxUser.encode(message.treasureBoxUser, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastEnvelopeMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastEnvelopeMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.treasureBoxData = TreasureBoxData.decode(reader, reader.uint32());
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.treasureBoxUser = TreasureBoxUser.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastEnvelopeMessage {
    return {
      treasureBoxData: isSet(object.treasureBoxData) ? TreasureBoxData.fromJSON(object.treasureBoxData) : undefined,
      treasureBoxUser: isSet(object.treasureBoxUser) ? TreasureBoxUser.fromJSON(object.treasureBoxUser) : undefined,
    };
  },

  toJSON(message: WebcastEnvelopeMessage): unknown {
    const obj: any = {};
    if (message.treasureBoxData !== undefined) {
      obj.treasureBoxData = TreasureBoxData.toJSON(message.treasureBoxData);
    }
    if (message.treasureBoxUser !== undefined) {
      obj.treasureBoxUser = TreasureBoxUser.toJSON(message.treasureBoxUser);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastEnvelopeMessage>, I>>(base?: I): WebcastEnvelopeMessage {
    return WebcastEnvelopeMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastEnvelopeMessage>, I>>(object: I): WebcastEnvelopeMessage {
    const message = createBaseWebcastEnvelopeMessage();
    message.treasureBoxData = (object.treasureBoxData !== undefined && object.treasureBoxData !== null)
      ? TreasureBoxData.fromPartial(object.treasureBoxData)
      : undefined;
    message.treasureBoxUser = (object.treasureBoxUser !== undefined && object.treasureBoxUser !== null)
      ? TreasureBoxUser.fromPartial(object.treasureBoxUser)
      : undefined;
    return message;
  },
};

function createBaseTreasureBoxUser(): TreasureBoxUser {
  return { user2: undefined };
}

export const TreasureBoxUser: MessageFns<TreasureBoxUser> = {
  encode(message: TreasureBoxUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user2 !== undefined) {
      TreasureBoxUser2.encode(message.user2, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreasureBoxUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreasureBoxUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.user2 = TreasureBoxUser2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreasureBoxUser {
    return { user2: isSet(object.user2) ? TreasureBoxUser2.fromJSON(object.user2) : undefined };
  },

  toJSON(message: TreasureBoxUser): unknown {
    const obj: any = {};
    if (message.user2 !== undefined) {
      obj.user2 = TreasureBoxUser2.toJSON(message.user2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TreasureBoxUser>, I>>(base?: I): TreasureBoxUser {
    return TreasureBoxUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TreasureBoxUser>, I>>(object: I): TreasureBoxUser {
    const message = createBaseTreasureBoxUser();
    message.user2 = (object.user2 !== undefined && object.user2 !== null)
      ? TreasureBoxUser2.fromPartial(object.user2)
      : undefined;
    return message;
  },
};

function createBaseTreasureBoxUser2(): TreasureBoxUser2 {
  return { user3: [] };
}

export const TreasureBoxUser2: MessageFns<TreasureBoxUser2> = {
  encode(message: TreasureBoxUser2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.user3) {
      TreasureBoxUser3.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreasureBoxUser2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreasureBoxUser2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.user3.push(TreasureBoxUser3.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreasureBoxUser2 {
    return {
      user3: globalThis.Array.isArray(object?.user3) ? object.user3.map((e: any) => TreasureBoxUser3.fromJSON(e)) : [],
    };
  },

  toJSON(message: TreasureBoxUser2): unknown {
    const obj: any = {};
    if (message.user3?.length) {
      obj.user3 = message.user3.map((e) => TreasureBoxUser3.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TreasureBoxUser2>, I>>(base?: I): TreasureBoxUser2 {
    return TreasureBoxUser2.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TreasureBoxUser2>, I>>(object: I): TreasureBoxUser2 {
    const message = createBaseTreasureBoxUser2();
    message.user3 = object.user3?.map((e) => TreasureBoxUser3.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTreasureBoxUser3(): TreasureBoxUser3 {
  return { user4: undefined };
}

export const TreasureBoxUser3: MessageFns<TreasureBoxUser3> = {
  encode(message: TreasureBoxUser3, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user4 !== undefined) {
      TreasureBoxUser4.encode(message.user4, writer.uint32(170).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreasureBoxUser3 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreasureBoxUser3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.user4 = TreasureBoxUser4.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreasureBoxUser3 {
    return { user4: isSet(object.user4) ? TreasureBoxUser4.fromJSON(object.user4) : undefined };
  },

  toJSON(message: TreasureBoxUser3): unknown {
    const obj: any = {};
    if (message.user4 !== undefined) {
      obj.user4 = TreasureBoxUser4.toJSON(message.user4);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TreasureBoxUser3>, I>>(base?: I): TreasureBoxUser3 {
    return TreasureBoxUser3.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TreasureBoxUser3>, I>>(object: I): TreasureBoxUser3 {
    const message = createBaseTreasureBoxUser3();
    message.user4 = (object.user4 !== undefined && object.user4 !== null)
      ? TreasureBoxUser4.fromPartial(object.user4)
      : undefined;
    return message;
  },
};

function createBaseTreasureBoxUser4(): TreasureBoxUser4 {
  return { user: undefined };
}

export const TreasureBoxUser4: MessageFns<TreasureBoxUser4> = {
  encode(message: TreasureBoxUser4, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreasureBoxUser4 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreasureBoxUser4();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreasureBoxUser4 {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  },

  toJSON(message: TreasureBoxUser4): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TreasureBoxUser4>, I>>(base?: I): TreasureBoxUser4 {
    return TreasureBoxUser4.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TreasureBoxUser4>, I>>(object: I): TreasureBoxUser4 {
    const message = createBaseTreasureBoxUser4();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseTreasureBoxData(): TreasureBoxData {
  return { coins: 0, canOpen: 0, timestamp: "0" };
}

export const TreasureBoxData: MessageFns<TreasureBoxData> = {
  encode(message: TreasureBoxData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coins !== 0) {
      writer.uint32(40).uint32(message.coins);
    }
    if (message.canOpen !== 0) {
      writer.uint32(48).uint32(message.canOpen);
    }
    if (message.timestamp !== "0") {
      writer.uint32(56).uint64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreasureBoxData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreasureBoxData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.coins = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.canOpen = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.timestamp = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreasureBoxData {
    return {
      coins: isSet(object.coins) ? globalThis.Number(object.coins) : 0,
      canOpen: isSet(object.canOpen) ? globalThis.Number(object.canOpen) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "0",
    };
  },

  toJSON(message: TreasureBoxData): unknown {
    const obj: any = {};
    if (message.coins !== 0) {
      obj.coins = Math.round(message.coins);
    }
    if (message.canOpen !== 0) {
      obj.canOpen = Math.round(message.canOpen);
    }
    if (message.timestamp !== "0") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TreasureBoxData>, I>>(base?: I): TreasureBoxData {
    return TreasureBoxData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TreasureBoxData>, I>>(object: I): TreasureBoxData {
    const message = createBaseTreasureBoxData();
    message.coins = object.coins ?? 0;
    message.canOpen = object.canOpen ?? 0;
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseWebcastSubNotifyMessage(): WebcastSubNotifyMessage {
  return {
    event: undefined,
    user: undefined,
    exhibitionType: 0,
    subMonth: 0,
    subscribeType: 0,
    oldSubscribeStatus: 0,
    subscribingStatus: 0,
  };
}

export const WebcastSubNotifyMessage: MessageFns<WebcastSubNotifyMessage> = {
  encode(message: WebcastSubNotifyMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== undefined) {
      WebcastMessageEvent.encode(message.event, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.exhibitionType !== 0) {
      writer.uint32(24).int32(message.exhibitionType);
    }
    if (message.subMonth !== 0) {
      writer.uint32(32).int32(message.subMonth);
    }
    if (message.subscribeType !== 0) {
      writer.uint32(40).int32(message.subscribeType);
    }
    if (message.oldSubscribeStatus !== 0) {
      writer.uint32(48).int32(message.oldSubscribeStatus);
    }
    if (message.subscribingStatus !== 0) {
      writer.uint32(64).int32(message.subscribingStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastSubNotifyMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastSubNotifyMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = WebcastMessageEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.exhibitionType = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.subMonth = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.subscribeType = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.oldSubscribeStatus = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.subscribingStatus = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastSubNotifyMessage {
    return {
      event: isSet(object.event) ? WebcastMessageEvent.fromJSON(object.event) : undefined,
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      exhibitionType: isSet(object.exhibitionType) ? globalThis.Number(object.exhibitionType) : 0,
      subMonth: isSet(object.subMonth) ? globalThis.Number(object.subMonth) : 0,
      subscribeType: isSet(object.subscribeType) ? globalThis.Number(object.subscribeType) : 0,
      oldSubscribeStatus: isSet(object.oldSubscribeStatus) ? globalThis.Number(object.oldSubscribeStatus) : 0,
      subscribingStatus: isSet(object.subscribingStatus) ? globalThis.Number(object.subscribingStatus) : 0,
    };
  },

  toJSON(message: WebcastSubNotifyMessage): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = WebcastMessageEvent.toJSON(message.event);
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.exhibitionType !== 0) {
      obj.exhibitionType = Math.round(message.exhibitionType);
    }
    if (message.subMonth !== 0) {
      obj.subMonth = Math.round(message.subMonth);
    }
    if (message.subscribeType !== 0) {
      obj.subscribeType = Math.round(message.subscribeType);
    }
    if (message.oldSubscribeStatus !== 0) {
      obj.oldSubscribeStatus = Math.round(message.oldSubscribeStatus);
    }
    if (message.subscribingStatus !== 0) {
      obj.subscribingStatus = Math.round(message.subscribingStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastSubNotifyMessage>, I>>(base?: I): WebcastSubNotifyMessage {
    return WebcastSubNotifyMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastSubNotifyMessage>, I>>(object: I): WebcastSubNotifyMessage {
    const message = createBaseWebcastSubNotifyMessage();
    message.event = (object.event !== undefined && object.event !== null)
      ? WebcastMessageEvent.fromPartial(object.event)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.exhibitionType = object.exhibitionType ?? 0;
    message.subMonth = object.subMonth ?? 0;
    message.subscribeType = object.subscribeType ?? 0;
    message.oldSubscribeStatus = object.oldSubscribeStatus ?? 0;
    message.subscribingStatus = object.subscribingStatus ?? 0;
    return message;
  },
};

function createBaseUser(): User {
  return {
    userId: "0",
    nickname: "",
    profilePicture: undefined,
    uniqueId: "",
    secUid: "",
    badges: [],
    createTime: "0",
    bioDescription: "",
    followInfo: undefined,
  };
}

export const User: MessageFns<User> = {
  encode(message: User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.nickname !== "") {
      writer.uint32(26).string(message.nickname);
    }
    if (message.profilePicture !== undefined) {
      ProfilePicture.encode(message.profilePicture, writer.uint32(74).fork()).join();
    }
    if (message.uniqueId !== "") {
      writer.uint32(306).string(message.uniqueId);
    }
    if (message.secUid !== "") {
      writer.uint32(370).string(message.secUid);
    }
    for (const v of message.badges) {
      UserBadgesAttributes.encode(v!, writer.uint32(514).fork()).join();
    }
    if (message.createTime !== "0") {
      writer.uint32(128).uint64(message.createTime);
    }
    if (message.bioDescription !== "") {
      writer.uint32(42).string(message.bioDescription);
    }
    if (message.followInfo !== undefined) {
      FollowInfo.encode(message.followInfo, writer.uint32(178).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.profilePicture = ProfilePicture.decode(reader, reader.uint32());
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.uniqueId = reader.string();
          continue;
        }
        case 46: {
          if (tag !== 370) {
            break;
          }

          message.secUid = reader.string();
          continue;
        }
        case 64: {
          if (tag !== 514) {
            break;
          }

          message.badges.push(UserBadgesAttributes.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.createTime = reader.uint64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bioDescription = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.followInfo = FollowInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "0",
      nickname: isSet(object.nickname) ? globalThis.String(object.nickname) : "",
      profilePicture: isSet(object.profilePicture) ? ProfilePicture.fromJSON(object.profilePicture) : undefined,
      uniqueId: isSet(object.uniqueId) ? globalThis.String(object.uniqueId) : "",
      secUid: isSet(object.secUid) ? globalThis.String(object.secUid) : "",
      badges: globalThis.Array.isArray(object?.badges)
        ? object.badges.map((e: any) => UserBadgesAttributes.fromJSON(e))
        : [],
      createTime: isSet(object.createTime) ? globalThis.String(object.createTime) : "0",
      bioDescription: isSet(object.bioDescription) ? globalThis.String(object.bioDescription) : "",
      followInfo: isSet(object.followInfo) ? FollowInfo.fromJSON(object.followInfo) : undefined,
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.userId !== "0") {
      obj.userId = message.userId;
    }
    if (message.nickname !== "") {
      obj.nickname = message.nickname;
    }
    if (message.profilePicture !== undefined) {
      obj.profilePicture = ProfilePicture.toJSON(message.profilePicture);
    }
    if (message.uniqueId !== "") {
      obj.uniqueId = message.uniqueId;
    }
    if (message.secUid !== "") {
      obj.secUid = message.secUid;
    }
    if (message.badges?.length) {
      obj.badges = message.badges.map((e) => UserBadgesAttributes.toJSON(e));
    }
    if (message.createTime !== "0") {
      obj.createTime = message.createTime;
    }
    if (message.bioDescription !== "") {
      obj.bioDescription = message.bioDescription;
    }
    if (message.followInfo !== undefined) {
      obj.followInfo = FollowInfo.toJSON(message.followInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.userId = object.userId ?? "0";
    message.nickname = object.nickname ?? "";
    message.profilePicture = (object.profilePicture !== undefined && object.profilePicture !== null)
      ? ProfilePicture.fromPartial(object.profilePicture)
      : undefined;
    message.uniqueId = object.uniqueId ?? "";
    message.secUid = object.secUid ?? "";
    message.badges = object.badges?.map((e) => UserBadgesAttributes.fromPartial(e)) || [];
    message.createTime = object.createTime ?? "0";
    message.bioDescription = object.bioDescription ?? "";
    message.followInfo = (object.followInfo !== undefined && object.followInfo !== null)
      ? FollowInfo.fromPartial(object.followInfo)
      : undefined;
    return message;
  },
};

function createBaseFollowInfo(): FollowInfo {
  return { followingCount: 0, followerCount: 0, followStatus: 0, pushStatus: 0 };
}

export const FollowInfo: MessageFns<FollowInfo> = {
  encode(message: FollowInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.followingCount !== 0) {
      writer.uint32(8).int32(message.followingCount);
    }
    if (message.followerCount !== 0) {
      writer.uint32(16).int32(message.followerCount);
    }
    if (message.followStatus !== 0) {
      writer.uint32(24).int32(message.followStatus);
    }
    if (message.pushStatus !== 0) {
      writer.uint32(32).int32(message.pushStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FollowInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFollowInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.followingCount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.followerCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.followStatus = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pushStatus = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FollowInfo {
    return {
      followingCount: isSet(object.followingCount) ? globalThis.Number(object.followingCount) : 0,
      followerCount: isSet(object.followerCount) ? globalThis.Number(object.followerCount) : 0,
      followStatus: isSet(object.followStatus) ? globalThis.Number(object.followStatus) : 0,
      pushStatus: isSet(object.pushStatus) ? globalThis.Number(object.pushStatus) : 0,
    };
  },

  toJSON(message: FollowInfo): unknown {
    const obj: any = {};
    if (message.followingCount !== 0) {
      obj.followingCount = Math.round(message.followingCount);
    }
    if (message.followerCount !== 0) {
      obj.followerCount = Math.round(message.followerCount);
    }
    if (message.followStatus !== 0) {
      obj.followStatus = Math.round(message.followStatus);
    }
    if (message.pushStatus !== 0) {
      obj.pushStatus = Math.round(message.pushStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FollowInfo>, I>>(base?: I): FollowInfo {
    return FollowInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FollowInfo>, I>>(object: I): FollowInfo {
    const message = createBaseFollowInfo();
    message.followingCount = object.followingCount ?? 0;
    message.followerCount = object.followerCount ?? 0;
    message.followStatus = object.followStatus ?? 0;
    message.pushStatus = object.pushStatus ?? 0;
    return message;
  },
};

function createBaseLinkUser(): LinkUser {
  return { userId: "0", nickname: "", profilePicture: undefined, uniqueId: "" };
}

export const LinkUser: MessageFns<LinkUser> = {
  encode(message: LinkUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.nickname !== "") {
      writer.uint32(18).string(message.nickname);
    }
    if (message.profilePicture !== undefined) {
      ProfilePicture.encode(message.profilePicture, writer.uint32(26).fork()).join();
    }
    if (message.uniqueId !== "") {
      writer.uint32(34).string(message.uniqueId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.profilePicture = ProfilePicture.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.uniqueId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinkUser {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "0",
      nickname: isSet(object.nickname) ? globalThis.String(object.nickname) : "",
      profilePicture: isSet(object.profilePicture) ? ProfilePicture.fromJSON(object.profilePicture) : undefined,
      uniqueId: isSet(object.uniqueId) ? globalThis.String(object.uniqueId) : "",
    };
  },

  toJSON(message: LinkUser): unknown {
    const obj: any = {};
    if (message.userId !== "0") {
      obj.userId = message.userId;
    }
    if (message.nickname !== "") {
      obj.nickname = message.nickname;
    }
    if (message.profilePicture !== undefined) {
      obj.profilePicture = ProfilePicture.toJSON(message.profilePicture);
    }
    if (message.uniqueId !== "") {
      obj.uniqueId = message.uniqueId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LinkUser>, I>>(base?: I): LinkUser {
    return LinkUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkUser>, I>>(object: I): LinkUser {
    const message = createBaseLinkUser();
    message.userId = object.userId ?? "0";
    message.nickname = object.nickname ?? "";
    message.profilePicture = (object.profilePicture !== undefined && object.profilePicture !== null)
      ? ProfilePicture.fromPartial(object.profilePicture)
      : undefined;
    message.uniqueId = object.uniqueId ?? "";
    return message;
  },
};

function createBaseProfilePicture(): ProfilePicture {
  return { urls: [] };
}

export const ProfilePicture: MessageFns<ProfilePicture> = {
  encode(message: ProfilePicture, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.urls) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProfilePicture {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProfilePicture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.urls.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProfilePicture {
    return { urls: globalThis.Array.isArray(object?.urls) ? object.urls.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: ProfilePicture): unknown {
    const obj: any = {};
    if (message.urls?.length) {
      obj.urls = message.urls;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProfilePicture>, I>>(base?: I): ProfilePicture {
    return ProfilePicture.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProfilePicture>, I>>(object: I): ProfilePicture {
    const message = createBaseProfilePicture();
    message.urls = object.urls?.map((e) => e) || [];
    return message;
  },
};

function createBaseUserBadgesAttributes(): UserBadgesAttributes {
  return { badgeSceneType: 0, imageBadges: [], badges: [], privilegeLogExtra: undefined };
}

export const UserBadgesAttributes: MessageFns<UserBadgesAttributes> = {
  encode(message: UserBadgesAttributes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.badgeSceneType !== 0) {
      writer.uint32(24).int32(message.badgeSceneType);
    }
    for (const v of message.imageBadges) {
      UserImageBadge.encode(v!, writer.uint32(162).fork()).join();
    }
    for (const v of message.badges) {
      UserBadge.encode(v!, writer.uint32(170).fork()).join();
    }
    if (message.privilegeLogExtra !== undefined) {
      PrivilegeLogExtra.encode(message.privilegeLogExtra, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserBadgesAttributes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserBadgesAttributes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.badgeSceneType = reader.int32();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.imageBadges.push(UserImageBadge.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.badges.push(UserBadge.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.privilegeLogExtra = PrivilegeLogExtra.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserBadgesAttributes {
    return {
      badgeSceneType: isSet(object.badgeSceneType) ? globalThis.Number(object.badgeSceneType) : 0,
      imageBadges: globalThis.Array.isArray(object?.imageBadges)
        ? object.imageBadges.map((e: any) => UserImageBadge.fromJSON(e))
        : [],
      badges: globalThis.Array.isArray(object?.badges) ? object.badges.map((e: any) => UserBadge.fromJSON(e)) : [],
      privilegeLogExtra: isSet(object.privilegeLogExtra)
        ? PrivilegeLogExtra.fromJSON(object.privilegeLogExtra)
        : undefined,
    };
  },

  toJSON(message: UserBadgesAttributes): unknown {
    const obj: any = {};
    if (message.badgeSceneType !== 0) {
      obj.badgeSceneType = Math.round(message.badgeSceneType);
    }
    if (message.imageBadges?.length) {
      obj.imageBadges = message.imageBadges.map((e) => UserImageBadge.toJSON(e));
    }
    if (message.badges?.length) {
      obj.badges = message.badges.map((e) => UserBadge.toJSON(e));
    }
    if (message.privilegeLogExtra !== undefined) {
      obj.privilegeLogExtra = PrivilegeLogExtra.toJSON(message.privilegeLogExtra);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserBadgesAttributes>, I>>(base?: I): UserBadgesAttributes {
    return UserBadgesAttributes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserBadgesAttributes>, I>>(object: I): UserBadgesAttributes {
    const message = createBaseUserBadgesAttributes();
    message.badgeSceneType = object.badgeSceneType ?? 0;
    message.imageBadges = object.imageBadges?.map((e) => UserImageBadge.fromPartial(e)) || [];
    message.badges = object.badges?.map((e) => UserBadge.fromPartial(e)) || [];
    message.privilegeLogExtra = (object.privilegeLogExtra !== undefined && object.privilegeLogExtra !== null)
      ? PrivilegeLogExtra.fromPartial(object.privilegeLogExtra)
      : undefined;
    return message;
  },
};

function createBasePrivilegeLogExtra(): PrivilegeLogExtra {
  return { privilegeId: "", level: "" };
}

export const PrivilegeLogExtra: MessageFns<PrivilegeLogExtra> = {
  encode(message: PrivilegeLogExtra, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.privilegeId !== "") {
      writer.uint32(18).string(message.privilegeId);
    }
    if (message.level !== "") {
      writer.uint32(42).string(message.level);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivilegeLogExtra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivilegeLogExtra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.privilegeId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.level = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrivilegeLogExtra {
    return {
      privilegeId: isSet(object.privilegeId) ? globalThis.String(object.privilegeId) : "",
      level: isSet(object.level) ? globalThis.String(object.level) : "",
    };
  },

  toJSON(message: PrivilegeLogExtra): unknown {
    const obj: any = {};
    if (message.privilegeId !== "") {
      obj.privilegeId = message.privilegeId;
    }
    if (message.level !== "") {
      obj.level = message.level;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PrivilegeLogExtra>, I>>(base?: I): PrivilegeLogExtra {
    return PrivilegeLogExtra.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrivilegeLogExtra>, I>>(object: I): PrivilegeLogExtra {
    const message = createBasePrivilegeLogExtra();
    message.privilegeId = object.privilegeId ?? "";
    message.level = object.level ?? "";
    return message;
  },
};

function createBaseUserBadge(): UserBadge {
  return { type: "", name: "" };
}

export const UserBadge: MessageFns<UserBadge> = {
  encode(message: UserBadge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserBadge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserBadge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserBadge {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: UserBadge): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserBadge>, I>>(base?: I): UserBadge {
    return UserBadge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserBadge>, I>>(object: I): UserBadge {
    const message = createBaseUserBadge();
    message.type = object.type ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUserImageBadge(): UserImageBadge {
  return { displayType: 0, image: undefined };
}

export const UserImageBadge: MessageFns<UserImageBadge> = {
  encode(message: UserImageBadge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayType !== 0) {
      writer.uint32(8).int32(message.displayType);
    }
    if (message.image !== undefined) {
      UserImageBadgeImage.encode(message.image, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserImageBadge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserImageBadge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.displayType = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.image = UserImageBadgeImage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserImageBadge {
    return {
      displayType: isSet(object.displayType) ? globalThis.Number(object.displayType) : 0,
      image: isSet(object.image) ? UserImageBadgeImage.fromJSON(object.image) : undefined,
    };
  },

  toJSON(message: UserImageBadge): unknown {
    const obj: any = {};
    if (message.displayType !== 0) {
      obj.displayType = Math.round(message.displayType);
    }
    if (message.image !== undefined) {
      obj.image = UserImageBadgeImage.toJSON(message.image);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserImageBadge>, I>>(base?: I): UserImageBadge {
    return UserImageBadge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserImageBadge>, I>>(object: I): UserImageBadge {
    const message = createBaseUserImageBadge();
    message.displayType = object.displayType ?? 0;
    message.image = (object.image !== undefined && object.image !== null)
      ? UserImageBadgeImage.fromPartial(object.image)
      : undefined;
    return message;
  },
};

function createBaseUserImageBadgeImage(): UserImageBadgeImage {
  return { url: "" };
}

export const UserImageBadgeImage: MessageFns<UserImageBadgeImage> = {
  encode(message: UserImageBadgeImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserImageBadgeImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserImageBadgeImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserImageBadgeImage {
    return { url: isSet(object.url) ? globalThis.String(object.url) : "" };
  },

  toJSON(message: UserImageBadgeImage): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserImageBadgeImage>, I>>(base?: I): UserImageBadgeImage {
    return UserImageBadgeImage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserImageBadgeImage>, I>>(object: I): UserImageBadgeImage {
    const message = createBaseUserImageBadgeImage();
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseWebcastWebsocketMessage(): WebcastWebsocketMessage {
  return { id: "0", type: "", binary: new Uint8Array(0) };
}

export const WebcastWebsocketMessage: MessageFns<WebcastWebsocketMessage> = {
  encode(message: WebcastWebsocketMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(16).uint64(message.id);
    }
    if (message.type !== "") {
      writer.uint32(58).string(message.type);
    }
    if (message.binary.length !== 0) {
      writer.uint32(66).bytes(message.binary);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastWebsocketMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastWebsocketMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.uint64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.binary = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastWebsocketMessage {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "0",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      binary: isSet(object.binary) ? bytesFromBase64(object.binary) : new Uint8Array(0),
    };
  },

  toJSON(message: WebcastWebsocketMessage): unknown {
    const obj: any = {};
    if (message.id !== "0") {
      obj.id = message.id;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.binary.length !== 0) {
      obj.binary = base64FromBytes(message.binary);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastWebsocketMessage>, I>>(base?: I): WebcastWebsocketMessage {
    return WebcastWebsocketMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastWebsocketMessage>, I>>(object: I): WebcastWebsocketMessage {
    const message = createBaseWebcastWebsocketMessage();
    message.id = object.id ?? "0";
    message.type = object.type ?? "";
    message.binary = object.binary ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWebcastWebsocketAck(): WebcastWebsocketAck {
  return { id: "0", type: "" };
}

export const WebcastWebsocketAck: MessageFns<WebcastWebsocketAck> = {
  encode(message: WebcastWebsocketAck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(16).uint64(message.id);
    }
    if (message.type !== "") {
      writer.uint32(58).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastWebsocketAck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastWebsocketAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.uint64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.type = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastWebsocketAck {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "0",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: WebcastWebsocketAck): unknown {
    const obj: any = {};
    if (message.id !== "0") {
      obj.id = message.id;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastWebsocketAck>, I>>(base?: I): WebcastWebsocketAck {
    return WebcastWebsocketAck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastWebsocketAck>, I>>(object: I): WebcastWebsocketAck {
    const message = createBaseWebcastWebsocketAck();
    message.id = object.id ?? "0";
    message.type = object.type ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.27.1
// source: tiktok-schema.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "TikTok";

export enum ControlAction {
  CONTROL_ACTION_FALLBACK_UNKNOWN = 0,
  CONTROL_ACTION_STREAM_PAUSED = 1,
  CONTROL_ACTION_STREAM_UNPAUSED = 2,
  CONTROL_ACTION_STREAM_ENDED = 3,
  CONTROL_ACTION_STREAM_SUSPENDED = 4,
  UNRECOGNIZED = -1,
}

export function controlActionFromJSON(object: any): ControlAction {
  switch (object) {
    case 0:
    case "CONTROL_ACTION_FALLBACK_UNKNOWN":
      return ControlAction.CONTROL_ACTION_FALLBACK_UNKNOWN;
    case 1:
    case "CONTROL_ACTION_STREAM_PAUSED":
      return ControlAction.CONTROL_ACTION_STREAM_PAUSED;
    case 2:
    case "CONTROL_ACTION_STREAM_UNPAUSED":
      return ControlAction.CONTROL_ACTION_STREAM_UNPAUSED;
    case 3:
    case "CONTROL_ACTION_STREAM_ENDED":
      return ControlAction.CONTROL_ACTION_STREAM_ENDED;
    case 4:
    case "CONTROL_ACTION_STREAM_SUSPENDED":
      return ControlAction.CONTROL_ACTION_STREAM_SUSPENDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ControlAction.UNRECOGNIZED;
  }
}

export function controlActionToJSON(object: ControlAction): string {
  switch (object) {
    case ControlAction.CONTROL_ACTION_FALLBACK_UNKNOWN:
      return "CONTROL_ACTION_FALLBACK_UNKNOWN";
    case ControlAction.CONTROL_ACTION_STREAM_PAUSED:
      return "CONTROL_ACTION_STREAM_PAUSED";
    case ControlAction.CONTROL_ACTION_STREAM_UNPAUSED:
      return "CONTROL_ACTION_STREAM_UNPAUSED";
    case ControlAction.CONTROL_ACTION_STREAM_ENDED:
      return "CONTROL_ACTION_STREAM_ENDED";
    case ControlAction.CONTROL_ACTION_STREAM_SUSPENDED:
      return "CONTROL_ACTION_STREAM_SUSPENDED";
    case ControlAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Data structure from im/fetch/ response */
export interface WebcastResponse {
  messages: Message[];
  cursor: string;
  fetchInterval: number;
  serverTimestamp: string;
  internalExt: string;
  /** ws (1) or polling (2) */
  fetchType: number;
  wsParams: WebsocketParam[];
  heartbeatDuration: number;
  needAck: boolean;
  wsUrl: string;
}

export interface Message {
  type: string;
  binary: Uint8Array;
}

export interface WebsocketParam {
  name: string;
  value: string;
}

/** Message types depending on Message.tyoe */
export interface WebcastControlMessage {
  action: ControlAction;
}

/** Statistics like viewer count */
export interface WebcastRoomUserSeqMessage {
  topViewers: TopUser[];
  viewerCount: number;
}

export interface TopUser {
  coinCount: string;
  user: User | undefined;
}

export interface ImageModel {
  mUrls: string[];
  mUri: string;
  height: number;
  width: number;
  avgColor: string;
  imageType: number;
  schema: string;
  content: ImageModel_Content | undefined;
  isAnimated: boolean;
}

export interface ImageModel_Content {
  name: string;
  fontColor: string;
  level: string;
}

export interface WebcastChatMessage {
  event: WebcastMessageEvent | undefined;
  user: User | undefined;
  comment: string;
  visibleToSender: boolean;
  background: ImageModel | undefined;
  fullScreenTextColor: string;
  backgroundImageV2: ImageModel | undefined;
  giftImage: ImageModel | undefined;
  inputType: number;
  atUser: User | undefined;
  emotes: WebcastSubEmote[];
  contentLanguage: string;
  quickChatScene: number;
  communityflaggedStatus: number;
  commentQualityScores: WebcastChatMessage_CommentQualityScore[];
  userIdentity: WebcastChatMessage_UserIdentity | undefined;
  commentTag: WebcastChatMessage_CommentTag[];
  screenTime: string;
  signature: string;
  signatureVersion: string;
  ecStreamerKey: string;
}

export enum WebcastChatMessage_CommentTag {
  COMMENT_TAG_NORMAL = 0,
  COMMENT_TAG_CANDIDATE = 1,
  COMMENT_TAG_OVERAGE = 2,
  UNRECOGNIZED = -1,
}

export function webcastChatMessage_CommentTagFromJSON(object: any): WebcastChatMessage_CommentTag {
  switch (object) {
    case 0:
    case "COMMENT_TAG_NORMAL":
      return WebcastChatMessage_CommentTag.COMMENT_TAG_NORMAL;
    case 1:
    case "COMMENT_TAG_CANDIDATE":
      return WebcastChatMessage_CommentTag.COMMENT_TAG_CANDIDATE;
    case 2:
    case "COMMENT_TAG_OVERAGE":
      return WebcastChatMessage_CommentTag.COMMENT_TAG_OVERAGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WebcastChatMessage_CommentTag.UNRECOGNIZED;
  }
}

export function webcastChatMessage_CommentTagToJSON(object: WebcastChatMessage_CommentTag): string {
  switch (object) {
    case WebcastChatMessage_CommentTag.COMMENT_TAG_NORMAL:
      return "COMMENT_TAG_NORMAL";
    case WebcastChatMessage_CommentTag.COMMENT_TAG_CANDIDATE:
      return "COMMENT_TAG_CANDIDATE";
    case WebcastChatMessage_CommentTag.COMMENT_TAG_OVERAGE:
      return "COMMENT_TAG_OVERAGE";
    case WebcastChatMessage_CommentTag.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface WebcastChatMessage_UserIdentity {
  isGiftGiverOfAnchor: boolean;
  isSubscriberOfAnchor: boolean;
  isMutualFollowingWithAnchor: boolean;
  isFollowerOfAnchor: boolean;
  isModeratorOfAnchor: boolean;
  isAnchor: boolean;
}

export interface WebcastChatMessage_CommentQualityScore {
  version: string;
  score: string;
}

export interface EmoteUploadInfo {
  userId: string;
  emoteUploadSource?: EmoteUploadInfo_UserEmoteUploadSource | undefined;
  userInfo: User | undefined;
  userIdStr: string;
}

export enum EmoteUploadInfo_UserEmoteUploadSource {
  USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_ANCHOR = 0,
  USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_SUBSCRIBER = 1,
  USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_MODERATOR = 2,
  UNRECOGNIZED = -1,
}

export function emoteUploadInfo_UserEmoteUploadSourceFromJSON(object: any): EmoteUploadInfo_UserEmoteUploadSource {
  switch (object) {
    case 0:
    case "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_ANCHOR":
      return EmoteUploadInfo_UserEmoteUploadSource.USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_ANCHOR;
    case 1:
    case "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_SUBSCRIBER":
      return EmoteUploadInfo_UserEmoteUploadSource.USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_SUBSCRIBER;
    case 2:
    case "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_MODERATOR":
      return EmoteUploadInfo_UserEmoteUploadSource.USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_MODERATOR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EmoteUploadInfo_UserEmoteUploadSource.UNRECOGNIZED;
  }
}

export function emoteUploadInfo_UserEmoteUploadSourceToJSON(object: EmoteUploadInfo_UserEmoteUploadSource): string {
  switch (object) {
    case EmoteUploadInfo_UserEmoteUploadSource.USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_ANCHOR:
      return "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_ANCHOR";
    case EmoteUploadInfo_UserEmoteUploadSource.USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_SUBSCRIBER:
      return "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_SUBSCRIBER";
    case EmoteUploadInfo_UserEmoteUploadSource.USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_MODERATOR:
      return "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_MODERATOR";
    case EmoteUploadInfo_UserEmoteUploadSource.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Chat Emotes (Subscriber) */
export interface WebcastEmoteChatMessage {
  user: User | undefined;
  emote: EmoteDetails | undefined;
}

export interface WebcastSubEmote {
  /** starting at 0, you insert the emote itself into the comment at that place */
  placeInComment: number;
  emote: EmoteDetails | undefined;
}

export interface WebcastMemberMessage {
  event: WebcastMessageEvent | undefined;
  user: User | undefined;
  actionId: number;
}

export interface WebcastGiftMessage {
  event: WebcastMessageEvent | undefined;
  giftId: number;
  repeatCount: number;
  user: User | undefined;
  repeatEnd: number;
  groupId: string;
  giftDetails: WebcastGiftMessageGiftDetails | undefined;
  monitorExtra: string;
  giftExtra: WebcastGiftMessageGiftExtra | undefined;
}

export interface WebcastGiftMessageGiftDetails {
  giftImage: WebcastGiftMessageGiftImage | undefined;
  giftName: string;
  describe: string;
  giftType: number;
  diamondCount: number;
}

/** Taken from https://github.com/Davincible/gotiktoklive/blob/da4630622bc586629a53faae64e8c53509af29de/proto/tiktok.proto#L57 */
export interface WebcastGiftMessageGiftExtra {
  timestamp: string;
  receiverUserId: string;
}

export interface WebcastGiftMessageGiftImage {
  giftPictureUrl: string;
}

/** Battle start */
export interface WebcastLinkMicBattle {
  battleUsers: WebcastLinkMicBattleItems[];
}

export interface WebcastLinkMicBattleItems {
  battleGroup: WebcastLinkMicBattleGroup | undefined;
}

export interface WebcastLinkMicBattleGroup {
  user: LinkUser | undefined;
}

/** Battle status */
export interface WebcastLinkMicArmies {
  battleItems: WebcastLinkMicArmiesItems[];
  battleStatus: number;
}

export interface WebcastLinkMicArmiesItems {
  hostUserId: string;
  battleGroups: WebcastLinkMicArmiesGroup[];
}

export interface WebcastLinkMicArmiesGroup {
  users: User[];
  points: number;
}

/** Follow & share event */
export interface WebcastSocialMessage {
  event: WebcastMessageEvent | undefined;
  user: User | undefined;
}

/** Like event (is only sent from time to time, not with every like) */
export interface WebcastLikeMessage {
  event: WebcastMessageEvent | undefined;
  user: User | undefined;
  likeCount: number;
  totalLikeCount: number;
}

/** New question event */
export interface WebcastQuestionNewMessage {
  questionDetails: QuestionDetails | undefined;
}

export interface QuestionDetails {
  questionText: string;
  user: User | undefined;
}

export interface WebcastMessageEvent {
  msgId: string;
  createTime: string;
  eventDetails: WebcastMessageEventDetails | undefined;
}

/** Contains UI information */
export interface WebcastMessageEventDetails {
  displayType: string;
  label: string;
}

/** Source: Co-opted https://github.com/zerodytrash/TikTok-Livestream-Chat-Connector/issues/19#issuecomment-1074150342 */
export interface WebcastLiveIntroMessage {
  id: string;
  description: string;
  user: User | undefined;
}

export interface SystemMessage {
  description: string;
}

export interface WebcastInRoomBannerMessage {
  data: string;
}

export interface RankItem {
  colour: string;
  id: string;
}

export interface WeeklyRanking {
  type: string;
  label: string;
  rank: RankItem | undefined;
}

export interface RankContainer {
  rankings: WeeklyRanking | undefined;
}

export interface WebcastHourlyRankMessage {
  data: RankContainer | undefined;
}

export interface EmoteDetails {
  emoteId: string;
  image: EmoteImage | undefined;
}

export interface EmoteImage {
  imageUrl: string;
}

/**
 * Envelope (treasure boxes)
 * Taken from https://github.com/ThanoFish/TikTok-Live-Connector/blob/9b215b96792adfddfb638344b152fa9efa581b4c/src/proto/tiktokSchema.proto
 */
export interface WebcastEnvelopeMessage {
  treasureBoxData: TreasureBoxData | undefined;
  treasureBoxUser: TreasureBoxUser | undefined;
}

export interface TreasureBoxUser {
  user2: TreasureBoxUser2 | undefined;
}

export interface TreasureBoxUser2 {
  user3: TreasureBoxUser3[];
}

export interface TreasureBoxUser3 {
  user4: TreasureBoxUser4 | undefined;
}

export interface TreasureBoxUser4 {
  user: User | undefined;
}

export interface TreasureBoxData {
  coins: number;
  canOpen: number;
  timestamp: string;
}

/** New Subscriber message */
export interface WebcastSubNotifyMessage {
  event: WebcastMessageEvent | undefined;
  user: User | undefined;
  exhibitionType: number;
  subMonth: number;
  subscribeType: number;
  oldSubscribeStatus: number;
  subscribingStatus: number;
}

export interface User {
  userId: string;
  nickname: string;
  profilePicture: ProfilePicture | undefined;
  uniqueId: string;
  secUid: string;
  badges: UserBadgesAttributes[];
  createTime: string;
  bioDescription: string;
  followInfo: FollowInfo | undefined;
}

export interface FollowInfo {
  followingCount: number;
  followerCount: number;
  followStatus: number;
  pushStatus: number;
}

export interface LinkUser {
  userId: string;
  nickname: string;
  profilePicture: ProfilePicture | undefined;
  uniqueId: string;
}

export interface ProfilePicture {
  urls: string[];
}

export interface UserBadgesAttributes {
  badgeSceneType: number;
  imageBadges: UserImageBadge[];
  badges: UserBadge[];
  privilegeLogExtra: PrivilegeLogExtra | undefined;
}

export interface PrivilegeLogExtra {
  privilegeId: string;
  level: string;
}

export interface UserBadge {
  type: string;
  name: string;
}

export interface UserImageBadge {
  displayType: number;
  image: UserImageBadgeImage | undefined;
}

export interface UserImageBadgeImage {
  url: string;
}

/** Websocket incoming message structure */
export interface WebcastWebsocketMessage {
  id: string;
  type: string;
  binary: Uint8Array;
}

/** Websocket acknowledgment message */
export interface WebcastWebsocketAck {
  id: string;
  type: string;
}

/** Message representing the room info */
export interface HeartbeatFrameRoomInfo {
  roomId: string;
}

/** Message representing metadata field 6 */
export interface HeartbeatFrameMetadataField6 {
  unknown1: number;
}

/** Message representing metadata field 7 */
export interface HeartbeatFrameMetadataField7 {
  unknown1: number;
}

/** Heartbeat keepalive message */
export interface HeartbeatFrame {
  metadataField6: HeartbeatFrameMetadataField6 | undefined;
  metadataField7: HeartbeatFrameMetadataField7 | undefined;
  roomInfo: HeartbeatFrameRoomInfo | undefined;
}

/**
 * TODO: In a future release, set client_enter=1 on both /im/fetch and WS url; this is what the web client does
 * Didn't do it because it requires an agent update & sign server update
 *         // Create a room enter container
 *        const container = ImEnterRoomMessagePushFrame.fromPartial({
 *            payloadType: "im_enter_room",
 *            payload: {
 *                roomId: roomId,
 *                unknown1: 12,
 *                role: "audience",
 *                cursor: cursor,
 *                unknown2: 0,
 *                unknown3: "0",
 *                unknown4: 0
 *            },
 *            metadata: {
 *                unknown1: 98
 *            }
 *        });
 */
export interface ImEnterRoomMessagePushFrame {
  metadata:
    | ImEnterRoomMessagePushFrame_Metadata
    | undefined;
  /** "im_enter_room" */
  payloadType: string;
  payload: ImEnterRoomMessagePushFrame_ImEnterRoomMessage | undefined;
}

export interface ImEnterRoomMessagePushFrame_Metadata {
  /** "98" */
  unknown1: number;
}

export interface ImEnterRoomMessagePushFrame_ImEnterRoomMessage {
  /** Room ID */
  roomId: string;
  /** "12" */
  unknown1: number;
  /** "audience" */
  role: string;
  /** Cursor */
  cursor: string;
  /** "0" */
  unknown2?:
    | number
    | undefined;
  /** "0" */
  unknown3: string;
  /** "0" */
  unknown4?: number | undefined;
}

export interface WebcastBarrageMessage {
  baseMessage: WebcastMessageEvent | undefined;
  event: WebcastBarrageMessage_BarrageEvent | undefined;
  msgType?: WebcastBarrageMessage_BarrageType | undefined;
  icon: ImageModel | undefined;
  duration: string;
  backGround: ImageModel | undefined;
  rightIcon: ImageModel | undefined;
  displayConfig: number;
  galleryGiftId: string;
  useMarquee: boolean;
  showType?: WebcastBarrageMessage_ShowType | undefined;
  renderType?: WebcastBarrageMessage_RenderType | undefined;
  leftIconDisplayType?: WebcastBarrageMessage_IconDisplayType | undefined;
  ribbonAnimation: ImageModel | undefined;
  hybridUrl: string;
  schema: string;
  subType: string;
  privilegeLogExtra: PrivilegeLogExtra | undefined;
}

export enum WebcastBarrageMessage_BarrageType {
  BARRAGE_TYPE_UNKNOWN = 0,
  BARRAGE_TYPE_E_COM_ORDERING = 1,
  BARRAGE_TYPE_E_COM_BUYING = 2,
  BARRAGE_TYPE_NORMAL = 3,
  BARRAGE_TYPE_SUBSCRIBE = 4,
  BARRAGE_TYPE_EVENT_VIEW = 5,
  BARRAGE_TYPE_EVENT_REGISTERED = 6,
  BARRAGE_TYPE_SUBSCRIBE_GIFT = 7,
  BARRAGE_TYPE_USER_UPGRADE = 8,
  BARRAGE_TYPE_GRADE_USER_ENTRANCE_NOTIFICATION = 9,
  BARRAGE_TYPE_FANS_LEVEL_UPGRADE = 10,
  BARRAGE_TYPE_FANS_LEVEL_ENTRANCE = 11,
  BARRAGE_TYPE_GAME_PARTNERSHIP = 12,
  BARRAGE_TYPE_GIFT_GALLERY = 13,
  BARRAGE_TYPE_E_COM_BOUGHT = 14,
  BARRAGE_TYPE_COMMON_BARRAGE = 100,
  UNRECOGNIZED = -1,
}

export function webcastBarrageMessage_BarrageTypeFromJSON(object: any): WebcastBarrageMessage_BarrageType {
  switch (object) {
    case 0:
    case "BARRAGE_TYPE_UNKNOWN":
      return WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_UNKNOWN;
    case 1:
    case "BARRAGE_TYPE_E_COM_ORDERING":
      return WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_E_COM_ORDERING;
    case 2:
    case "BARRAGE_TYPE_E_COM_BUYING":
      return WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_E_COM_BUYING;
    case 3:
    case "BARRAGE_TYPE_NORMAL":
      return WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_NORMAL;
    case 4:
    case "BARRAGE_TYPE_SUBSCRIBE":
      return WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_SUBSCRIBE;
    case 5:
    case "BARRAGE_TYPE_EVENT_VIEW":
      return WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_EVENT_VIEW;
    case 6:
    case "BARRAGE_TYPE_EVENT_REGISTERED":
      return WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_EVENT_REGISTERED;
    case 7:
    case "BARRAGE_TYPE_SUBSCRIBE_GIFT":
      return WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_SUBSCRIBE_GIFT;
    case 8:
    case "BARRAGE_TYPE_USER_UPGRADE":
      return WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_USER_UPGRADE;
    case 9:
    case "BARRAGE_TYPE_GRADE_USER_ENTRANCE_NOTIFICATION":
      return WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_GRADE_USER_ENTRANCE_NOTIFICATION;
    case 10:
    case "BARRAGE_TYPE_FANS_LEVEL_UPGRADE":
      return WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_FANS_LEVEL_UPGRADE;
    case 11:
    case "BARRAGE_TYPE_FANS_LEVEL_ENTRANCE":
      return WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_FANS_LEVEL_ENTRANCE;
    case 12:
    case "BARRAGE_TYPE_GAME_PARTNERSHIP":
      return WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_GAME_PARTNERSHIP;
    case 13:
    case "BARRAGE_TYPE_GIFT_GALLERY":
      return WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_GIFT_GALLERY;
    case 14:
    case "BARRAGE_TYPE_E_COM_BOUGHT":
      return WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_E_COM_BOUGHT;
    case 100:
    case "BARRAGE_TYPE_COMMON_BARRAGE":
      return WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_COMMON_BARRAGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WebcastBarrageMessage_BarrageType.UNRECOGNIZED;
  }
}

export function webcastBarrageMessage_BarrageTypeToJSON(object: WebcastBarrageMessage_BarrageType): string {
  switch (object) {
    case WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_UNKNOWN:
      return "BARRAGE_TYPE_UNKNOWN";
    case WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_E_COM_ORDERING:
      return "BARRAGE_TYPE_E_COM_ORDERING";
    case WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_E_COM_BUYING:
      return "BARRAGE_TYPE_E_COM_BUYING";
    case WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_NORMAL:
      return "BARRAGE_TYPE_NORMAL";
    case WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_SUBSCRIBE:
      return "BARRAGE_TYPE_SUBSCRIBE";
    case WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_EVENT_VIEW:
      return "BARRAGE_TYPE_EVENT_VIEW";
    case WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_EVENT_REGISTERED:
      return "BARRAGE_TYPE_EVENT_REGISTERED";
    case WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_SUBSCRIBE_GIFT:
      return "BARRAGE_TYPE_SUBSCRIBE_GIFT";
    case WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_USER_UPGRADE:
      return "BARRAGE_TYPE_USER_UPGRADE";
    case WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_GRADE_USER_ENTRANCE_NOTIFICATION:
      return "BARRAGE_TYPE_GRADE_USER_ENTRANCE_NOTIFICATION";
    case WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_FANS_LEVEL_UPGRADE:
      return "BARRAGE_TYPE_FANS_LEVEL_UPGRADE";
    case WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_FANS_LEVEL_ENTRANCE:
      return "BARRAGE_TYPE_FANS_LEVEL_ENTRANCE";
    case WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_GAME_PARTNERSHIP:
      return "BARRAGE_TYPE_GAME_PARTNERSHIP";
    case WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_GIFT_GALLERY:
      return "BARRAGE_TYPE_GIFT_GALLERY";
    case WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_E_COM_BOUGHT:
      return "BARRAGE_TYPE_E_COM_BOUGHT";
    case WebcastBarrageMessage_BarrageType.BARRAGE_TYPE_COMMON_BARRAGE:
      return "BARRAGE_TYPE_COMMON_BARRAGE";
    case WebcastBarrageMessage_BarrageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WebcastBarrageMessage_ShowType {
  SHOW_TYPE_NORMAL = 0,
  SHOW_TYPE_FADE_IN_OUT = 1,
  UNRECOGNIZED = -1,
}

export function webcastBarrageMessage_ShowTypeFromJSON(object: any): WebcastBarrageMessage_ShowType {
  switch (object) {
    case 0:
    case "SHOW_TYPE_NORMAL":
      return WebcastBarrageMessage_ShowType.SHOW_TYPE_NORMAL;
    case 1:
    case "SHOW_TYPE_FADE_IN_OUT":
      return WebcastBarrageMessage_ShowType.SHOW_TYPE_FADE_IN_OUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WebcastBarrageMessage_ShowType.UNRECOGNIZED;
  }
}

export function webcastBarrageMessage_ShowTypeToJSON(object: WebcastBarrageMessage_ShowType): string {
  switch (object) {
    case WebcastBarrageMessage_ShowType.SHOW_TYPE_NORMAL:
      return "SHOW_TYPE_NORMAL";
    case WebcastBarrageMessage_ShowType.SHOW_TYPE_FADE_IN_OUT:
      return "SHOW_TYPE_FADE_IN_OUT";
    case WebcastBarrageMessage_ShowType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WebcastBarrageMessage_RenderType {
  RENDER_TYPE_NATIVE = 0,
  RENDER_TYPE_HYBRID = 1,
  RENDER_TYPE_ALPHA = 2,
  UNRECOGNIZED = -1,
}

export function webcastBarrageMessage_RenderTypeFromJSON(object: any): WebcastBarrageMessage_RenderType {
  switch (object) {
    case 0:
    case "RENDER_TYPE_NATIVE":
      return WebcastBarrageMessage_RenderType.RENDER_TYPE_NATIVE;
    case 1:
    case "RENDER_TYPE_HYBRID":
      return WebcastBarrageMessage_RenderType.RENDER_TYPE_HYBRID;
    case 2:
    case "RENDER_TYPE_ALPHA":
      return WebcastBarrageMessage_RenderType.RENDER_TYPE_ALPHA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WebcastBarrageMessage_RenderType.UNRECOGNIZED;
  }
}

export function webcastBarrageMessage_RenderTypeToJSON(object: WebcastBarrageMessage_RenderType): string {
  switch (object) {
    case WebcastBarrageMessage_RenderType.RENDER_TYPE_NATIVE:
      return "RENDER_TYPE_NATIVE";
    case WebcastBarrageMessage_RenderType.RENDER_TYPE_HYBRID:
      return "RENDER_TYPE_HYBRID";
    case WebcastBarrageMessage_RenderType.RENDER_TYPE_ALPHA:
      return "RENDER_TYPE_ALPHA";
    case WebcastBarrageMessage_RenderType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WebcastBarrageMessage_IconDisplayType {
  ICON_DISPLAY_TYPE_IMAGE = 0,
  ICON_DISPLAY_TYPE_BADGE = 1,
  UNRECOGNIZED = -1,
}

export function webcastBarrageMessage_IconDisplayTypeFromJSON(object: any): WebcastBarrageMessage_IconDisplayType {
  switch (object) {
    case 0:
    case "ICON_DISPLAY_TYPE_IMAGE":
      return WebcastBarrageMessage_IconDisplayType.ICON_DISPLAY_TYPE_IMAGE;
    case 1:
    case "ICON_DISPLAY_TYPE_BADGE":
      return WebcastBarrageMessage_IconDisplayType.ICON_DISPLAY_TYPE_BADGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WebcastBarrageMessage_IconDisplayType.UNRECOGNIZED;
  }
}

export function webcastBarrageMessage_IconDisplayTypeToJSON(object: WebcastBarrageMessage_IconDisplayType): string {
  switch (object) {
    case WebcastBarrageMessage_IconDisplayType.ICON_DISPLAY_TYPE_IMAGE:
      return "ICON_DISPLAY_TYPE_IMAGE";
    case WebcastBarrageMessage_IconDisplayType.ICON_DISPLAY_TYPE_BADGE:
      return "ICON_DISPLAY_TYPE_BADGE";
    case WebcastBarrageMessage_IconDisplayType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface WebcastBarrageMessage_BarrageEvent {
  eventName: string;
  params: { [key: string]: string };
}

export interface WebcastBarrageMessage_BarrageEvent_ParamsEntry {
  key: string;
  value: string;
}

function createBaseWebcastResponse(): WebcastResponse {
  return {
    messages: [],
    cursor: "",
    fetchInterval: 0,
    serverTimestamp: "0",
    internalExt: "",
    fetchType: 0,
    wsParams: [],
    heartbeatDuration: 0,
    needAck: false,
    wsUrl: "",
  };
}

export const WebcastResponse: MessageFns<WebcastResponse> = {
  encode(message: WebcastResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      Message.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.cursor !== "") {
      writer.uint32(18).string(message.cursor);
    }
    if (message.fetchInterval !== 0) {
      writer.uint32(24).int32(message.fetchInterval);
    }
    if (message.serverTimestamp !== "0") {
      writer.uint32(32).int64(message.serverTimestamp);
    }
    if (message.internalExt !== "") {
      writer.uint32(42).string(message.internalExt);
    }
    if (message.fetchType !== 0) {
      writer.uint32(48).int32(message.fetchType);
    }
    for (const v of message.wsParams) {
      WebsocketParam.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.heartbeatDuration !== 0) {
      writer.uint32(64).int32(message.heartbeatDuration);
    }
    if (message.needAck !== false) {
      writer.uint32(72).bool(message.needAck);
    }
    if (message.wsUrl !== "") {
      writer.uint32(82).string(message.wsUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cursor = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fetchInterval = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.serverTimestamp = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.internalExt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.fetchType = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.wsParams.push(WebsocketParam.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.heartbeatDuration = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.needAck = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.wsUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastResponse {
    return {
      messages: globalThis.Array.isArray(object?.messages) ? object.messages.map((e: any) => Message.fromJSON(e)) : [],
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
      fetchInterval: isSet(object.fetchInterval) ? globalThis.Number(object.fetchInterval) : 0,
      serverTimestamp: isSet(object.serverTimestamp) ? globalThis.String(object.serverTimestamp) : "0",
      internalExt: isSet(object.internalExt) ? globalThis.String(object.internalExt) : "",
      fetchType: isSet(object.fetchType) ? globalThis.Number(object.fetchType) : 0,
      wsParams: globalThis.Array.isArray(object?.wsParams)
        ? object.wsParams.map((e: any) => WebsocketParam.fromJSON(e))
        : [],
      heartbeatDuration: isSet(object.heartbeatDuration) ? globalThis.Number(object.heartbeatDuration) : 0,
      needAck: isSet(object.needAck) ? globalThis.Boolean(object.needAck) : false,
      wsUrl: isSet(object.wsUrl) ? globalThis.String(object.wsUrl) : "",
    };
  },

  toJSON(message: WebcastResponse): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => Message.toJSON(e));
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    if (message.fetchInterval !== 0) {
      obj.fetchInterval = Math.round(message.fetchInterval);
    }
    if (message.serverTimestamp !== "0") {
      obj.serverTimestamp = message.serverTimestamp;
    }
    if (message.internalExt !== "") {
      obj.internalExt = message.internalExt;
    }
    if (message.fetchType !== 0) {
      obj.fetchType = Math.round(message.fetchType);
    }
    if (message.wsParams?.length) {
      obj.wsParams = message.wsParams.map((e) => WebsocketParam.toJSON(e));
    }
    if (message.heartbeatDuration !== 0) {
      obj.heartbeatDuration = Math.round(message.heartbeatDuration);
    }
    if (message.needAck !== false) {
      obj.needAck = message.needAck;
    }
    if (message.wsUrl !== "") {
      obj.wsUrl = message.wsUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastResponse>, I>>(base?: I): WebcastResponse {
    return WebcastResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastResponse>, I>>(object: I): WebcastResponse {
    const message = createBaseWebcastResponse();
    message.messages = object.messages?.map((e) => Message.fromPartial(e)) || [];
    message.cursor = object.cursor ?? "";
    message.fetchInterval = object.fetchInterval ?? 0;
    message.serverTimestamp = object.serverTimestamp ?? "0";
    message.internalExt = object.internalExt ?? "";
    message.fetchType = object.fetchType ?? 0;
    message.wsParams = object.wsParams?.map((e) => WebsocketParam.fromPartial(e)) || [];
    message.heartbeatDuration = object.heartbeatDuration ?? 0;
    message.needAck = object.needAck ?? false;
    message.wsUrl = object.wsUrl ?? "";
    return message;
  },
};

function createBaseMessage(): Message {
  return { type: "", binary: new Uint8Array(0) };
}

export const Message: MessageFns<Message> = {
  encode(message: Message, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.binary.length !== 0) {
      writer.uint32(18).bytes(message.binary);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.binary = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      binary: isSet(object.binary) ? bytesFromBase64(object.binary) : new Uint8Array(0),
    };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.binary.length !== 0) {
      obj.binary = base64FromBytes(message.binary);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Message>, I>>(base?: I): Message {
    return Message.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message {
    const message = createBaseMessage();
    message.type = object.type ?? "";
    message.binary = object.binary ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWebsocketParam(): WebsocketParam {
  return { name: "", value: "" };
}

export const WebsocketParam: MessageFns<WebsocketParam> = {
  encode(message: WebsocketParam, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebsocketParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebsocketParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebsocketParam {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: WebsocketParam): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebsocketParam>, I>>(base?: I): WebsocketParam {
    return WebsocketParam.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebsocketParam>, I>>(object: I): WebsocketParam {
    const message = createBaseWebsocketParam();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseWebcastControlMessage(): WebcastControlMessage {
  return { action: 0 };
}

export const WebcastControlMessage: MessageFns<WebcastControlMessage> = {
  encode(message: WebcastControlMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== 0) {
      writer.uint32(16).int32(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastControlMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastControlMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastControlMessage {
    return { action: isSet(object.action) ? controlActionFromJSON(object.action) : 0 };
  },

  toJSON(message: WebcastControlMessage): unknown {
    const obj: any = {};
    if (message.action !== 0) {
      obj.action = controlActionToJSON(message.action);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastControlMessage>, I>>(base?: I): WebcastControlMessage {
    return WebcastControlMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastControlMessage>, I>>(object: I): WebcastControlMessage {
    const message = createBaseWebcastControlMessage();
    message.action = object.action ?? 0;
    return message;
  },
};

function createBaseWebcastRoomUserSeqMessage(): WebcastRoomUserSeqMessage {
  return { topViewers: [], viewerCount: 0 };
}

export const WebcastRoomUserSeqMessage: MessageFns<WebcastRoomUserSeqMessage> = {
  encode(message: WebcastRoomUserSeqMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.topViewers) {
      TopUser.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.viewerCount !== 0) {
      writer.uint32(24).int32(message.viewerCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastRoomUserSeqMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastRoomUserSeqMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.topViewers.push(TopUser.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.viewerCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastRoomUserSeqMessage {
    return {
      topViewers: globalThis.Array.isArray(object?.topViewers)
        ? object.topViewers.map((e: any) => TopUser.fromJSON(e))
        : [],
      viewerCount: isSet(object.viewerCount) ? globalThis.Number(object.viewerCount) : 0,
    };
  },

  toJSON(message: WebcastRoomUserSeqMessage): unknown {
    const obj: any = {};
    if (message.topViewers?.length) {
      obj.topViewers = message.topViewers.map((e) => TopUser.toJSON(e));
    }
    if (message.viewerCount !== 0) {
      obj.viewerCount = Math.round(message.viewerCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastRoomUserSeqMessage>, I>>(base?: I): WebcastRoomUserSeqMessage {
    return WebcastRoomUserSeqMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastRoomUserSeqMessage>, I>>(object: I): WebcastRoomUserSeqMessage {
    const message = createBaseWebcastRoomUserSeqMessage();
    message.topViewers = object.topViewers?.map((e) => TopUser.fromPartial(e)) || [];
    message.viewerCount = object.viewerCount ?? 0;
    return message;
  },
};

function createBaseTopUser(): TopUser {
  return { coinCount: "0", user: undefined };
}

export const TopUser: MessageFns<TopUser> = {
  encode(message: TopUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coinCount !== "0") {
      writer.uint32(8).uint64(message.coinCount);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.coinCount = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopUser {
    return {
      coinCount: isSet(object.coinCount) ? globalThis.String(object.coinCount) : "0",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: TopUser): unknown {
    const obj: any = {};
    if (message.coinCount !== "0") {
      obj.coinCount = message.coinCount;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopUser>, I>>(base?: I): TopUser {
    return TopUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopUser>, I>>(object: I): TopUser {
    const message = createBaseTopUser();
    message.coinCount = object.coinCount ?? "0";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseImageModel(): ImageModel {
  return {
    mUrls: [],
    mUri: "",
    height: 0,
    width: 0,
    avgColor: "",
    imageType: 0,
    schema: "",
    content: undefined,
    isAnimated: false,
  };
}

export const ImageModel: MessageFns<ImageModel> = {
  encode(message: ImageModel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.mUrls) {
      writer.uint32(10).string(v!);
    }
    if (message.mUri !== "") {
      writer.uint32(18).string(message.mUri);
    }
    if (message.height !== 0) {
      writer.uint32(24).int32(message.height);
    }
    if (message.width !== 0) {
      writer.uint32(32).int32(message.width);
    }
    if (message.avgColor !== "") {
      writer.uint32(42).string(message.avgColor);
    }
    if (message.imageType !== 0) {
      writer.uint32(48).int32(message.imageType);
    }
    if (message.schema !== "") {
      writer.uint32(58).string(message.schema);
    }
    if (message.content !== undefined) {
      ImageModel_Content.encode(message.content, writer.uint32(66).fork()).join();
    }
    if (message.isAnimated !== false) {
      writer.uint32(72).bool(message.isAnimated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mUrls.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mUri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.avgColor = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.imageType = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.content = ImageModel_Content.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isAnimated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageModel {
    return {
      mUrls: globalThis.Array.isArray(object?.mUrls) ? object.mUrls.map((e: any) => globalThis.String(e)) : [],
      mUri: isSet(object.mUri) ? globalThis.String(object.mUri) : "",
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      avgColor: isSet(object.avgColor) ? globalThis.String(object.avgColor) : "",
      imageType: isSet(object.imageType) ? globalThis.Number(object.imageType) : 0,
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      content: isSet(object.content) ? ImageModel_Content.fromJSON(object.content) : undefined,
      isAnimated: isSet(object.isAnimated) ? globalThis.Boolean(object.isAnimated) : false,
    };
  },

  toJSON(message: ImageModel): unknown {
    const obj: any = {};
    if (message.mUrls?.length) {
      obj.mUrls = message.mUrls;
    }
    if (message.mUri !== "") {
      obj.mUri = message.mUri;
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.avgColor !== "") {
      obj.avgColor = message.avgColor;
    }
    if (message.imageType !== 0) {
      obj.imageType = Math.round(message.imageType);
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.content !== undefined) {
      obj.content = ImageModel_Content.toJSON(message.content);
    }
    if (message.isAnimated !== false) {
      obj.isAnimated = message.isAnimated;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImageModel>, I>>(base?: I): ImageModel {
    return ImageModel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImageModel>, I>>(object: I): ImageModel {
    const message = createBaseImageModel();
    message.mUrls = object.mUrls?.map((e) => e) || [];
    message.mUri = object.mUri ?? "";
    message.height = object.height ?? 0;
    message.width = object.width ?? 0;
    message.avgColor = object.avgColor ?? "";
    message.imageType = object.imageType ?? 0;
    message.schema = object.schema ?? "";
    message.content = (object.content !== undefined && object.content !== null)
      ? ImageModel_Content.fromPartial(object.content)
      : undefined;
    message.isAnimated = object.isAnimated ?? false;
    return message;
  },
};

function createBaseImageModel_Content(): ImageModel_Content {
  return { name: "", fontColor: "", level: "0" };
}

export const ImageModel_Content: MessageFns<ImageModel_Content> = {
  encode(message: ImageModel_Content, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.fontColor !== "") {
      writer.uint32(18).string(message.fontColor);
    }
    if (message.level !== "0") {
      writer.uint32(24).int64(message.level);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageModel_Content {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageModel_Content();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fontColor = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.level = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageModel_Content {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      fontColor: isSet(object.fontColor) ? globalThis.String(object.fontColor) : "",
      level: isSet(object.level) ? globalThis.String(object.level) : "0",
    };
  },

  toJSON(message: ImageModel_Content): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.fontColor !== "") {
      obj.fontColor = message.fontColor;
    }
    if (message.level !== "0") {
      obj.level = message.level;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImageModel_Content>, I>>(base?: I): ImageModel_Content {
    return ImageModel_Content.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImageModel_Content>, I>>(object: I): ImageModel_Content {
    const message = createBaseImageModel_Content();
    message.name = object.name ?? "";
    message.fontColor = object.fontColor ?? "";
    message.level = object.level ?? "0";
    return message;
  },
};

function createBaseWebcastChatMessage(): WebcastChatMessage {
  return {
    event: undefined,
    user: undefined,
    comment: "",
    visibleToSender: false,
    background: undefined,
    fullScreenTextColor: "",
    backgroundImageV2: undefined,
    giftImage: undefined,
    inputType: 0,
    atUser: undefined,
    emotes: [],
    contentLanguage: "",
    quickChatScene: 0,
    communityflaggedStatus: 0,
    commentQualityScores: [],
    userIdentity: undefined,
    commentTag: [],
    screenTime: "0",
    signature: "",
    signatureVersion: "",
    ecStreamerKey: "",
  };
}

export const WebcastChatMessage: MessageFns<WebcastChatMessage> = {
  encode(message: WebcastChatMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== undefined) {
      WebcastMessageEvent.encode(message.event, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    if (message.visibleToSender !== false) {
      writer.uint32(32).bool(message.visibleToSender);
    }
    if (message.background !== undefined) {
      ImageModel.encode(message.background, writer.uint32(42).fork()).join();
    }
    if (message.fullScreenTextColor !== "") {
      writer.uint32(50).string(message.fullScreenTextColor);
    }
    if (message.backgroundImageV2 !== undefined) {
      ImageModel.encode(message.backgroundImageV2, writer.uint32(58).fork()).join();
    }
    if (message.giftImage !== undefined) {
      ImageModel.encode(message.giftImage, writer.uint32(82).fork()).join();
    }
    if (message.inputType !== 0) {
      writer.uint32(88).int32(message.inputType);
    }
    if (message.atUser !== undefined) {
      User.encode(message.atUser, writer.uint32(98).fork()).join();
    }
    for (const v of message.emotes) {
      WebcastSubEmote.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.contentLanguage !== "") {
      writer.uint32(114).string(message.contentLanguage);
    }
    if (message.quickChatScene !== 0) {
      writer.uint32(128).int32(message.quickChatScene);
    }
    if (message.communityflaggedStatus !== 0) {
      writer.uint32(136).int32(message.communityflaggedStatus);
    }
    for (const v of message.commentQualityScores) {
      WebcastChatMessage_CommentQualityScore.encode(v!, writer.uint32(154).fork()).join();
    }
    if (message.userIdentity !== undefined) {
      WebcastChatMessage_UserIdentity.encode(message.userIdentity, writer.uint32(146).fork()).join();
    }
    writer.uint32(162).fork();
    for (const v of message.commentTag) {
      writer.int32(v);
    }
    writer.join();
    if (message.screenTime !== "0") {
      writer.uint32(176).int64(message.screenTime);
    }
    if (message.signature !== "") {
      writer.uint32(186).string(message.signature);
    }
    if (message.signatureVersion !== "") {
      writer.uint32(194).string(message.signatureVersion);
    }
    if (message.ecStreamerKey !== "") {
      writer.uint32(202).string(message.ecStreamerKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastChatMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = WebcastMessageEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.visibleToSender = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.background = ImageModel.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fullScreenTextColor = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.backgroundImageV2 = ImageModel.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.giftImage = ImageModel.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.inputType = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.atUser = User.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.emotes.push(WebcastSubEmote.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.contentLanguage = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.quickChatScene = reader.int32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.communityflaggedStatus = reader.int32();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.commentQualityScores.push(WebcastChatMessage_CommentQualityScore.decode(reader, reader.uint32()));
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.userIdentity = WebcastChatMessage_UserIdentity.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag === 160) {
            message.commentTag.push(reader.int32() as any);

            continue;
          }

          if (tag === 162) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.commentTag.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.screenTime = reader.int64().toString();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.signatureVersion = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.ecStreamerKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastChatMessage {
    return {
      event: isSet(object.event) ? WebcastMessageEvent.fromJSON(object.event) : undefined,
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      visibleToSender: isSet(object.visibleToSender) ? globalThis.Boolean(object.visibleToSender) : false,
      background: isSet(object.background) ? ImageModel.fromJSON(object.background) : undefined,
      fullScreenTextColor: isSet(object.fullScreenTextColor) ? globalThis.String(object.fullScreenTextColor) : "",
      backgroundImageV2: isSet(object.backgroundImageV2) ? ImageModel.fromJSON(object.backgroundImageV2) : undefined,
      giftImage: isSet(object.giftImage) ? ImageModel.fromJSON(object.giftImage) : undefined,
      inputType: isSet(object.inputType) ? globalThis.Number(object.inputType) : 0,
      atUser: isSet(object.atUser) ? User.fromJSON(object.atUser) : undefined,
      emotes: globalThis.Array.isArray(object?.emotes)
        ? object.emotes.map((e: any) => WebcastSubEmote.fromJSON(e))
        : [],
      contentLanguage: isSet(object.contentLanguage) ? globalThis.String(object.contentLanguage) : "",
      quickChatScene: isSet(object.quickChatScene) ? globalThis.Number(object.quickChatScene) : 0,
      communityflaggedStatus: isSet(object.communityflaggedStatus)
        ? globalThis.Number(object.communityflaggedStatus)
        : 0,
      commentQualityScores: globalThis.Array.isArray(object?.commentQualityScores)
        ? object.commentQualityScores.map((e: any) => WebcastChatMessage_CommentQualityScore.fromJSON(e))
        : [],
      userIdentity: isSet(object.userIdentity)
        ? WebcastChatMessage_UserIdentity.fromJSON(object.userIdentity)
        : undefined,
      commentTag: globalThis.Array.isArray(object?.commentTag)
        ? object.commentTag.map((e: any) => webcastChatMessage_CommentTagFromJSON(e))
        : [],
      screenTime: isSet(object.screenTime) ? globalThis.String(object.screenTime) : "0",
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      signatureVersion: isSet(object.signatureVersion) ? globalThis.String(object.signatureVersion) : "",
      ecStreamerKey: isSet(object.ecStreamerKey) ? globalThis.String(object.ecStreamerKey) : "",
    };
  },

  toJSON(message: WebcastChatMessage): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = WebcastMessageEvent.toJSON(message.event);
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.visibleToSender !== false) {
      obj.visibleToSender = message.visibleToSender;
    }
    if (message.background !== undefined) {
      obj.background = ImageModel.toJSON(message.background);
    }
    if (message.fullScreenTextColor !== "") {
      obj.fullScreenTextColor = message.fullScreenTextColor;
    }
    if (message.backgroundImageV2 !== undefined) {
      obj.backgroundImageV2 = ImageModel.toJSON(message.backgroundImageV2);
    }
    if (message.giftImage !== undefined) {
      obj.giftImage = ImageModel.toJSON(message.giftImage);
    }
    if (message.inputType !== 0) {
      obj.inputType = Math.round(message.inputType);
    }
    if (message.atUser !== undefined) {
      obj.atUser = User.toJSON(message.atUser);
    }
    if (message.emotes?.length) {
      obj.emotes = message.emotes.map((e) => WebcastSubEmote.toJSON(e));
    }
    if (message.contentLanguage !== "") {
      obj.contentLanguage = message.contentLanguage;
    }
    if (message.quickChatScene !== 0) {
      obj.quickChatScene = Math.round(message.quickChatScene);
    }
    if (message.communityflaggedStatus !== 0) {
      obj.communityflaggedStatus = Math.round(message.communityflaggedStatus);
    }
    if (message.commentQualityScores?.length) {
      obj.commentQualityScores = message.commentQualityScores.map((e) =>
        WebcastChatMessage_CommentQualityScore.toJSON(e)
      );
    }
    if (message.userIdentity !== undefined) {
      obj.userIdentity = WebcastChatMessage_UserIdentity.toJSON(message.userIdentity);
    }
    if (message.commentTag?.length) {
      obj.commentTag = message.commentTag.map((e) => webcastChatMessage_CommentTagToJSON(e));
    }
    if (message.screenTime !== "0") {
      obj.screenTime = message.screenTime;
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.signatureVersion !== "") {
      obj.signatureVersion = message.signatureVersion;
    }
    if (message.ecStreamerKey !== "") {
      obj.ecStreamerKey = message.ecStreamerKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastChatMessage>, I>>(base?: I): WebcastChatMessage {
    return WebcastChatMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastChatMessage>, I>>(object: I): WebcastChatMessage {
    const message = createBaseWebcastChatMessage();
    message.event = (object.event !== undefined && object.event !== null)
      ? WebcastMessageEvent.fromPartial(object.event)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.comment = object.comment ?? "";
    message.visibleToSender = object.visibleToSender ?? false;
    message.background = (object.background !== undefined && object.background !== null)
      ? ImageModel.fromPartial(object.background)
      : undefined;
    message.fullScreenTextColor = object.fullScreenTextColor ?? "";
    message.backgroundImageV2 = (object.backgroundImageV2 !== undefined && object.backgroundImageV2 !== null)
      ? ImageModel.fromPartial(object.backgroundImageV2)
      : undefined;
    message.giftImage = (object.giftImage !== undefined && object.giftImage !== null)
      ? ImageModel.fromPartial(object.giftImage)
      : undefined;
    message.inputType = object.inputType ?? 0;
    message.atUser = (object.atUser !== undefined && object.atUser !== null)
      ? User.fromPartial(object.atUser)
      : undefined;
    message.emotes = object.emotes?.map((e) => WebcastSubEmote.fromPartial(e)) || [];
    message.contentLanguage = object.contentLanguage ?? "";
    message.quickChatScene = object.quickChatScene ?? 0;
    message.communityflaggedStatus = object.communityflaggedStatus ?? 0;
    message.commentQualityScores =
      object.commentQualityScores?.map((e) => WebcastChatMessage_CommentQualityScore.fromPartial(e)) || [];
    message.userIdentity = (object.userIdentity !== undefined && object.userIdentity !== null)
      ? WebcastChatMessage_UserIdentity.fromPartial(object.userIdentity)
      : undefined;
    message.commentTag = object.commentTag?.map((e) => e) || [];
    message.screenTime = object.screenTime ?? "0";
    message.signature = object.signature ?? "";
    message.signatureVersion = object.signatureVersion ?? "";
    message.ecStreamerKey = object.ecStreamerKey ?? "";
    return message;
  },
};

function createBaseWebcastChatMessage_UserIdentity(): WebcastChatMessage_UserIdentity {
  return {
    isGiftGiverOfAnchor: false,
    isSubscriberOfAnchor: false,
    isMutualFollowingWithAnchor: false,
    isFollowerOfAnchor: false,
    isModeratorOfAnchor: false,
    isAnchor: false,
  };
}

export const WebcastChatMessage_UserIdentity: MessageFns<WebcastChatMessage_UserIdentity> = {
  encode(message: WebcastChatMessage_UserIdentity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isGiftGiverOfAnchor !== false) {
      writer.uint32(8).bool(message.isGiftGiverOfAnchor);
    }
    if (message.isSubscriberOfAnchor !== false) {
      writer.uint32(16).bool(message.isSubscriberOfAnchor);
    }
    if (message.isMutualFollowingWithAnchor !== false) {
      writer.uint32(24).bool(message.isMutualFollowingWithAnchor);
    }
    if (message.isFollowerOfAnchor !== false) {
      writer.uint32(32).bool(message.isFollowerOfAnchor);
    }
    if (message.isModeratorOfAnchor !== false) {
      writer.uint32(40).bool(message.isModeratorOfAnchor);
    }
    if (message.isAnchor !== false) {
      writer.uint32(48).bool(message.isAnchor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastChatMessage_UserIdentity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastChatMessage_UserIdentity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isGiftGiverOfAnchor = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSubscriberOfAnchor = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isMutualFollowingWithAnchor = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isFollowerOfAnchor = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isModeratorOfAnchor = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isAnchor = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastChatMessage_UserIdentity {
    return {
      isGiftGiverOfAnchor: isSet(object.isGiftGiverOfAnchor) ? globalThis.Boolean(object.isGiftGiverOfAnchor) : false,
      isSubscriberOfAnchor: isSet(object.isSubscriberOfAnchor)
        ? globalThis.Boolean(object.isSubscriberOfAnchor)
        : false,
      isMutualFollowingWithAnchor: isSet(object.isMutualFollowingWithAnchor)
        ? globalThis.Boolean(object.isMutualFollowingWithAnchor)
        : false,
      isFollowerOfAnchor: isSet(object.isFollowerOfAnchor) ? globalThis.Boolean(object.isFollowerOfAnchor) : false,
      isModeratorOfAnchor: isSet(object.isModeratorOfAnchor) ? globalThis.Boolean(object.isModeratorOfAnchor) : false,
      isAnchor: isSet(object.isAnchor) ? globalThis.Boolean(object.isAnchor) : false,
    };
  },

  toJSON(message: WebcastChatMessage_UserIdentity): unknown {
    const obj: any = {};
    if (message.isGiftGiverOfAnchor !== false) {
      obj.isGiftGiverOfAnchor = message.isGiftGiverOfAnchor;
    }
    if (message.isSubscriberOfAnchor !== false) {
      obj.isSubscriberOfAnchor = message.isSubscriberOfAnchor;
    }
    if (message.isMutualFollowingWithAnchor !== false) {
      obj.isMutualFollowingWithAnchor = message.isMutualFollowingWithAnchor;
    }
    if (message.isFollowerOfAnchor !== false) {
      obj.isFollowerOfAnchor = message.isFollowerOfAnchor;
    }
    if (message.isModeratorOfAnchor !== false) {
      obj.isModeratorOfAnchor = message.isModeratorOfAnchor;
    }
    if (message.isAnchor !== false) {
      obj.isAnchor = message.isAnchor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastChatMessage_UserIdentity>, I>>(base?: I): WebcastChatMessage_UserIdentity {
    return WebcastChatMessage_UserIdentity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastChatMessage_UserIdentity>, I>>(
    object: I,
  ): WebcastChatMessage_UserIdentity {
    const message = createBaseWebcastChatMessage_UserIdentity();
    message.isGiftGiverOfAnchor = object.isGiftGiverOfAnchor ?? false;
    message.isSubscriberOfAnchor = object.isSubscriberOfAnchor ?? false;
    message.isMutualFollowingWithAnchor = object.isMutualFollowingWithAnchor ?? false;
    message.isFollowerOfAnchor = object.isFollowerOfAnchor ?? false;
    message.isModeratorOfAnchor = object.isModeratorOfAnchor ?? false;
    message.isAnchor = object.isAnchor ?? false;
    return message;
  },
};

function createBaseWebcastChatMessage_CommentQualityScore(): WebcastChatMessage_CommentQualityScore {
  return { version: "", score: "0" };
}

export const WebcastChatMessage_CommentQualityScore: MessageFns<WebcastChatMessage_CommentQualityScore> = {
  encode(message: WebcastChatMessage_CommentQualityScore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.score !== "0") {
      writer.uint32(16).int64(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastChatMessage_CommentQualityScore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastChatMessage_CommentQualityScore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.score = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastChatMessage_CommentQualityScore {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      score: isSet(object.score) ? globalThis.String(object.score) : "0",
    };
  },

  toJSON(message: WebcastChatMessage_CommentQualityScore): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.score !== "0") {
      obj.score = message.score;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastChatMessage_CommentQualityScore>, I>>(
    base?: I,
  ): WebcastChatMessage_CommentQualityScore {
    return WebcastChatMessage_CommentQualityScore.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastChatMessage_CommentQualityScore>, I>>(
    object: I,
  ): WebcastChatMessage_CommentQualityScore {
    const message = createBaseWebcastChatMessage_CommentQualityScore();
    message.version = object.version ?? "";
    message.score = object.score ?? "0";
    return message;
  },
};

function createBaseEmoteUploadInfo(): EmoteUploadInfo {
  return { userId: "0", emoteUploadSource: undefined, userInfo: undefined, userIdStr: "" };
}

export const EmoteUploadInfo: MessageFns<EmoteUploadInfo> = {
  encode(message: EmoteUploadInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.emoteUploadSource !== undefined) {
      writer.uint32(16).int32(message.emoteUploadSource);
    }
    if (message.userInfo !== undefined) {
      User.encode(message.userInfo, writer.uint32(26).fork()).join();
    }
    if (message.userIdStr !== "") {
      writer.uint32(34).string(message.userIdStr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmoteUploadInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmoteUploadInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.emoteUploadSource = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userInfo = User.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userIdStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmoteUploadInfo {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "0",
      emoteUploadSource: isSet(object.emoteUploadSource)
        ? emoteUploadInfo_UserEmoteUploadSourceFromJSON(object.emoteUploadSource)
        : undefined,
      userInfo: isSet(object.userInfo) ? User.fromJSON(object.userInfo) : undefined,
      userIdStr: isSet(object.userIdStr) ? globalThis.String(object.userIdStr) : "",
    };
  },

  toJSON(message: EmoteUploadInfo): unknown {
    const obj: any = {};
    if (message.userId !== "0") {
      obj.userId = message.userId;
    }
    if (message.emoteUploadSource !== undefined) {
      obj.emoteUploadSource = emoteUploadInfo_UserEmoteUploadSourceToJSON(message.emoteUploadSource);
    }
    if (message.userInfo !== undefined) {
      obj.userInfo = User.toJSON(message.userInfo);
    }
    if (message.userIdStr !== "") {
      obj.userIdStr = message.userIdStr;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmoteUploadInfo>, I>>(base?: I): EmoteUploadInfo {
    return EmoteUploadInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmoteUploadInfo>, I>>(object: I): EmoteUploadInfo {
    const message = createBaseEmoteUploadInfo();
    message.userId = object.userId ?? "0";
    message.emoteUploadSource = object.emoteUploadSource ?? undefined;
    message.userInfo = (object.userInfo !== undefined && object.userInfo !== null)
      ? User.fromPartial(object.userInfo)
      : undefined;
    message.userIdStr = object.userIdStr ?? "";
    return message;
  },
};

function createBaseWebcastEmoteChatMessage(): WebcastEmoteChatMessage {
  return { user: undefined, emote: undefined };
}

export const WebcastEmoteChatMessage: MessageFns<WebcastEmoteChatMessage> = {
  encode(message: WebcastEmoteChatMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.emote !== undefined) {
      EmoteDetails.encode(message.emote, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastEmoteChatMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastEmoteChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.emote = EmoteDetails.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastEmoteChatMessage {
    return {
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      emote: isSet(object.emote) ? EmoteDetails.fromJSON(object.emote) : undefined,
    };
  },

  toJSON(message: WebcastEmoteChatMessage): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.emote !== undefined) {
      obj.emote = EmoteDetails.toJSON(message.emote);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastEmoteChatMessage>, I>>(base?: I): WebcastEmoteChatMessage {
    return WebcastEmoteChatMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastEmoteChatMessage>, I>>(object: I): WebcastEmoteChatMessage {
    const message = createBaseWebcastEmoteChatMessage();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.emote = (object.emote !== undefined && object.emote !== null)
      ? EmoteDetails.fromPartial(object.emote)
      : undefined;
    return message;
  },
};

function createBaseWebcastSubEmote(): WebcastSubEmote {
  return { placeInComment: 0, emote: undefined };
}

export const WebcastSubEmote: MessageFns<WebcastSubEmote> = {
  encode(message: WebcastSubEmote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.placeInComment !== 0) {
      writer.uint32(8).int32(message.placeInComment);
    }
    if (message.emote !== undefined) {
      EmoteDetails.encode(message.emote, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastSubEmote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastSubEmote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.placeInComment = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.emote = EmoteDetails.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastSubEmote {
    return {
      placeInComment: isSet(object.placeInComment) ? globalThis.Number(object.placeInComment) : 0,
      emote: isSet(object.emote) ? EmoteDetails.fromJSON(object.emote) : undefined,
    };
  },

  toJSON(message: WebcastSubEmote): unknown {
    const obj: any = {};
    if (message.placeInComment !== 0) {
      obj.placeInComment = Math.round(message.placeInComment);
    }
    if (message.emote !== undefined) {
      obj.emote = EmoteDetails.toJSON(message.emote);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastSubEmote>, I>>(base?: I): WebcastSubEmote {
    return WebcastSubEmote.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastSubEmote>, I>>(object: I): WebcastSubEmote {
    const message = createBaseWebcastSubEmote();
    message.placeInComment = object.placeInComment ?? 0;
    message.emote = (object.emote !== undefined && object.emote !== null)
      ? EmoteDetails.fromPartial(object.emote)
      : undefined;
    return message;
  },
};

function createBaseWebcastMemberMessage(): WebcastMemberMessage {
  return { event: undefined, user: undefined, actionId: 0 };
}

export const WebcastMemberMessage: MessageFns<WebcastMemberMessage> = {
  encode(message: WebcastMemberMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== undefined) {
      WebcastMessageEvent.encode(message.event, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.actionId !== 0) {
      writer.uint32(80).int32(message.actionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMemberMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMemberMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = WebcastMessageEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.actionId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastMemberMessage {
    return {
      event: isSet(object.event) ? WebcastMessageEvent.fromJSON(object.event) : undefined,
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      actionId: isSet(object.actionId) ? globalThis.Number(object.actionId) : 0,
    };
  },

  toJSON(message: WebcastMemberMessage): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = WebcastMessageEvent.toJSON(message.event);
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.actionId !== 0) {
      obj.actionId = Math.round(message.actionId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastMemberMessage>, I>>(base?: I): WebcastMemberMessage {
    return WebcastMemberMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastMemberMessage>, I>>(object: I): WebcastMemberMessage {
    const message = createBaseWebcastMemberMessage();
    message.event = (object.event !== undefined && object.event !== null)
      ? WebcastMessageEvent.fromPartial(object.event)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.actionId = object.actionId ?? 0;
    return message;
  },
};

function createBaseWebcastGiftMessage(): WebcastGiftMessage {
  return {
    event: undefined,
    giftId: 0,
    repeatCount: 0,
    user: undefined,
    repeatEnd: 0,
    groupId: "0",
    giftDetails: undefined,
    monitorExtra: "",
    giftExtra: undefined,
  };
}

export const WebcastGiftMessage: MessageFns<WebcastGiftMessage> = {
  encode(message: WebcastGiftMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== undefined) {
      WebcastMessageEvent.encode(message.event, writer.uint32(10).fork()).join();
    }
    if (message.giftId !== 0) {
      writer.uint32(16).int32(message.giftId);
    }
    if (message.repeatCount !== 0) {
      writer.uint32(40).int32(message.repeatCount);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(58).fork()).join();
    }
    if (message.repeatEnd !== 0) {
      writer.uint32(72).int32(message.repeatEnd);
    }
    if (message.groupId !== "0") {
      writer.uint32(88).uint64(message.groupId);
    }
    if (message.giftDetails !== undefined) {
      WebcastGiftMessageGiftDetails.encode(message.giftDetails, writer.uint32(122).fork()).join();
    }
    if (message.monitorExtra !== "") {
      writer.uint32(178).string(message.monitorExtra);
    }
    if (message.giftExtra !== undefined) {
      WebcastGiftMessageGiftExtra.encode(message.giftExtra, writer.uint32(186).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = WebcastMessageEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.giftId = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.repeatCount = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.repeatEnd = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.groupId = reader.uint64().toString();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.giftDetails = WebcastGiftMessageGiftDetails.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.monitorExtra = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.giftExtra = WebcastGiftMessageGiftExtra.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastGiftMessage {
    return {
      event: isSet(object.event) ? WebcastMessageEvent.fromJSON(object.event) : undefined,
      giftId: isSet(object.giftId) ? globalThis.Number(object.giftId) : 0,
      repeatCount: isSet(object.repeatCount) ? globalThis.Number(object.repeatCount) : 0,
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      repeatEnd: isSet(object.repeatEnd) ? globalThis.Number(object.repeatEnd) : 0,
      groupId: isSet(object.groupId) ? globalThis.String(object.groupId) : "0",
      giftDetails: isSet(object.giftDetails) ? WebcastGiftMessageGiftDetails.fromJSON(object.giftDetails) : undefined,
      monitorExtra: isSet(object.monitorExtra) ? globalThis.String(object.monitorExtra) : "",
      giftExtra: isSet(object.giftExtra) ? WebcastGiftMessageGiftExtra.fromJSON(object.giftExtra) : undefined,
    };
  },

  toJSON(message: WebcastGiftMessage): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = WebcastMessageEvent.toJSON(message.event);
    }
    if (message.giftId !== 0) {
      obj.giftId = Math.round(message.giftId);
    }
    if (message.repeatCount !== 0) {
      obj.repeatCount = Math.round(message.repeatCount);
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.repeatEnd !== 0) {
      obj.repeatEnd = Math.round(message.repeatEnd);
    }
    if (message.groupId !== "0") {
      obj.groupId = message.groupId;
    }
    if (message.giftDetails !== undefined) {
      obj.giftDetails = WebcastGiftMessageGiftDetails.toJSON(message.giftDetails);
    }
    if (message.monitorExtra !== "") {
      obj.monitorExtra = message.monitorExtra;
    }
    if (message.giftExtra !== undefined) {
      obj.giftExtra = WebcastGiftMessageGiftExtra.toJSON(message.giftExtra);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastGiftMessage>, I>>(base?: I): WebcastGiftMessage {
    return WebcastGiftMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastGiftMessage>, I>>(object: I): WebcastGiftMessage {
    const message = createBaseWebcastGiftMessage();
    message.event = (object.event !== undefined && object.event !== null)
      ? WebcastMessageEvent.fromPartial(object.event)
      : undefined;
    message.giftId = object.giftId ?? 0;
    message.repeatCount = object.repeatCount ?? 0;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.repeatEnd = object.repeatEnd ?? 0;
    message.groupId = object.groupId ?? "0";
    message.giftDetails = (object.giftDetails !== undefined && object.giftDetails !== null)
      ? WebcastGiftMessageGiftDetails.fromPartial(object.giftDetails)
      : undefined;
    message.monitorExtra = object.monitorExtra ?? "";
    message.giftExtra = (object.giftExtra !== undefined && object.giftExtra !== null)
      ? WebcastGiftMessageGiftExtra.fromPartial(object.giftExtra)
      : undefined;
    return message;
  },
};

function createBaseWebcastGiftMessageGiftDetails(): WebcastGiftMessageGiftDetails {
  return { giftImage: undefined, giftName: "", describe: "", giftType: 0, diamondCount: 0 };
}

export const WebcastGiftMessageGiftDetails: MessageFns<WebcastGiftMessageGiftDetails> = {
  encode(message: WebcastGiftMessageGiftDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftImage !== undefined) {
      WebcastGiftMessageGiftImage.encode(message.giftImage, writer.uint32(10).fork()).join();
    }
    if (message.giftName !== "") {
      writer.uint32(130).string(message.giftName);
    }
    if (message.describe !== "") {
      writer.uint32(18).string(message.describe);
    }
    if (message.giftType !== 0) {
      writer.uint32(88).int32(message.giftType);
    }
    if (message.diamondCount !== 0) {
      writer.uint32(96).int32(message.diamondCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessageGiftDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessageGiftDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.giftImage = WebcastGiftMessageGiftImage.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.giftName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.describe = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.giftType = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.diamondCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastGiftMessageGiftDetails {
    return {
      giftImage: isSet(object.giftImage) ? WebcastGiftMessageGiftImage.fromJSON(object.giftImage) : undefined,
      giftName: isSet(object.giftName) ? globalThis.String(object.giftName) : "",
      describe: isSet(object.describe) ? globalThis.String(object.describe) : "",
      giftType: isSet(object.giftType) ? globalThis.Number(object.giftType) : 0,
      diamondCount: isSet(object.diamondCount) ? globalThis.Number(object.diamondCount) : 0,
    };
  },

  toJSON(message: WebcastGiftMessageGiftDetails): unknown {
    const obj: any = {};
    if (message.giftImage !== undefined) {
      obj.giftImage = WebcastGiftMessageGiftImage.toJSON(message.giftImage);
    }
    if (message.giftName !== "") {
      obj.giftName = message.giftName;
    }
    if (message.describe !== "") {
      obj.describe = message.describe;
    }
    if (message.giftType !== 0) {
      obj.giftType = Math.round(message.giftType);
    }
    if (message.diamondCount !== 0) {
      obj.diamondCount = Math.round(message.diamondCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastGiftMessageGiftDetails>, I>>(base?: I): WebcastGiftMessageGiftDetails {
    return WebcastGiftMessageGiftDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastGiftMessageGiftDetails>, I>>(
    object: I,
  ): WebcastGiftMessageGiftDetails {
    const message = createBaseWebcastGiftMessageGiftDetails();
    message.giftImage = (object.giftImage !== undefined && object.giftImage !== null)
      ? WebcastGiftMessageGiftImage.fromPartial(object.giftImage)
      : undefined;
    message.giftName = object.giftName ?? "";
    message.describe = object.describe ?? "";
    message.giftType = object.giftType ?? 0;
    message.diamondCount = object.diamondCount ?? 0;
    return message;
  },
};

function createBaseWebcastGiftMessageGiftExtra(): WebcastGiftMessageGiftExtra {
  return { timestamp: "0", receiverUserId: "0" };
}

export const WebcastGiftMessageGiftExtra: MessageFns<WebcastGiftMessageGiftExtra> = {
  encode(message: WebcastGiftMessageGiftExtra, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== "0") {
      writer.uint32(48).uint64(message.timestamp);
    }
    if (message.receiverUserId !== "0") {
      writer.uint32(64).uint64(message.receiverUserId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessageGiftExtra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessageGiftExtra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.timestamp = reader.uint64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.receiverUserId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastGiftMessageGiftExtra {
    return {
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "0",
      receiverUserId: isSet(object.receiverUserId) ? globalThis.String(object.receiverUserId) : "0",
    };
  },

  toJSON(message: WebcastGiftMessageGiftExtra): unknown {
    const obj: any = {};
    if (message.timestamp !== "0") {
      obj.timestamp = message.timestamp;
    }
    if (message.receiverUserId !== "0") {
      obj.receiverUserId = message.receiverUserId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastGiftMessageGiftExtra>, I>>(base?: I): WebcastGiftMessageGiftExtra {
    return WebcastGiftMessageGiftExtra.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastGiftMessageGiftExtra>, I>>(object: I): WebcastGiftMessageGiftExtra {
    const message = createBaseWebcastGiftMessageGiftExtra();
    message.timestamp = object.timestamp ?? "0";
    message.receiverUserId = object.receiverUserId ?? "0";
    return message;
  },
};

function createBaseWebcastGiftMessageGiftImage(): WebcastGiftMessageGiftImage {
  return { giftPictureUrl: "" };
}

export const WebcastGiftMessageGiftImage: MessageFns<WebcastGiftMessageGiftImage> = {
  encode(message: WebcastGiftMessageGiftImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftPictureUrl !== "") {
      writer.uint32(10).string(message.giftPictureUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessageGiftImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessageGiftImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.giftPictureUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastGiftMessageGiftImage {
    return { giftPictureUrl: isSet(object.giftPictureUrl) ? globalThis.String(object.giftPictureUrl) : "" };
  },

  toJSON(message: WebcastGiftMessageGiftImage): unknown {
    const obj: any = {};
    if (message.giftPictureUrl !== "") {
      obj.giftPictureUrl = message.giftPictureUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastGiftMessageGiftImage>, I>>(base?: I): WebcastGiftMessageGiftImage {
    return WebcastGiftMessageGiftImage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastGiftMessageGiftImage>, I>>(object: I): WebcastGiftMessageGiftImage {
    const message = createBaseWebcastGiftMessageGiftImage();
    message.giftPictureUrl = object.giftPictureUrl ?? "";
    return message;
  },
};

function createBaseWebcastLinkMicBattle(): WebcastLinkMicBattle {
  return { battleUsers: [] };
}

export const WebcastLinkMicBattle: MessageFns<WebcastLinkMicBattle> = {
  encode(message: WebcastLinkMicBattle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.battleUsers) {
      WebcastLinkMicBattleItems.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.battleUsers.push(WebcastLinkMicBattleItems.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastLinkMicBattle {
    return {
      battleUsers: globalThis.Array.isArray(object?.battleUsers)
        ? object.battleUsers.map((e: any) => WebcastLinkMicBattleItems.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WebcastLinkMicBattle): unknown {
    const obj: any = {};
    if (message.battleUsers?.length) {
      obj.battleUsers = message.battleUsers.map((e) => WebcastLinkMicBattleItems.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastLinkMicBattle>, I>>(base?: I): WebcastLinkMicBattle {
    return WebcastLinkMicBattle.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastLinkMicBattle>, I>>(object: I): WebcastLinkMicBattle {
    const message = createBaseWebcastLinkMicBattle();
    message.battleUsers = object.battleUsers?.map((e) => WebcastLinkMicBattleItems.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWebcastLinkMicBattleItems(): WebcastLinkMicBattleItems {
  return { battleGroup: undefined };
}

export const WebcastLinkMicBattleItems: MessageFns<WebcastLinkMicBattleItems> = {
  encode(message: WebcastLinkMicBattleItems, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.battleGroup !== undefined) {
      WebcastLinkMicBattleGroup.encode(message.battleGroup, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattleItems {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattleItems();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.battleGroup = WebcastLinkMicBattleGroup.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastLinkMicBattleItems {
    return {
      battleGroup: isSet(object.battleGroup) ? WebcastLinkMicBattleGroup.fromJSON(object.battleGroup) : undefined,
    };
  },

  toJSON(message: WebcastLinkMicBattleItems): unknown {
    const obj: any = {};
    if (message.battleGroup !== undefined) {
      obj.battleGroup = WebcastLinkMicBattleGroup.toJSON(message.battleGroup);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastLinkMicBattleItems>, I>>(base?: I): WebcastLinkMicBattleItems {
    return WebcastLinkMicBattleItems.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastLinkMicBattleItems>, I>>(object: I): WebcastLinkMicBattleItems {
    const message = createBaseWebcastLinkMicBattleItems();
    message.battleGroup = (object.battleGroup !== undefined && object.battleGroup !== null)
      ? WebcastLinkMicBattleGroup.fromPartial(object.battleGroup)
      : undefined;
    return message;
  },
};

function createBaseWebcastLinkMicBattleGroup(): WebcastLinkMicBattleGroup {
  return { user: undefined };
}

export const WebcastLinkMicBattleGroup: MessageFns<WebcastLinkMicBattleGroup> = {
  encode(message: WebcastLinkMicBattleGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      LinkUser.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattleGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattleGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = LinkUser.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastLinkMicBattleGroup {
    return { user: isSet(object.user) ? LinkUser.fromJSON(object.user) : undefined };
  },

  toJSON(message: WebcastLinkMicBattleGroup): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = LinkUser.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastLinkMicBattleGroup>, I>>(base?: I): WebcastLinkMicBattleGroup {
    return WebcastLinkMicBattleGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastLinkMicBattleGroup>, I>>(object: I): WebcastLinkMicBattleGroup {
    const message = createBaseWebcastLinkMicBattleGroup();
    message.user = (object.user !== undefined && object.user !== null) ? LinkUser.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseWebcastLinkMicArmies(): WebcastLinkMicArmies {
  return { battleItems: [], battleStatus: 0 };
}

export const WebcastLinkMicArmies: MessageFns<WebcastLinkMicArmies> = {
  encode(message: WebcastLinkMicArmies, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.battleItems) {
      WebcastLinkMicArmiesItems.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.battleStatus !== 0) {
      writer.uint32(56).int32(message.battleStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicArmies {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicArmies();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.battleItems.push(WebcastLinkMicArmiesItems.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.battleStatus = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastLinkMicArmies {
    return {
      battleItems: globalThis.Array.isArray(object?.battleItems)
        ? object.battleItems.map((e: any) => WebcastLinkMicArmiesItems.fromJSON(e))
        : [],
      battleStatus: isSet(object.battleStatus) ? globalThis.Number(object.battleStatus) : 0,
    };
  },

  toJSON(message: WebcastLinkMicArmies): unknown {
    const obj: any = {};
    if (message.battleItems?.length) {
      obj.battleItems = message.battleItems.map((e) => WebcastLinkMicArmiesItems.toJSON(e));
    }
    if (message.battleStatus !== 0) {
      obj.battleStatus = Math.round(message.battleStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastLinkMicArmies>, I>>(base?: I): WebcastLinkMicArmies {
    return WebcastLinkMicArmies.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastLinkMicArmies>, I>>(object: I): WebcastLinkMicArmies {
    const message = createBaseWebcastLinkMicArmies();
    message.battleItems = object.battleItems?.map((e) => WebcastLinkMicArmiesItems.fromPartial(e)) || [];
    message.battleStatus = object.battleStatus ?? 0;
    return message;
  },
};

function createBaseWebcastLinkMicArmiesItems(): WebcastLinkMicArmiesItems {
  return { hostUserId: "0", battleGroups: [] };
}

export const WebcastLinkMicArmiesItems: MessageFns<WebcastLinkMicArmiesItems> = {
  encode(message: WebcastLinkMicArmiesItems, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostUserId !== "0") {
      writer.uint32(8).uint64(message.hostUserId);
    }
    for (const v of message.battleGroups) {
      WebcastLinkMicArmiesGroup.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicArmiesItems {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicArmiesItems();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hostUserId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.battleGroups.push(WebcastLinkMicArmiesGroup.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastLinkMicArmiesItems {
    return {
      hostUserId: isSet(object.hostUserId) ? globalThis.String(object.hostUserId) : "0",
      battleGroups: globalThis.Array.isArray(object?.battleGroups)
        ? object.battleGroups.map((e: any) => WebcastLinkMicArmiesGroup.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WebcastLinkMicArmiesItems): unknown {
    const obj: any = {};
    if (message.hostUserId !== "0") {
      obj.hostUserId = message.hostUserId;
    }
    if (message.battleGroups?.length) {
      obj.battleGroups = message.battleGroups.map((e) => WebcastLinkMicArmiesGroup.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastLinkMicArmiesItems>, I>>(base?: I): WebcastLinkMicArmiesItems {
    return WebcastLinkMicArmiesItems.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastLinkMicArmiesItems>, I>>(object: I): WebcastLinkMicArmiesItems {
    const message = createBaseWebcastLinkMicArmiesItems();
    message.hostUserId = object.hostUserId ?? "0";
    message.battleGroups = object.battleGroups?.map((e) => WebcastLinkMicArmiesGroup.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWebcastLinkMicArmiesGroup(): WebcastLinkMicArmiesGroup {
  return { users: [], points: 0 };
}

export const WebcastLinkMicArmiesGroup: MessageFns<WebcastLinkMicArmiesGroup> = {
  encode(message: WebcastLinkMicArmiesGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.users) {
      User.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.points !== 0) {
      writer.uint32(16).int32(message.points);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicArmiesGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicArmiesGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.points = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastLinkMicArmiesGroup {
    return {
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => User.fromJSON(e)) : [],
      points: isSet(object.points) ? globalThis.Number(object.points) : 0,
    };
  },

  toJSON(message: WebcastLinkMicArmiesGroup): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users.map((e) => User.toJSON(e));
    }
    if (message.points !== 0) {
      obj.points = Math.round(message.points);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastLinkMicArmiesGroup>, I>>(base?: I): WebcastLinkMicArmiesGroup {
    return WebcastLinkMicArmiesGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastLinkMicArmiesGroup>, I>>(object: I): WebcastLinkMicArmiesGroup {
    const message = createBaseWebcastLinkMicArmiesGroup();
    message.users = object.users?.map((e) => User.fromPartial(e)) || [];
    message.points = object.points ?? 0;
    return message;
  },
};

function createBaseWebcastSocialMessage(): WebcastSocialMessage {
  return { event: undefined, user: undefined };
}

export const WebcastSocialMessage: MessageFns<WebcastSocialMessage> = {
  encode(message: WebcastSocialMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== undefined) {
      WebcastMessageEvent.encode(message.event, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastSocialMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastSocialMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = WebcastMessageEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastSocialMessage {
    return {
      event: isSet(object.event) ? WebcastMessageEvent.fromJSON(object.event) : undefined,
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: WebcastSocialMessage): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = WebcastMessageEvent.toJSON(message.event);
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastSocialMessage>, I>>(base?: I): WebcastSocialMessage {
    return WebcastSocialMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastSocialMessage>, I>>(object: I): WebcastSocialMessage {
    const message = createBaseWebcastSocialMessage();
    message.event = (object.event !== undefined && object.event !== null)
      ? WebcastMessageEvent.fromPartial(object.event)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseWebcastLikeMessage(): WebcastLikeMessage {
  return { event: undefined, user: undefined, likeCount: 0, totalLikeCount: 0 };
}

export const WebcastLikeMessage: MessageFns<WebcastLikeMessage> = {
  encode(message: WebcastLikeMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== undefined) {
      WebcastMessageEvent.encode(message.event, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.likeCount !== 0) {
      writer.uint32(16).int32(message.likeCount);
    }
    if (message.totalLikeCount !== 0) {
      writer.uint32(24).int32(message.totalLikeCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLikeMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLikeMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = WebcastMessageEvent.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.likeCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalLikeCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastLikeMessage {
    return {
      event: isSet(object.event) ? WebcastMessageEvent.fromJSON(object.event) : undefined,
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      likeCount: isSet(object.likeCount) ? globalThis.Number(object.likeCount) : 0,
      totalLikeCount: isSet(object.totalLikeCount) ? globalThis.Number(object.totalLikeCount) : 0,
    };
  },

  toJSON(message: WebcastLikeMessage): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = WebcastMessageEvent.toJSON(message.event);
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.likeCount !== 0) {
      obj.likeCount = Math.round(message.likeCount);
    }
    if (message.totalLikeCount !== 0) {
      obj.totalLikeCount = Math.round(message.totalLikeCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastLikeMessage>, I>>(base?: I): WebcastLikeMessage {
    return WebcastLikeMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastLikeMessage>, I>>(object: I): WebcastLikeMessage {
    const message = createBaseWebcastLikeMessage();
    message.event = (object.event !== undefined && object.event !== null)
      ? WebcastMessageEvent.fromPartial(object.event)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.likeCount = object.likeCount ?? 0;
    message.totalLikeCount = object.totalLikeCount ?? 0;
    return message;
  },
};

function createBaseWebcastQuestionNewMessage(): WebcastQuestionNewMessage {
  return { questionDetails: undefined };
}

export const WebcastQuestionNewMessage: MessageFns<WebcastQuestionNewMessage> = {
  encode(message: WebcastQuestionNewMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.questionDetails !== undefined) {
      QuestionDetails.encode(message.questionDetails, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastQuestionNewMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastQuestionNewMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.questionDetails = QuestionDetails.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastQuestionNewMessage {
    return {
      questionDetails: isSet(object.questionDetails) ? QuestionDetails.fromJSON(object.questionDetails) : undefined,
    };
  },

  toJSON(message: WebcastQuestionNewMessage): unknown {
    const obj: any = {};
    if (message.questionDetails !== undefined) {
      obj.questionDetails = QuestionDetails.toJSON(message.questionDetails);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastQuestionNewMessage>, I>>(base?: I): WebcastQuestionNewMessage {
    return WebcastQuestionNewMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastQuestionNewMessage>, I>>(object: I): WebcastQuestionNewMessage {
    const message = createBaseWebcastQuestionNewMessage();
    message.questionDetails = (object.questionDetails !== undefined && object.questionDetails !== null)
      ? QuestionDetails.fromPartial(object.questionDetails)
      : undefined;
    return message;
  },
};

function createBaseQuestionDetails(): QuestionDetails {
  return { questionText: "", user: undefined };
}

export const QuestionDetails: MessageFns<QuestionDetails> = {
  encode(message: QuestionDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.questionText !== "") {
      writer.uint32(18).string(message.questionText);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuestionDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.questionText = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionDetails {
    return {
      questionText: isSet(object.questionText) ? globalThis.String(object.questionText) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: QuestionDetails): unknown {
    const obj: any = {};
    if (message.questionText !== "") {
      obj.questionText = message.questionText;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuestionDetails>, I>>(base?: I): QuestionDetails {
    return QuestionDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuestionDetails>, I>>(object: I): QuestionDetails {
    const message = createBaseQuestionDetails();
    message.questionText = object.questionText ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseWebcastMessageEvent(): WebcastMessageEvent {
  return { msgId: "0", createTime: "0", eventDetails: undefined };
}

export const WebcastMessageEvent: MessageFns<WebcastMessageEvent> = {
  encode(message: WebcastMessageEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msgId !== "0") {
      writer.uint32(16).uint64(message.msgId);
    }
    if (message.createTime !== "0") {
      writer.uint32(32).uint64(message.createTime);
    }
    if (message.eventDetails !== undefined) {
      WebcastMessageEventDetails.encode(message.eventDetails, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMessageEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMessageEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.msgId = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.createTime = reader.uint64().toString();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.eventDetails = WebcastMessageEventDetails.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastMessageEvent {
    return {
      msgId: isSet(object.msgId) ? globalThis.String(object.msgId) : "0",
      createTime: isSet(object.createTime) ? globalThis.String(object.createTime) : "0",
      eventDetails: isSet(object.eventDetails) ? WebcastMessageEventDetails.fromJSON(object.eventDetails) : undefined,
    };
  },

  toJSON(message: WebcastMessageEvent): unknown {
    const obj: any = {};
    if (message.msgId !== "0") {
      obj.msgId = message.msgId;
    }
    if (message.createTime !== "0") {
      obj.createTime = message.createTime;
    }
    if (message.eventDetails !== undefined) {
      obj.eventDetails = WebcastMessageEventDetails.toJSON(message.eventDetails);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastMessageEvent>, I>>(base?: I): WebcastMessageEvent {
    return WebcastMessageEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastMessageEvent>, I>>(object: I): WebcastMessageEvent {
    const message = createBaseWebcastMessageEvent();
    message.msgId = object.msgId ?? "0";
    message.createTime = object.createTime ?? "0";
    message.eventDetails = (object.eventDetails !== undefined && object.eventDetails !== null)
      ? WebcastMessageEventDetails.fromPartial(object.eventDetails)
      : undefined;
    return message;
  },
};

function createBaseWebcastMessageEventDetails(): WebcastMessageEventDetails {
  return { displayType: "", label: "" };
}

export const WebcastMessageEventDetails: MessageFns<WebcastMessageEventDetails> = {
  encode(message: WebcastMessageEventDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayType !== "") {
      writer.uint32(10).string(message.displayType);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMessageEventDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMessageEventDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastMessageEventDetails {
    return {
      displayType: isSet(object.displayType) ? globalThis.String(object.displayType) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
    };
  },

  toJSON(message: WebcastMessageEventDetails): unknown {
    const obj: any = {};
    if (message.displayType !== "") {
      obj.displayType = message.displayType;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastMessageEventDetails>, I>>(base?: I): WebcastMessageEventDetails {
    return WebcastMessageEventDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastMessageEventDetails>, I>>(object: I): WebcastMessageEventDetails {
    const message = createBaseWebcastMessageEventDetails();
    message.displayType = object.displayType ?? "";
    message.label = object.label ?? "";
    return message;
  },
};

function createBaseWebcastLiveIntroMessage(): WebcastLiveIntroMessage {
  return { id: "0", description: "", user: undefined };
}

export const WebcastLiveIntroMessage: MessageFns<WebcastLiveIntroMessage> = {
  encode(message: WebcastLiveIntroMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(16).uint64(message.id);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLiveIntroMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLiveIntroMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastLiveIntroMessage {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "0",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: WebcastLiveIntroMessage): unknown {
    const obj: any = {};
    if (message.id !== "0") {
      obj.id = message.id;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastLiveIntroMessage>, I>>(base?: I): WebcastLiveIntroMessage {
    return WebcastLiveIntroMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastLiveIntroMessage>, I>>(object: I): WebcastLiveIntroMessage {
    const message = createBaseWebcastLiveIntroMessage();
    message.id = object.id ?? "0";
    message.description = object.description ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseSystemMessage(): SystemMessage {
  return { description: "" };
}

export const SystemMessage: MessageFns<SystemMessage> = {
  encode(message: SystemMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SystemMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemMessage {
    return { description: isSet(object.description) ? globalThis.String(object.description) : "" };
  },

  toJSON(message: SystemMessage): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SystemMessage>, I>>(base?: I): SystemMessage {
    return SystemMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SystemMessage>, I>>(object: I): SystemMessage {
    const message = createBaseSystemMessage();
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseWebcastInRoomBannerMessage(): WebcastInRoomBannerMessage {
  return { data: "" };
}

export const WebcastInRoomBannerMessage: MessageFns<WebcastInRoomBannerMessage> = {
  encode(message: WebcastInRoomBannerMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== "") {
      writer.uint32(18).string(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastInRoomBannerMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastInRoomBannerMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastInRoomBannerMessage {
    return { data: isSet(object.data) ? globalThis.String(object.data) : "" };
  },

  toJSON(message: WebcastInRoomBannerMessage): unknown {
    const obj: any = {};
    if (message.data !== "") {
      obj.data = message.data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastInRoomBannerMessage>, I>>(base?: I): WebcastInRoomBannerMessage {
    return WebcastInRoomBannerMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastInRoomBannerMessage>, I>>(object: I): WebcastInRoomBannerMessage {
    const message = createBaseWebcastInRoomBannerMessage();
    message.data = object.data ?? "";
    return message;
  },
};

function createBaseRankItem(): RankItem {
  return { colour: "", id: "0" };
}

export const RankItem: MessageFns<RankItem> = {
  encode(message: RankItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.colour !== "") {
      writer.uint32(10).string(message.colour);
    }
    if (message.id !== "0") {
      writer.uint32(32).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RankItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRankItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.colour = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.id = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RankItem {
    return {
      colour: isSet(object.colour) ? globalThis.String(object.colour) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "0",
    };
  },

  toJSON(message: RankItem): unknown {
    const obj: any = {};
    if (message.colour !== "") {
      obj.colour = message.colour;
    }
    if (message.id !== "0") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RankItem>, I>>(base?: I): RankItem {
    return RankItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RankItem>, I>>(object: I): RankItem {
    const message = createBaseRankItem();
    message.colour = object.colour ?? "";
    message.id = object.id ?? "0";
    return message;
  },
};

function createBaseWeeklyRanking(): WeeklyRanking {
  return { type: "", label: "", rank: undefined };
}

export const WeeklyRanking: MessageFns<WeeklyRanking> = {
  encode(message: WeeklyRanking, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.rank !== undefined) {
      RankItem.encode(message.rank, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WeeklyRanking {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWeeklyRanking();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rank = RankItem.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WeeklyRanking {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      rank: isSet(object.rank) ? RankItem.fromJSON(object.rank) : undefined,
    };
  },

  toJSON(message: WeeklyRanking): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.rank !== undefined) {
      obj.rank = RankItem.toJSON(message.rank);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WeeklyRanking>, I>>(base?: I): WeeklyRanking {
    return WeeklyRanking.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WeeklyRanking>, I>>(object: I): WeeklyRanking {
    const message = createBaseWeeklyRanking();
    message.type = object.type ?? "";
    message.label = object.label ?? "";
    message.rank = (object.rank !== undefined && object.rank !== null) ? RankItem.fromPartial(object.rank) : undefined;
    return message;
  },
};

function createBaseRankContainer(): RankContainer {
  return { rankings: undefined };
}

export const RankContainer: MessageFns<RankContainer> = {
  encode(message: RankContainer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rankings !== undefined) {
      WeeklyRanking.encode(message.rankings, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RankContainer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRankContainer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rankings = WeeklyRanking.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RankContainer {
    return { rankings: isSet(object.rankings) ? WeeklyRanking.fromJSON(object.rankings) : undefined };
  },

  toJSON(message: RankContainer): unknown {
    const obj: any = {};
    if (message.rankings !== undefined) {
      obj.rankings = WeeklyRanking.toJSON(message.rankings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RankContainer>, I>>(base?: I): RankContainer {
    return RankContainer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RankContainer>, I>>(object: I): RankContainer {
    const message = createBaseRankContainer();
    message.rankings = (object.rankings !== undefined && object.rankings !== null)
      ? WeeklyRanking.fromPartial(object.rankings)
      : undefined;
    return message;
  },
};

function createBaseWebcastHourlyRankMessage(): WebcastHourlyRankMessage {
  return { data: undefined };
}

export const WebcastHourlyRankMessage: MessageFns<WebcastHourlyRankMessage> = {
  encode(message: WebcastHourlyRankMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      RankContainer.encode(message.data, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastHourlyRankMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastHourlyRankMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = RankContainer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastHourlyRankMessage {
    return { data: isSet(object.data) ? RankContainer.fromJSON(object.data) : undefined };
  },

  toJSON(message: WebcastHourlyRankMessage): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = RankContainer.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastHourlyRankMessage>, I>>(base?: I): WebcastHourlyRankMessage {
    return WebcastHourlyRankMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastHourlyRankMessage>, I>>(object: I): WebcastHourlyRankMessage {
    const message = createBaseWebcastHourlyRankMessage();
    message.data = (object.data !== undefined && object.data !== null)
      ? RankContainer.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function createBaseEmoteDetails(): EmoteDetails {
  return { emoteId: "", image: undefined };
}

export const EmoteDetails: MessageFns<EmoteDetails> = {
  encode(message: EmoteDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.emoteId !== "") {
      writer.uint32(10).string(message.emoteId);
    }
    if (message.image !== undefined) {
      EmoteImage.encode(message.image, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmoteDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmoteDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.emoteId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.image = EmoteImage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmoteDetails {
    return {
      emoteId: isSet(object.emoteId) ? globalThis.String(object.emoteId) : "",
      image: isSet(object.image) ? EmoteImage.fromJSON(object.image) : undefined,
    };
  },

  toJSON(message: EmoteDetails): unknown {
    const obj: any = {};
    if (message.emoteId !== "") {
      obj.emoteId = message.emoteId;
    }
    if (message.image !== undefined) {
      obj.image = EmoteImage.toJSON(message.image);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmoteDetails>, I>>(base?: I): EmoteDetails {
    return EmoteDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmoteDetails>, I>>(object: I): EmoteDetails {
    const message = createBaseEmoteDetails();
    message.emoteId = object.emoteId ?? "";
    message.image = (object.image !== undefined && object.image !== null)
      ? EmoteImage.fromPartial(object.image)
      : undefined;
    return message;
  },
};

function createBaseEmoteImage(): EmoteImage {
  return { imageUrl: "" };
}

export const EmoteImage: MessageFns<EmoteImage> = {
  encode(message: EmoteImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageUrl !== "") {
      writer.uint32(10).string(message.imageUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmoteImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmoteImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmoteImage {
    return { imageUrl: isSet(object.imageUrl) ? globalThis.String(object.imageUrl) : "" };
  },

  toJSON(message: EmoteImage): unknown {
    const obj: any = {};
    if (message.imageUrl !== "") {
      obj.imageUrl = message.imageUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmoteImage>, I>>(base?: I): EmoteImage {
    return EmoteImage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmoteImage>, I>>(object: I): EmoteImage {
    const message = createBaseEmoteImage();
    message.imageUrl = object.imageUrl ?? "";
    return message;
  },
};

function createBaseWebcastEnvelopeMessage(): WebcastEnvelopeMessage {
  return { treasureBoxData: undefined, treasureBoxUser: undefined };
}

export const WebcastEnvelopeMessage: MessageFns<WebcastEnvelopeMessage> = {
  encode(message: WebcastEnvelopeMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.treasureBoxData !== undefined) {
      TreasureBoxData.encode(message.treasureBoxData, writer.uint32(18).fork()).join();
    }
    if (message.treasureBoxUser !== undefined) {
      TreasureBoxUser.encode(message.treasureBoxUser, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastEnvelopeMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastEnvelopeMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.treasureBoxData = TreasureBoxData.decode(reader, reader.uint32());
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.treasureBoxUser = TreasureBoxUser.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastEnvelopeMessage {
    return {
      treasureBoxData: isSet(object.treasureBoxData) ? TreasureBoxData.fromJSON(object.treasureBoxData) : undefined,
      treasureBoxUser: isSet(object.treasureBoxUser) ? TreasureBoxUser.fromJSON(object.treasureBoxUser) : undefined,
    };
  },

  toJSON(message: WebcastEnvelopeMessage): unknown {
    const obj: any = {};
    if (message.treasureBoxData !== undefined) {
      obj.treasureBoxData = TreasureBoxData.toJSON(message.treasureBoxData);
    }
    if (message.treasureBoxUser !== undefined) {
      obj.treasureBoxUser = TreasureBoxUser.toJSON(message.treasureBoxUser);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastEnvelopeMessage>, I>>(base?: I): WebcastEnvelopeMessage {
    return WebcastEnvelopeMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastEnvelopeMessage>, I>>(object: I): WebcastEnvelopeMessage {
    const message = createBaseWebcastEnvelopeMessage();
    message.treasureBoxData = (object.treasureBoxData !== undefined && object.treasureBoxData !== null)
      ? TreasureBoxData.fromPartial(object.treasureBoxData)
      : undefined;
    message.treasureBoxUser = (object.treasureBoxUser !== undefined && object.treasureBoxUser !== null)
      ? TreasureBoxUser.fromPartial(object.treasureBoxUser)
      : undefined;
    return message;
  },
};

function createBaseTreasureBoxUser(): TreasureBoxUser {
  return { user2: undefined };
}

export const TreasureBoxUser: MessageFns<TreasureBoxUser> = {
  encode(message: TreasureBoxUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user2 !== undefined) {
      TreasureBoxUser2.encode(message.user2, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreasureBoxUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreasureBoxUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.user2 = TreasureBoxUser2.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreasureBoxUser {
    return { user2: isSet(object.user2) ? TreasureBoxUser2.fromJSON(object.user2) : undefined };
  },

  toJSON(message: TreasureBoxUser): unknown {
    const obj: any = {};
    if (message.user2 !== undefined) {
      obj.user2 = TreasureBoxUser2.toJSON(message.user2);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TreasureBoxUser>, I>>(base?: I): TreasureBoxUser {
    return TreasureBoxUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TreasureBoxUser>, I>>(object: I): TreasureBoxUser {
    const message = createBaseTreasureBoxUser();
    message.user2 = (object.user2 !== undefined && object.user2 !== null)
      ? TreasureBoxUser2.fromPartial(object.user2)
      : undefined;
    return message;
  },
};

function createBaseTreasureBoxUser2(): TreasureBoxUser2 {
  return { user3: [] };
}

export const TreasureBoxUser2: MessageFns<TreasureBoxUser2> = {
  encode(message: TreasureBoxUser2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.user3) {
      TreasureBoxUser3.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreasureBoxUser2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreasureBoxUser2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.user3.push(TreasureBoxUser3.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreasureBoxUser2 {
    return {
      user3: globalThis.Array.isArray(object?.user3) ? object.user3.map((e: any) => TreasureBoxUser3.fromJSON(e)) : [],
    };
  },

  toJSON(message: TreasureBoxUser2): unknown {
    const obj: any = {};
    if (message.user3?.length) {
      obj.user3 = message.user3.map((e) => TreasureBoxUser3.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TreasureBoxUser2>, I>>(base?: I): TreasureBoxUser2 {
    return TreasureBoxUser2.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TreasureBoxUser2>, I>>(object: I): TreasureBoxUser2 {
    const message = createBaseTreasureBoxUser2();
    message.user3 = object.user3?.map((e) => TreasureBoxUser3.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTreasureBoxUser3(): TreasureBoxUser3 {
  return { user4: undefined };
}

export const TreasureBoxUser3: MessageFns<TreasureBoxUser3> = {
  encode(message: TreasureBoxUser3, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user4 !== undefined) {
      TreasureBoxUser4.encode(message.user4, writer.uint32(170).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreasureBoxUser3 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreasureBoxUser3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.user4 = TreasureBoxUser4.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreasureBoxUser3 {
    return { user4: isSet(object.user4) ? TreasureBoxUser4.fromJSON(object.user4) : undefined };
  },

  toJSON(message: TreasureBoxUser3): unknown {
    const obj: any = {};
    if (message.user4 !== undefined) {
      obj.user4 = TreasureBoxUser4.toJSON(message.user4);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TreasureBoxUser3>, I>>(base?: I): TreasureBoxUser3 {
    return TreasureBoxUser3.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TreasureBoxUser3>, I>>(object: I): TreasureBoxUser3 {
    const message = createBaseTreasureBoxUser3();
    message.user4 = (object.user4 !== undefined && object.user4 !== null)
      ? TreasureBoxUser4.fromPartial(object.user4)
      : undefined;
    return message;
  },
};

function createBaseTreasureBoxUser4(): TreasureBoxUser4 {
  return { user: undefined };
}

export const TreasureBoxUser4: MessageFns<TreasureBoxUser4> = {
  encode(message: TreasureBoxUser4, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreasureBoxUser4 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreasureBoxUser4();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreasureBoxUser4 {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  },

  toJSON(message: TreasureBoxUser4): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TreasureBoxUser4>, I>>(base?: I): TreasureBoxUser4 {
    return TreasureBoxUser4.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TreasureBoxUser4>, I>>(object: I): TreasureBoxUser4 {
    const message = createBaseTreasureBoxUser4();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseTreasureBoxData(): TreasureBoxData {
  return { coins: 0, canOpen: 0, timestamp: "0" };
}

export const TreasureBoxData: MessageFns<TreasureBoxData> = {
  encode(message: TreasureBoxData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coins !== 0) {
      writer.uint32(40).uint32(message.coins);
    }
    if (message.canOpen !== 0) {
      writer.uint32(48).uint32(message.canOpen);
    }
    if (message.timestamp !== "0") {
      writer.uint32(56).uint64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreasureBoxData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreasureBoxData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.coins = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.canOpen = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.timestamp = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreasureBoxData {
    return {
      coins: isSet(object.coins) ? globalThis.Number(object.coins) : 0,
      canOpen: isSet(object.canOpen) ? globalThis.Number(object.canOpen) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "0",
    };
  },

  toJSON(message: TreasureBoxData): unknown {
    const obj: any = {};
    if (message.coins !== 0) {
      obj.coins = Math.round(message.coins);
    }
    if (message.canOpen !== 0) {
      obj.canOpen = Math.round(message.canOpen);
    }
    if (message.timestamp !== "0") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TreasureBoxData>, I>>(base?: I): TreasureBoxData {
    return TreasureBoxData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TreasureBoxData>, I>>(object: I): TreasureBoxData {
    const message = createBaseTreasureBoxData();
    message.coins = object.coins ?? 0;
    message.canOpen = object.canOpen ?? 0;
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseWebcastSubNotifyMessage(): WebcastSubNotifyMessage {
  return {
    event: undefined,
    user: undefined,
    exhibitionType: 0,
    subMonth: 0,
    subscribeType: 0,
    oldSubscribeStatus: 0,
    subscribingStatus: 0,
  };
}

export const WebcastSubNotifyMessage: MessageFns<WebcastSubNotifyMessage> = {
  encode(message: WebcastSubNotifyMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== undefined) {
      WebcastMessageEvent.encode(message.event, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.exhibitionType !== 0) {
      writer.uint32(24).int32(message.exhibitionType);
    }
    if (message.subMonth !== 0) {
      writer.uint32(32).int32(message.subMonth);
    }
    if (message.subscribeType !== 0) {
      writer.uint32(40).int32(message.subscribeType);
    }
    if (message.oldSubscribeStatus !== 0) {
      writer.uint32(48).int32(message.oldSubscribeStatus);
    }
    if (message.subscribingStatus !== 0) {
      writer.uint32(64).int32(message.subscribingStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastSubNotifyMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastSubNotifyMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = WebcastMessageEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.exhibitionType = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.subMonth = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.subscribeType = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.oldSubscribeStatus = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.subscribingStatus = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastSubNotifyMessage {
    return {
      event: isSet(object.event) ? WebcastMessageEvent.fromJSON(object.event) : undefined,
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      exhibitionType: isSet(object.exhibitionType) ? globalThis.Number(object.exhibitionType) : 0,
      subMonth: isSet(object.subMonth) ? globalThis.Number(object.subMonth) : 0,
      subscribeType: isSet(object.subscribeType) ? globalThis.Number(object.subscribeType) : 0,
      oldSubscribeStatus: isSet(object.oldSubscribeStatus) ? globalThis.Number(object.oldSubscribeStatus) : 0,
      subscribingStatus: isSet(object.subscribingStatus) ? globalThis.Number(object.subscribingStatus) : 0,
    };
  },

  toJSON(message: WebcastSubNotifyMessage): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = WebcastMessageEvent.toJSON(message.event);
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.exhibitionType !== 0) {
      obj.exhibitionType = Math.round(message.exhibitionType);
    }
    if (message.subMonth !== 0) {
      obj.subMonth = Math.round(message.subMonth);
    }
    if (message.subscribeType !== 0) {
      obj.subscribeType = Math.round(message.subscribeType);
    }
    if (message.oldSubscribeStatus !== 0) {
      obj.oldSubscribeStatus = Math.round(message.oldSubscribeStatus);
    }
    if (message.subscribingStatus !== 0) {
      obj.subscribingStatus = Math.round(message.subscribingStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastSubNotifyMessage>, I>>(base?: I): WebcastSubNotifyMessage {
    return WebcastSubNotifyMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastSubNotifyMessage>, I>>(object: I): WebcastSubNotifyMessage {
    const message = createBaseWebcastSubNotifyMessage();
    message.event = (object.event !== undefined && object.event !== null)
      ? WebcastMessageEvent.fromPartial(object.event)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.exhibitionType = object.exhibitionType ?? 0;
    message.subMonth = object.subMonth ?? 0;
    message.subscribeType = object.subscribeType ?? 0;
    message.oldSubscribeStatus = object.oldSubscribeStatus ?? 0;
    message.subscribingStatus = object.subscribingStatus ?? 0;
    return message;
  },
};

function createBaseUser(): User {
  return {
    userId: "0",
    nickname: "",
    profilePicture: undefined,
    uniqueId: "",
    secUid: "",
    badges: [],
    createTime: "0",
    bioDescription: "",
    followInfo: undefined,
  };
}

export const User: MessageFns<User> = {
  encode(message: User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.nickname !== "") {
      writer.uint32(26).string(message.nickname);
    }
    if (message.profilePicture !== undefined) {
      ProfilePicture.encode(message.profilePicture, writer.uint32(74).fork()).join();
    }
    if (message.uniqueId !== "") {
      writer.uint32(306).string(message.uniqueId);
    }
    if (message.secUid !== "") {
      writer.uint32(370).string(message.secUid);
    }
    for (const v of message.badges) {
      UserBadgesAttributes.encode(v!, writer.uint32(514).fork()).join();
    }
    if (message.createTime !== "0") {
      writer.uint32(128).uint64(message.createTime);
    }
    if (message.bioDescription !== "") {
      writer.uint32(42).string(message.bioDescription);
    }
    if (message.followInfo !== undefined) {
      FollowInfo.encode(message.followInfo, writer.uint32(178).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.profilePicture = ProfilePicture.decode(reader, reader.uint32());
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.uniqueId = reader.string();
          continue;
        }
        case 46: {
          if (tag !== 370) {
            break;
          }

          message.secUid = reader.string();
          continue;
        }
        case 64: {
          if (tag !== 514) {
            break;
          }

          message.badges.push(UserBadgesAttributes.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.createTime = reader.uint64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bioDescription = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.followInfo = FollowInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "0",
      nickname: isSet(object.nickname) ? globalThis.String(object.nickname) : "",
      profilePicture: isSet(object.profilePicture) ? ProfilePicture.fromJSON(object.profilePicture) : undefined,
      uniqueId: isSet(object.uniqueId) ? globalThis.String(object.uniqueId) : "",
      secUid: isSet(object.secUid) ? globalThis.String(object.secUid) : "",
      badges: globalThis.Array.isArray(object?.badges)
        ? object.badges.map((e: any) => UserBadgesAttributes.fromJSON(e))
        : [],
      createTime: isSet(object.createTime) ? globalThis.String(object.createTime) : "0",
      bioDescription: isSet(object.bioDescription) ? globalThis.String(object.bioDescription) : "",
      followInfo: isSet(object.followInfo) ? FollowInfo.fromJSON(object.followInfo) : undefined,
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.userId !== "0") {
      obj.userId = message.userId;
    }
    if (message.nickname !== "") {
      obj.nickname = message.nickname;
    }
    if (message.profilePicture !== undefined) {
      obj.profilePicture = ProfilePicture.toJSON(message.profilePicture);
    }
    if (message.uniqueId !== "") {
      obj.uniqueId = message.uniqueId;
    }
    if (message.secUid !== "") {
      obj.secUid = message.secUid;
    }
    if (message.badges?.length) {
      obj.badges = message.badges.map((e) => UserBadgesAttributes.toJSON(e));
    }
    if (message.createTime !== "0") {
      obj.createTime = message.createTime;
    }
    if (message.bioDescription !== "") {
      obj.bioDescription = message.bioDescription;
    }
    if (message.followInfo !== undefined) {
      obj.followInfo = FollowInfo.toJSON(message.followInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.userId = object.userId ?? "0";
    message.nickname = object.nickname ?? "";
    message.profilePicture = (object.profilePicture !== undefined && object.profilePicture !== null)
      ? ProfilePicture.fromPartial(object.profilePicture)
      : undefined;
    message.uniqueId = object.uniqueId ?? "";
    message.secUid = object.secUid ?? "";
    message.badges = object.badges?.map((e) => UserBadgesAttributes.fromPartial(e)) || [];
    message.createTime = object.createTime ?? "0";
    message.bioDescription = object.bioDescription ?? "";
    message.followInfo = (object.followInfo !== undefined && object.followInfo !== null)
      ? FollowInfo.fromPartial(object.followInfo)
      : undefined;
    return message;
  },
};

function createBaseFollowInfo(): FollowInfo {
  return { followingCount: 0, followerCount: 0, followStatus: 0, pushStatus: 0 };
}

export const FollowInfo: MessageFns<FollowInfo> = {
  encode(message: FollowInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.followingCount !== 0) {
      writer.uint32(8).int32(message.followingCount);
    }
    if (message.followerCount !== 0) {
      writer.uint32(16).int32(message.followerCount);
    }
    if (message.followStatus !== 0) {
      writer.uint32(24).int32(message.followStatus);
    }
    if (message.pushStatus !== 0) {
      writer.uint32(32).int32(message.pushStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FollowInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFollowInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.followingCount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.followerCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.followStatus = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pushStatus = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FollowInfo {
    return {
      followingCount: isSet(object.followingCount) ? globalThis.Number(object.followingCount) : 0,
      followerCount: isSet(object.followerCount) ? globalThis.Number(object.followerCount) : 0,
      followStatus: isSet(object.followStatus) ? globalThis.Number(object.followStatus) : 0,
      pushStatus: isSet(object.pushStatus) ? globalThis.Number(object.pushStatus) : 0,
    };
  },

  toJSON(message: FollowInfo): unknown {
    const obj: any = {};
    if (message.followingCount !== 0) {
      obj.followingCount = Math.round(message.followingCount);
    }
    if (message.followerCount !== 0) {
      obj.followerCount = Math.round(message.followerCount);
    }
    if (message.followStatus !== 0) {
      obj.followStatus = Math.round(message.followStatus);
    }
    if (message.pushStatus !== 0) {
      obj.pushStatus = Math.round(message.pushStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FollowInfo>, I>>(base?: I): FollowInfo {
    return FollowInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FollowInfo>, I>>(object: I): FollowInfo {
    const message = createBaseFollowInfo();
    message.followingCount = object.followingCount ?? 0;
    message.followerCount = object.followerCount ?? 0;
    message.followStatus = object.followStatus ?? 0;
    message.pushStatus = object.pushStatus ?? 0;
    return message;
  },
};

function createBaseLinkUser(): LinkUser {
  return { userId: "0", nickname: "", profilePicture: undefined, uniqueId: "" };
}

export const LinkUser: MessageFns<LinkUser> = {
  encode(message: LinkUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.nickname !== "") {
      writer.uint32(18).string(message.nickname);
    }
    if (message.profilePicture !== undefined) {
      ProfilePicture.encode(message.profilePicture, writer.uint32(26).fork()).join();
    }
    if (message.uniqueId !== "") {
      writer.uint32(34).string(message.uniqueId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.profilePicture = ProfilePicture.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.uniqueId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinkUser {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "0",
      nickname: isSet(object.nickname) ? globalThis.String(object.nickname) : "",
      profilePicture: isSet(object.profilePicture) ? ProfilePicture.fromJSON(object.profilePicture) : undefined,
      uniqueId: isSet(object.uniqueId) ? globalThis.String(object.uniqueId) : "",
    };
  },

  toJSON(message: LinkUser): unknown {
    const obj: any = {};
    if (message.userId !== "0") {
      obj.userId = message.userId;
    }
    if (message.nickname !== "") {
      obj.nickname = message.nickname;
    }
    if (message.profilePicture !== undefined) {
      obj.profilePicture = ProfilePicture.toJSON(message.profilePicture);
    }
    if (message.uniqueId !== "") {
      obj.uniqueId = message.uniqueId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LinkUser>, I>>(base?: I): LinkUser {
    return LinkUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkUser>, I>>(object: I): LinkUser {
    const message = createBaseLinkUser();
    message.userId = object.userId ?? "0";
    message.nickname = object.nickname ?? "";
    message.profilePicture = (object.profilePicture !== undefined && object.profilePicture !== null)
      ? ProfilePicture.fromPartial(object.profilePicture)
      : undefined;
    message.uniqueId = object.uniqueId ?? "";
    return message;
  },
};

function createBaseProfilePicture(): ProfilePicture {
  return { urls: [] };
}

export const ProfilePicture: MessageFns<ProfilePicture> = {
  encode(message: ProfilePicture, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.urls) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProfilePicture {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProfilePicture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.urls.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProfilePicture {
    return { urls: globalThis.Array.isArray(object?.urls) ? object.urls.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: ProfilePicture): unknown {
    const obj: any = {};
    if (message.urls?.length) {
      obj.urls = message.urls;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProfilePicture>, I>>(base?: I): ProfilePicture {
    return ProfilePicture.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProfilePicture>, I>>(object: I): ProfilePicture {
    const message = createBaseProfilePicture();
    message.urls = object.urls?.map((e) => e) || [];
    return message;
  },
};

function createBaseUserBadgesAttributes(): UserBadgesAttributes {
  return { badgeSceneType: 0, imageBadges: [], badges: [], privilegeLogExtra: undefined };
}

export const UserBadgesAttributes: MessageFns<UserBadgesAttributes> = {
  encode(message: UserBadgesAttributes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.badgeSceneType !== 0) {
      writer.uint32(24).int32(message.badgeSceneType);
    }
    for (const v of message.imageBadges) {
      UserImageBadge.encode(v!, writer.uint32(162).fork()).join();
    }
    for (const v of message.badges) {
      UserBadge.encode(v!, writer.uint32(170).fork()).join();
    }
    if (message.privilegeLogExtra !== undefined) {
      PrivilegeLogExtra.encode(message.privilegeLogExtra, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserBadgesAttributes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserBadgesAttributes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.badgeSceneType = reader.int32();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.imageBadges.push(UserImageBadge.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.badges.push(UserBadge.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.privilegeLogExtra = PrivilegeLogExtra.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserBadgesAttributes {
    return {
      badgeSceneType: isSet(object.badgeSceneType) ? globalThis.Number(object.badgeSceneType) : 0,
      imageBadges: globalThis.Array.isArray(object?.imageBadges)
        ? object.imageBadges.map((e: any) => UserImageBadge.fromJSON(e))
        : [],
      badges: globalThis.Array.isArray(object?.badges) ? object.badges.map((e: any) => UserBadge.fromJSON(e)) : [],
      privilegeLogExtra: isSet(object.privilegeLogExtra)
        ? PrivilegeLogExtra.fromJSON(object.privilegeLogExtra)
        : undefined,
    };
  },

  toJSON(message: UserBadgesAttributes): unknown {
    const obj: any = {};
    if (message.badgeSceneType !== 0) {
      obj.badgeSceneType = Math.round(message.badgeSceneType);
    }
    if (message.imageBadges?.length) {
      obj.imageBadges = message.imageBadges.map((e) => UserImageBadge.toJSON(e));
    }
    if (message.badges?.length) {
      obj.badges = message.badges.map((e) => UserBadge.toJSON(e));
    }
    if (message.privilegeLogExtra !== undefined) {
      obj.privilegeLogExtra = PrivilegeLogExtra.toJSON(message.privilegeLogExtra);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserBadgesAttributes>, I>>(base?: I): UserBadgesAttributes {
    return UserBadgesAttributes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserBadgesAttributes>, I>>(object: I): UserBadgesAttributes {
    const message = createBaseUserBadgesAttributes();
    message.badgeSceneType = object.badgeSceneType ?? 0;
    message.imageBadges = object.imageBadges?.map((e) => UserImageBadge.fromPartial(e)) || [];
    message.badges = object.badges?.map((e) => UserBadge.fromPartial(e)) || [];
    message.privilegeLogExtra = (object.privilegeLogExtra !== undefined && object.privilegeLogExtra !== null)
      ? PrivilegeLogExtra.fromPartial(object.privilegeLogExtra)
      : undefined;
    return message;
  },
};

function createBasePrivilegeLogExtra(): PrivilegeLogExtra {
  return { privilegeId: "", level: "" };
}

export const PrivilegeLogExtra: MessageFns<PrivilegeLogExtra> = {
  encode(message: PrivilegeLogExtra, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.privilegeId !== "") {
      writer.uint32(18).string(message.privilegeId);
    }
    if (message.level !== "") {
      writer.uint32(42).string(message.level);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivilegeLogExtra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivilegeLogExtra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.privilegeId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.level = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrivilegeLogExtra {
    return {
      privilegeId: isSet(object.privilegeId) ? globalThis.String(object.privilegeId) : "",
      level: isSet(object.level) ? globalThis.String(object.level) : "",
    };
  },

  toJSON(message: PrivilegeLogExtra): unknown {
    const obj: any = {};
    if (message.privilegeId !== "") {
      obj.privilegeId = message.privilegeId;
    }
    if (message.level !== "") {
      obj.level = message.level;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PrivilegeLogExtra>, I>>(base?: I): PrivilegeLogExtra {
    return PrivilegeLogExtra.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrivilegeLogExtra>, I>>(object: I): PrivilegeLogExtra {
    const message = createBasePrivilegeLogExtra();
    message.privilegeId = object.privilegeId ?? "";
    message.level = object.level ?? "";
    return message;
  },
};

function createBaseUserBadge(): UserBadge {
  return { type: "", name: "" };
}

export const UserBadge: MessageFns<UserBadge> = {
  encode(message: UserBadge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserBadge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserBadge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserBadge {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: UserBadge): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserBadge>, I>>(base?: I): UserBadge {
    return UserBadge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserBadge>, I>>(object: I): UserBadge {
    const message = createBaseUserBadge();
    message.type = object.type ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUserImageBadge(): UserImageBadge {
  return { displayType: 0, image: undefined };
}

export const UserImageBadge: MessageFns<UserImageBadge> = {
  encode(message: UserImageBadge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayType !== 0) {
      writer.uint32(8).int32(message.displayType);
    }
    if (message.image !== undefined) {
      UserImageBadgeImage.encode(message.image, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserImageBadge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserImageBadge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.displayType = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.image = UserImageBadgeImage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserImageBadge {
    return {
      displayType: isSet(object.displayType) ? globalThis.Number(object.displayType) : 0,
      image: isSet(object.image) ? UserImageBadgeImage.fromJSON(object.image) : undefined,
    };
  },

  toJSON(message: UserImageBadge): unknown {
    const obj: any = {};
    if (message.displayType !== 0) {
      obj.displayType = Math.round(message.displayType);
    }
    if (message.image !== undefined) {
      obj.image = UserImageBadgeImage.toJSON(message.image);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserImageBadge>, I>>(base?: I): UserImageBadge {
    return UserImageBadge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserImageBadge>, I>>(object: I): UserImageBadge {
    const message = createBaseUserImageBadge();
    message.displayType = object.displayType ?? 0;
    message.image = (object.image !== undefined && object.image !== null)
      ? UserImageBadgeImage.fromPartial(object.image)
      : undefined;
    return message;
  },
};

function createBaseUserImageBadgeImage(): UserImageBadgeImage {
  return { url: "" };
}

export const UserImageBadgeImage: MessageFns<UserImageBadgeImage> = {
  encode(message: UserImageBadgeImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserImageBadgeImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserImageBadgeImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserImageBadgeImage {
    return { url: isSet(object.url) ? globalThis.String(object.url) : "" };
  },

  toJSON(message: UserImageBadgeImage): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserImageBadgeImage>, I>>(base?: I): UserImageBadgeImage {
    return UserImageBadgeImage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserImageBadgeImage>, I>>(object: I): UserImageBadgeImage {
    const message = createBaseUserImageBadgeImage();
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseWebcastWebsocketMessage(): WebcastWebsocketMessage {
  return { id: "0", type: "", binary: new Uint8Array(0) };
}

export const WebcastWebsocketMessage: MessageFns<WebcastWebsocketMessage> = {
  encode(message: WebcastWebsocketMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(16).uint64(message.id);
    }
    if (message.type !== "") {
      writer.uint32(58).string(message.type);
    }
    if (message.binary.length !== 0) {
      writer.uint32(66).bytes(message.binary);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastWebsocketMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastWebsocketMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.uint64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.binary = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastWebsocketMessage {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "0",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      binary: isSet(object.binary) ? bytesFromBase64(object.binary) : new Uint8Array(0),
    };
  },

  toJSON(message: WebcastWebsocketMessage): unknown {
    const obj: any = {};
    if (message.id !== "0") {
      obj.id = message.id;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.binary.length !== 0) {
      obj.binary = base64FromBytes(message.binary);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastWebsocketMessage>, I>>(base?: I): WebcastWebsocketMessage {
    return WebcastWebsocketMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastWebsocketMessage>, I>>(object: I): WebcastWebsocketMessage {
    const message = createBaseWebcastWebsocketMessage();
    message.id = object.id ?? "0";
    message.type = object.type ?? "";
    message.binary = object.binary ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWebcastWebsocketAck(): WebcastWebsocketAck {
  return { id: "0", type: "" };
}

export const WebcastWebsocketAck: MessageFns<WebcastWebsocketAck> = {
  encode(message: WebcastWebsocketAck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(16).uint64(message.id);
    }
    if (message.type !== "") {
      writer.uint32(58).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastWebsocketAck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastWebsocketAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.uint64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.type = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastWebsocketAck {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "0",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: WebcastWebsocketAck): unknown {
    const obj: any = {};
    if (message.id !== "0") {
      obj.id = message.id;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastWebsocketAck>, I>>(base?: I): WebcastWebsocketAck {
    return WebcastWebsocketAck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastWebsocketAck>, I>>(object: I): WebcastWebsocketAck {
    const message = createBaseWebcastWebsocketAck();
    message.id = object.id ?? "0";
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseHeartbeatFrameRoomInfo(): HeartbeatFrameRoomInfo {
  return { roomId: "0" };
}

export const HeartbeatFrameRoomInfo: MessageFns<HeartbeatFrameRoomInfo> = {
  encode(message: HeartbeatFrameRoomInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== "0") {
      writer.uint32(8).uint64(message.roomId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartbeatFrameRoomInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatFrameRoomInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.roomId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeartbeatFrameRoomInfo {
    return { roomId: isSet(object.roomId) ? globalThis.String(object.roomId) : "0" };
  },

  toJSON(message: HeartbeatFrameRoomInfo): unknown {
    const obj: any = {};
    if (message.roomId !== "0") {
      obj.roomId = message.roomId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeartbeatFrameRoomInfo>, I>>(base?: I): HeartbeatFrameRoomInfo {
    return HeartbeatFrameRoomInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeartbeatFrameRoomInfo>, I>>(object: I): HeartbeatFrameRoomInfo {
    const message = createBaseHeartbeatFrameRoomInfo();
    message.roomId = object.roomId ?? "0";
    return message;
  },
};

function createBaseHeartbeatFrameMetadataField6(): HeartbeatFrameMetadataField6 {
  return { unknown1: 0 };
}

export const HeartbeatFrameMetadataField6: MessageFns<HeartbeatFrameMetadataField6> = {
  encode(message: HeartbeatFrameMetadataField6, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unknown1 !== 0) {
      writer.uint32(112).uint32(message.unknown1);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartbeatFrameMetadataField6 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatFrameMetadataField6();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.unknown1 = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeartbeatFrameMetadataField6 {
    return { unknown1: isSet(object.unknown1) ? globalThis.Number(object.unknown1) : 0 };
  },

  toJSON(message: HeartbeatFrameMetadataField6): unknown {
    const obj: any = {};
    if (message.unknown1 !== 0) {
      obj.unknown1 = Math.round(message.unknown1);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeartbeatFrameMetadataField6>, I>>(base?: I): HeartbeatFrameMetadataField6 {
    return HeartbeatFrameMetadataField6.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeartbeatFrameMetadataField6>, I>>(object: I): HeartbeatFrameMetadataField6 {
    const message = createBaseHeartbeatFrameMetadataField6();
    message.unknown1 = object.unknown1 ?? 0;
    return message;
  },
};

function createBaseHeartbeatFrameMetadataField7(): HeartbeatFrameMetadataField7 {
  return { unknown1: 0 };
}

export const HeartbeatFrameMetadataField7: MessageFns<HeartbeatFrameMetadataField7> = {
  encode(message: HeartbeatFrameMetadataField7, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unknown1 !== 0) {
      writer.uint32(104).uint32(message.unknown1);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartbeatFrameMetadataField7 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatFrameMetadataField7();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.unknown1 = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeartbeatFrameMetadataField7 {
    return { unknown1: isSet(object.unknown1) ? globalThis.Number(object.unknown1) : 0 };
  },

  toJSON(message: HeartbeatFrameMetadataField7): unknown {
    const obj: any = {};
    if (message.unknown1 !== 0) {
      obj.unknown1 = Math.round(message.unknown1);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeartbeatFrameMetadataField7>, I>>(base?: I): HeartbeatFrameMetadataField7 {
    return HeartbeatFrameMetadataField7.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeartbeatFrameMetadataField7>, I>>(object: I): HeartbeatFrameMetadataField7 {
    const message = createBaseHeartbeatFrameMetadataField7();
    message.unknown1 = object.unknown1 ?? 0;
    return message;
  },
};

function createBaseHeartbeatFrame(): HeartbeatFrame {
  return { metadataField6: undefined, metadataField7: undefined, roomInfo: undefined };
}

export const HeartbeatFrame: MessageFns<HeartbeatFrame> = {
  encode(message: HeartbeatFrame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadataField6 !== undefined) {
      HeartbeatFrameMetadataField6.encode(message.metadataField6, writer.uint32(50).fork()).join();
    }
    if (message.metadataField7 !== undefined) {
      HeartbeatFrameMetadataField7.encode(message.metadataField7, writer.uint32(58).fork()).join();
    }
    if (message.roomInfo !== undefined) {
      HeartbeatFrameRoomInfo.encode(message.roomInfo, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartbeatFrame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadataField6 = HeartbeatFrameMetadataField6.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.metadataField7 = HeartbeatFrameMetadataField7.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.roomInfo = HeartbeatFrameRoomInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeartbeatFrame {
    return {
      metadataField6: isSet(object.metadataField6)
        ? HeartbeatFrameMetadataField6.fromJSON(object.metadataField6)
        : undefined,
      metadataField7: isSet(object.metadataField7)
        ? HeartbeatFrameMetadataField7.fromJSON(object.metadataField7)
        : undefined,
      roomInfo: isSet(object.roomInfo) ? HeartbeatFrameRoomInfo.fromJSON(object.roomInfo) : undefined,
    };
  },

  toJSON(message: HeartbeatFrame): unknown {
    const obj: any = {};
    if (message.metadataField6 !== undefined) {
      obj.metadataField6 = HeartbeatFrameMetadataField6.toJSON(message.metadataField6);
    }
    if (message.metadataField7 !== undefined) {
      obj.metadataField7 = HeartbeatFrameMetadataField7.toJSON(message.metadataField7);
    }
    if (message.roomInfo !== undefined) {
      obj.roomInfo = HeartbeatFrameRoomInfo.toJSON(message.roomInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeartbeatFrame>, I>>(base?: I): HeartbeatFrame {
    return HeartbeatFrame.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeartbeatFrame>, I>>(object: I): HeartbeatFrame {
    const message = createBaseHeartbeatFrame();
    message.metadataField6 = (object.metadataField6 !== undefined && object.metadataField6 !== null)
      ? HeartbeatFrameMetadataField6.fromPartial(object.metadataField6)
      : undefined;
    message.metadataField7 = (object.metadataField7 !== undefined && object.metadataField7 !== null)
      ? HeartbeatFrameMetadataField7.fromPartial(object.metadataField7)
      : undefined;
    message.roomInfo = (object.roomInfo !== undefined && object.roomInfo !== null)
      ? HeartbeatFrameRoomInfo.fromPartial(object.roomInfo)
      : undefined;
    return message;
  },
};

function createBaseImEnterRoomMessagePushFrame(): ImEnterRoomMessagePushFrame {
  return { metadata: undefined, payloadType: "", payload: undefined };
}

export const ImEnterRoomMessagePushFrame: MessageFns<ImEnterRoomMessagePushFrame> = {
  encode(message: ImEnterRoomMessagePushFrame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      ImEnterRoomMessagePushFrame_Metadata.encode(message.metadata, writer.uint32(50).fork()).join();
    }
    if (message.payloadType !== "") {
      writer.uint32(58).string(message.payloadType);
    }
    if (message.payload !== undefined) {
      ImEnterRoomMessagePushFrame_ImEnterRoomMessage.encode(message.payload, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImEnterRoomMessagePushFrame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImEnterRoomMessagePushFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = ImEnterRoomMessagePushFrame_Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.payloadType = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.payload = ImEnterRoomMessagePushFrame_ImEnterRoomMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImEnterRoomMessagePushFrame {
    return {
      metadata: isSet(object.metadata) ? ImEnterRoomMessagePushFrame_Metadata.fromJSON(object.metadata) : undefined,
      payloadType: isSet(object.payloadType) ? globalThis.String(object.payloadType) : "",
      payload: isSet(object.payload)
        ? ImEnterRoomMessagePushFrame_ImEnterRoomMessage.fromJSON(object.payload)
        : undefined,
    };
  },

  toJSON(message: ImEnterRoomMessagePushFrame): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = ImEnterRoomMessagePushFrame_Metadata.toJSON(message.metadata);
    }
    if (message.payloadType !== "") {
      obj.payloadType = message.payloadType;
    }
    if (message.payload !== undefined) {
      obj.payload = ImEnterRoomMessagePushFrame_ImEnterRoomMessage.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImEnterRoomMessagePushFrame>, I>>(base?: I): ImEnterRoomMessagePushFrame {
    return ImEnterRoomMessagePushFrame.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImEnterRoomMessagePushFrame>, I>>(object: I): ImEnterRoomMessagePushFrame {
    const message = createBaseImEnterRoomMessagePushFrame();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ImEnterRoomMessagePushFrame_Metadata.fromPartial(object.metadata)
      : undefined;
    message.payloadType = object.payloadType ?? "";
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? ImEnterRoomMessagePushFrame_ImEnterRoomMessage.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseImEnterRoomMessagePushFrame_Metadata(): ImEnterRoomMessagePushFrame_Metadata {
  return { unknown1: 0 };
}

export const ImEnterRoomMessagePushFrame_Metadata: MessageFns<ImEnterRoomMessagePushFrame_Metadata> = {
  encode(message: ImEnterRoomMessagePushFrame_Metadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unknown1 !== 0) {
      writer.uint32(112).uint32(message.unknown1);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImEnterRoomMessagePushFrame_Metadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImEnterRoomMessagePushFrame_Metadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.unknown1 = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImEnterRoomMessagePushFrame_Metadata {
    return { unknown1: isSet(object.unknown1) ? globalThis.Number(object.unknown1) : 0 };
  },

  toJSON(message: ImEnterRoomMessagePushFrame_Metadata): unknown {
    const obj: any = {};
    if (message.unknown1 !== 0) {
      obj.unknown1 = Math.round(message.unknown1);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImEnterRoomMessagePushFrame_Metadata>, I>>(
    base?: I,
  ): ImEnterRoomMessagePushFrame_Metadata {
    return ImEnterRoomMessagePushFrame_Metadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImEnterRoomMessagePushFrame_Metadata>, I>>(
    object: I,
  ): ImEnterRoomMessagePushFrame_Metadata {
    const message = createBaseImEnterRoomMessagePushFrame_Metadata();
    message.unknown1 = object.unknown1 ?? 0;
    return message;
  },
};

function createBaseImEnterRoomMessagePushFrame_ImEnterRoomMessage(): ImEnterRoomMessagePushFrame_ImEnterRoomMessage {
  return { roomId: "0", unknown1: 0, role: "", cursor: "", unknown2: undefined, unknown3: "", unknown4: undefined };
}

export const ImEnterRoomMessagePushFrame_ImEnterRoomMessage: MessageFns<
  ImEnterRoomMessagePushFrame_ImEnterRoomMessage
> = {
  encode(
    message: ImEnterRoomMessagePushFrame_ImEnterRoomMessage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.roomId !== "0") {
      writer.uint32(8).uint64(message.roomId);
    }
    if (message.unknown1 !== 0) {
      writer.uint32(32).uint32(message.unknown1);
    }
    if (message.role !== "") {
      writer.uint32(42).string(message.role);
    }
    if (message.cursor !== "") {
      writer.uint32(50).string(message.cursor);
    }
    if (message.unknown2 !== undefined) {
      writer.uint32(56).int32(message.unknown2);
    }
    if (message.unknown3 !== "") {
      writer.uint32(74).string(message.unknown3);
    }
    if (message.unknown4 !== undefined) {
      writer.uint32(80).int32(message.unknown4);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImEnterRoomMessagePushFrame_ImEnterRoomMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImEnterRoomMessagePushFrame_ImEnterRoomMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.roomId = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.unknown1 = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cursor = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.unknown2 = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.unknown3 = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.unknown4 = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImEnterRoomMessagePushFrame_ImEnterRoomMessage {
    return {
      roomId: isSet(object.roomId) ? globalThis.String(object.roomId) : "0",
      unknown1: isSet(object.unknown1) ? globalThis.Number(object.unknown1) : 0,
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      cursor: isSet(object.cursor) ? globalThis.String(object.cursor) : "",
      unknown2: isSet(object.unknown2) ? globalThis.Number(object.unknown2) : undefined,
      unknown3: isSet(object.unknown3) ? globalThis.String(object.unknown3) : "",
      unknown4: isSet(object.unknown4) ? globalThis.Number(object.unknown4) : undefined,
    };
  },

  toJSON(message: ImEnterRoomMessagePushFrame_ImEnterRoomMessage): unknown {
    const obj: any = {};
    if (message.roomId !== "0") {
      obj.roomId = message.roomId;
    }
    if (message.unknown1 !== 0) {
      obj.unknown1 = Math.round(message.unknown1);
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.cursor !== "") {
      obj.cursor = message.cursor;
    }
    if (message.unknown2 !== undefined) {
      obj.unknown2 = Math.round(message.unknown2);
    }
    if (message.unknown3 !== "") {
      obj.unknown3 = message.unknown3;
    }
    if (message.unknown4 !== undefined) {
      obj.unknown4 = Math.round(message.unknown4);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImEnterRoomMessagePushFrame_ImEnterRoomMessage>, I>>(
    base?: I,
  ): ImEnterRoomMessagePushFrame_ImEnterRoomMessage {
    return ImEnterRoomMessagePushFrame_ImEnterRoomMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImEnterRoomMessagePushFrame_ImEnterRoomMessage>, I>>(
    object: I,
  ): ImEnterRoomMessagePushFrame_ImEnterRoomMessage {
    const message = createBaseImEnterRoomMessagePushFrame_ImEnterRoomMessage();
    message.roomId = object.roomId ?? "0";
    message.unknown1 = object.unknown1 ?? 0;
    message.role = object.role ?? "";
    message.cursor = object.cursor ?? "";
    message.unknown2 = object.unknown2 ?? undefined;
    message.unknown3 = object.unknown3 ?? "";
    message.unknown4 = object.unknown4 ?? undefined;
    return message;
  },
};

function createBaseWebcastBarrageMessage(): WebcastBarrageMessage {
  return {
    baseMessage: undefined,
    event: undefined,
    msgType: undefined,
    icon: undefined,
    duration: "0",
    backGround: undefined,
    rightIcon: undefined,
    displayConfig: 0,
    galleryGiftId: "0",
    useMarquee: false,
    showType: undefined,
    renderType: undefined,
    leftIconDisplayType: undefined,
    ribbonAnimation: undefined,
    hybridUrl: "",
    schema: "",
    subType: "",
    privilegeLogExtra: undefined,
  };
}

export const WebcastBarrageMessage: MessageFns<WebcastBarrageMessage> = {
  encode(message: WebcastBarrageMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseMessage !== undefined) {
      WebcastMessageEvent.encode(message.baseMessage, writer.uint32(10).fork()).join();
    }
    if (message.event !== undefined) {
      WebcastBarrageMessage_BarrageEvent.encode(message.event, writer.uint32(18).fork()).join();
    }
    if (message.msgType !== undefined) {
      writer.uint32(24).int32(message.msgType);
    }
    if (message.icon !== undefined) {
      ImageModel.encode(message.icon, writer.uint32(34).fork()).join();
    }
    if (message.duration !== "0") {
      writer.uint32(48).int64(message.duration);
    }
    if (message.backGround !== undefined) {
      ImageModel.encode(message.backGround, writer.uint32(58).fork()).join();
    }
    if (message.rightIcon !== undefined) {
      ImageModel.encode(message.rightIcon, writer.uint32(66).fork()).join();
    }
    if (message.displayConfig !== 0) {
      writer.uint32(72).int32(message.displayConfig);
    }
    if (message.galleryGiftId !== "0") {
      writer.uint32(80).int64(message.galleryGiftId);
    }
    if (message.useMarquee !== false) {
      writer.uint32(112).bool(message.useMarquee);
    }
    if (message.showType !== undefined) {
      writer.uint32(120).int32(message.showType);
    }
    if (message.renderType !== undefined) {
      writer.uint32(136).int32(message.renderType);
    }
    if (message.leftIconDisplayType !== undefined) {
      writer.uint32(144).int32(message.leftIconDisplayType);
    }
    if (message.ribbonAnimation !== undefined) {
      ImageModel.encode(message.ribbonAnimation, writer.uint32(154).fork()).join();
    }
    if (message.hybridUrl !== "") {
      writer.uint32(170).string(message.hybridUrl);
    }
    if (message.schema !== "") {
      writer.uint32(178).string(message.schema);
    }
    if (message.subType !== "") {
      writer.uint32(186).string(message.subType);
    }
    if (message.privilegeLogExtra !== undefined) {
      PrivilegeLogExtra.encode(message.privilegeLogExtra, writer.uint32(826).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseMessage = WebcastMessageEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.event = WebcastBarrageMessage_BarrageEvent.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.msgType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.icon = ImageModel.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.duration = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.backGround = ImageModel.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.rightIcon = ImageModel.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.displayConfig = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.galleryGiftId = reader.int64().toString();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.useMarquee = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.showType = reader.int32() as any;
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.renderType = reader.int32() as any;
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.leftIconDisplayType = reader.int32() as any;
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.ribbonAnimation = ImageModel.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.hybridUrl = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.subType = reader.string();
          continue;
        }
        case 103: {
          if (tag !== 826) {
            break;
          }

          message.privilegeLogExtra = PrivilegeLogExtra.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastBarrageMessage {
    return {
      baseMessage: isSet(object.baseMessage) ? WebcastMessageEvent.fromJSON(object.baseMessage) : undefined,
      event: isSet(object.event) ? WebcastBarrageMessage_BarrageEvent.fromJSON(object.event) : undefined,
      msgType: isSet(object.msgType) ? webcastBarrageMessage_BarrageTypeFromJSON(object.msgType) : undefined,
      icon: isSet(object.icon) ? ImageModel.fromJSON(object.icon) : undefined,
      duration: isSet(object.duration) ? globalThis.String(object.duration) : "0",
      backGround: isSet(object.backGround) ? ImageModel.fromJSON(object.backGround) : undefined,
      rightIcon: isSet(object.rightIcon) ? ImageModel.fromJSON(object.rightIcon) : undefined,
      displayConfig: isSet(object.displayConfig) ? globalThis.Number(object.displayConfig) : 0,
      galleryGiftId: isSet(object.galleryGiftId) ? globalThis.String(object.galleryGiftId) : "0",
      useMarquee: isSet(object.useMarquee) ? globalThis.Boolean(object.useMarquee) : false,
      showType: isSet(object.showType) ? webcastBarrageMessage_ShowTypeFromJSON(object.showType) : undefined,
      renderType: isSet(object.renderType) ? webcastBarrageMessage_RenderTypeFromJSON(object.renderType) : undefined,
      leftIconDisplayType: isSet(object.leftIconDisplayType)
        ? webcastBarrageMessage_IconDisplayTypeFromJSON(object.leftIconDisplayType)
        : undefined,
      ribbonAnimation: isSet(object.ribbonAnimation) ? ImageModel.fromJSON(object.ribbonAnimation) : undefined,
      hybridUrl: isSet(object.hybridUrl) ? globalThis.String(object.hybridUrl) : "",
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
      subType: isSet(object.subType) ? globalThis.String(object.subType) : "",
      privilegeLogExtra: isSet(object.privilegeLogExtra)
        ? PrivilegeLogExtra.fromJSON(object.privilegeLogExtra)
        : undefined,
    };
  },

  toJSON(message: WebcastBarrageMessage): unknown {
    const obj: any = {};
    if (message.baseMessage !== undefined) {
      obj.baseMessage = WebcastMessageEvent.toJSON(message.baseMessage);
    }
    if (message.event !== undefined) {
      obj.event = WebcastBarrageMessage_BarrageEvent.toJSON(message.event);
    }
    if (message.msgType !== undefined) {
      obj.msgType = webcastBarrageMessage_BarrageTypeToJSON(message.msgType);
    }
    if (message.icon !== undefined) {
      obj.icon = ImageModel.toJSON(message.icon);
    }
    if (message.duration !== "0") {
      obj.duration = message.duration;
    }
    if (message.backGround !== undefined) {
      obj.backGround = ImageModel.toJSON(message.backGround);
    }
    if (message.rightIcon !== undefined) {
      obj.rightIcon = ImageModel.toJSON(message.rightIcon);
    }
    if (message.displayConfig !== 0) {
      obj.displayConfig = Math.round(message.displayConfig);
    }
    if (message.galleryGiftId !== "0") {
      obj.galleryGiftId = message.galleryGiftId;
    }
    if (message.useMarquee !== false) {
      obj.useMarquee = message.useMarquee;
    }
    if (message.showType !== undefined) {
      obj.showType = webcastBarrageMessage_ShowTypeToJSON(message.showType);
    }
    if (message.renderType !== undefined) {
      obj.renderType = webcastBarrageMessage_RenderTypeToJSON(message.renderType);
    }
    if (message.leftIconDisplayType !== undefined) {
      obj.leftIconDisplayType = webcastBarrageMessage_IconDisplayTypeToJSON(message.leftIconDisplayType);
    }
    if (message.ribbonAnimation !== undefined) {
      obj.ribbonAnimation = ImageModel.toJSON(message.ribbonAnimation);
    }
    if (message.hybridUrl !== "") {
      obj.hybridUrl = message.hybridUrl;
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    if (message.subType !== "") {
      obj.subType = message.subType;
    }
    if (message.privilegeLogExtra !== undefined) {
      obj.privilegeLogExtra = PrivilegeLogExtra.toJSON(message.privilegeLogExtra);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastBarrageMessage>, I>>(base?: I): WebcastBarrageMessage {
    return WebcastBarrageMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastBarrageMessage>, I>>(object: I): WebcastBarrageMessage {
    const message = createBaseWebcastBarrageMessage();
    message.baseMessage = (object.baseMessage !== undefined && object.baseMessage !== null)
      ? WebcastMessageEvent.fromPartial(object.baseMessage)
      : undefined;
    message.event = (object.event !== undefined && object.event !== null)
      ? WebcastBarrageMessage_BarrageEvent.fromPartial(object.event)
      : undefined;
    message.msgType = object.msgType ?? undefined;
    message.icon = (object.icon !== undefined && object.icon !== null)
      ? ImageModel.fromPartial(object.icon)
      : undefined;
    message.duration = object.duration ?? "0";
    message.backGround = (object.backGround !== undefined && object.backGround !== null)
      ? ImageModel.fromPartial(object.backGround)
      : undefined;
    message.rightIcon = (object.rightIcon !== undefined && object.rightIcon !== null)
      ? ImageModel.fromPartial(object.rightIcon)
      : undefined;
    message.displayConfig = object.displayConfig ?? 0;
    message.galleryGiftId = object.galleryGiftId ?? "0";
    message.useMarquee = object.useMarquee ?? false;
    message.showType = object.showType ?? undefined;
    message.renderType = object.renderType ?? undefined;
    message.leftIconDisplayType = object.leftIconDisplayType ?? undefined;
    message.ribbonAnimation = (object.ribbonAnimation !== undefined && object.ribbonAnimation !== null)
      ? ImageModel.fromPartial(object.ribbonAnimation)
      : undefined;
    message.hybridUrl = object.hybridUrl ?? "";
    message.schema = object.schema ?? "";
    message.subType = object.subType ?? "";
    message.privilegeLogExtra = (object.privilegeLogExtra !== undefined && object.privilegeLogExtra !== null)
      ? PrivilegeLogExtra.fromPartial(object.privilegeLogExtra)
      : undefined;
    return message;
  },
};

function createBaseWebcastBarrageMessage_BarrageEvent(): WebcastBarrageMessage_BarrageEvent {
  return { eventName: "", params: {} };
}

export const WebcastBarrageMessage_BarrageEvent: MessageFns<WebcastBarrageMessage_BarrageEvent> = {
  encode(message: WebcastBarrageMessage_BarrageEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventName !== "") {
      writer.uint32(10).string(message.eventName);
    }
    Object.entries(message.params).forEach(([key, value]) => {
      WebcastBarrageMessage_BarrageEvent_ParamsEntry.encode({ key: key as any, value }, writer.uint32(18).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage_BarrageEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_BarrageEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = WebcastBarrageMessage_BarrageEvent_ParamsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.params[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastBarrageMessage_BarrageEvent {
    return {
      eventName: isSet(object.eventName) ? globalThis.String(object.eventName) : "",
      params: isObject(object.params)
        ? Object.entries(object.params).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: WebcastBarrageMessage_BarrageEvent): unknown {
    const obj: any = {};
    if (message.eventName !== "") {
      obj.eventName = message.eventName;
    }
    if (message.params) {
      const entries = Object.entries(message.params);
      if (entries.length > 0) {
        obj.params = {};
        entries.forEach(([k, v]) => {
          obj.params[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastBarrageMessage_BarrageEvent>, I>>(
    base?: I,
  ): WebcastBarrageMessage_BarrageEvent {
    return WebcastBarrageMessage_BarrageEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastBarrageMessage_BarrageEvent>, I>>(
    object: I,
  ): WebcastBarrageMessage_BarrageEvent {
    const message = createBaseWebcastBarrageMessage_BarrageEvent();
    message.eventName = object.eventName ?? "";
    message.params = Object.entries(object.params ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseWebcastBarrageMessage_BarrageEvent_ParamsEntry(): WebcastBarrageMessage_BarrageEvent_ParamsEntry {
  return { key: "", value: "" };
}

export const WebcastBarrageMessage_BarrageEvent_ParamsEntry: MessageFns<
  WebcastBarrageMessage_BarrageEvent_ParamsEntry
> = {
  encode(
    message: WebcastBarrageMessage_BarrageEvent_ParamsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage_BarrageEvent_ParamsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_BarrageEvent_ParamsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebcastBarrageMessage_BarrageEvent_ParamsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: WebcastBarrageMessage_BarrageEvent_ParamsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebcastBarrageMessage_BarrageEvent_ParamsEntry>, I>>(
    base?: I,
  ): WebcastBarrageMessage_BarrageEvent_ParamsEntry {
    return WebcastBarrageMessage_BarrageEvent_ParamsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebcastBarrageMessage_BarrageEvent_ParamsEntry>, I>>(
    object: I,
  ): WebcastBarrageMessage_BarrageEvent_ParamsEntry {
    const message = createBaseWebcastBarrageMessage_BarrageEvent_ParamsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.27.1
// source: data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  AgreeStatus,
  AuditStatus,
  BattleInviteType,
  BattleType,
  CohostABTestType,
  CohostLayoutMode,
  ContentInviteSource,
  ContentPositionType,
  ContentSource,
  EmotePrivateType,
  EmoteScene,
  EmoteType,
  GroupStatus,
  GuestMicCameraChangeScene,
  GuestMicCameraManageOp,
  HashtagNamespace,
  JoinType,
  KickoutReason,
  LinkmicApplierSortSetting,
  LinkmicMultiLiveEnum,
  LinkmicRoleType,
  LinkmicShareRevenueSetting,
  LinkmicStatus,
  LinkMicUserAdminType,
  LinkRoleType,
  LinkSilenceStatus,
  LinkType,
  LinkUserType,
  MultiGuestOutsideRoomInviteSource,
  MuteStatus,
  OptPairStatus,
  PerceptionDialogIconType,
  PlayScene,
  PollEndType,
  PosIdentityType,
  PunishTypeId,
  ReplyStatus,
  RewardCondition,
  Scene,
  SourceType,
  TagClassification,
  TagType,
  TextType,
  TopicActionType,
  UserEmoteUploadSource,
  UserMetricsType,
} from "./enums";

export const protobufPackage = "";

/** @Common */
export interface CommonMessageData {
  method: string;
  msgId: string;
  roomId: string;
  createTime: string;
  monitor: number;
  isShowMsg: boolean;
  describe: string;
  displayText: Text | undefined;
  foldType: string;
  anchorFoldType: string;
  priorityScore: string;
  logId: string;
  msgProcessFilterK: string;
  msgProcessFilterV: string;
  fromIdc: string;
  toIdc: string;
  filterMsgTagsList: string[];
  sei: CommonMessageData_LiveMessageSEI | undefined;
  dependRootId: CommonMessageData_LiveMessageID | undefined;
  dependId: CommonMessageData_LiveMessageID | undefined;
  anchorPriorityScore: string;
  roomMessageHeatLevel: string;
  foldTypeForWeb: string;
  anchorFoldTypeForWeb: string;
  clientSendTime: string;
  /** Enum */
  dispatchStrategy: CommonMessageData_IMDispatchStrategy;
}

export enum CommonMessageData_IMDispatchStrategy {
  IM_DISPATCH_STRATEGY_DEFAULT = 0,
  IM_DISPATCH_STRATEGY_BYPASS_DISPATCH_QUEUE = 1,
  UNRECOGNIZED = -1,
}

export interface CommonMessageData_LiveMessageSEI {
  uniqueId: CommonMessageData_LiveMessageID | undefined;
  timestamp: string;
}

export interface CommonMessageData_LiveMessageID {
  primaryId: string;
  messageScene: string;
}

/** @Text */
export interface Text {
  displayType: string;
  defaultPattern: string;
  defaultFormat: Text_TextFormat | undefined;
  piecesList: Text_TextPiece[];
}

export enum Text_ShowType {
  SHOW_TYPE_NORMAL = 0,
  SHOW_TYPE_FADE_IN_OUT = 1,
  UNRECOGNIZED = -1,
}

export interface Text_TextPiece {
  type: number;
  format: Text_TextFormat | undefined;
  stringValue: string;
  userValue?: Text_TextPieceUser | undefined;
  giftValue?: Text_TextPieceGift | undefined;
  patternRefValue: Text_TextPiecePatternRef | undefined;
}

export interface Text_TextFormat {
  color: string;
  bold: boolean;
  italic: boolean;
  weight: number;
  italicAngle: number;
  fontSize: number;
  useHeighLightColor: boolean;
  useRemoteClor: boolean;
}

export interface Text_TextPieceGift {
  giftId: number;
  nameRef:
    | Text_PatternRef
    | undefined;
  /** Enum */
  showType: Text_ShowType;
  colorId: string;
}

export interface Text_TextPiecePatternRef {
  key: string;
  defaultPattern: string;
}

export interface Text_TextPieceUser {
  user: User | undefined;
  withColon: boolean;
}

export interface Text_PatternRef {
  key: string;
  defaultPattern: string;
}

/** @Image */
export interface Image {
  url: string[];
  mUri: string;
  height: number;
  width: number;
  avgColor: string;
  imageType: number;
  schema: string;
  content: Image_Content | undefined;
  isAnimated: boolean;
}

export interface Image_Content {
  name: string;
  fontColor: string;
  level: string;
}

/** @Badge */
export interface BadgeStruct {
  /** Enum */
  badgeDisplayType: BadgeStruct_BadgeDisplayType;
  badgePriorityType: BadgeStruct_BadgePriorityType;
  badgeScene: BadgeStruct_BadgeSceneType;
  position: BadgeStruct_Position;
  displayStatus: BadgeStruct_DisplayStatus;
  greyedByClient: string;
  exhibitionType: BadgeStruct_BadgeExhibitionType;
  schemaUrl: string;
  display: boolean;
  logExtra: PrivilegeLogExtra | undefined;
  image?: BadgeStruct_ImageBadge | undefined;
  text?: BadgeStruct_TextBadge | undefined;
  str?: BadgeStruct_StringBadge | undefined;
  combine?: BadgeStruct_CombineBadge | undefined;
  isCustomized: boolean;
}

export enum BadgeStruct_BadgeDisplayType {
  BADGEDISPLAYTYPE_UNKNOWN = 0,
  BADGEDISPLAYTYPE_IMAGE = 1,
  BADGEDISPLAYTYPE_TEXT = 2,
  BADGEDISPLAYTYPE_STRING = 3,
  BADGEDISPLAYTYPE_COMBINE = 4,
  UNRECOGNIZED = -1,
}

export enum BadgeStruct_BadgePriorityType {
  BADGE_PRIORITY_TYPE_UNKNOWN = 0,
  BADGE_PRIORITY_TYPE_STRONG_RELATION = 10,
  BADGE_PRIORITY_TYPE_PLATFORM = 20,
  BADGE_PRIORITY_TYPE_RELATION = 30,
  BADGE_PRIORITY_TYPE_ACTIVITY = 40,
  BADGE_PRIORITY_TYPE_RANK_LIST = 50,
  UNRECOGNIZED = -1,
}

export enum BadgeStruct_BadgeSceneType {
  BADGE_SCENE_TYPE_UNKNOWN = 0,
  BADGE_SCENE_TYPE_ADMIN = 1,
  BADGE_SCENE_TYPE_FIRST_RECHARGE = 2,
  BADGE_SCENE_TYPE_FRIENDS = 3,
  BADGE_SCENE_TYPE_SUBSCRIBER = 4,
  BADGE_SCENE_TYPE_ACTIVITY = 5,
  BADGE_SCENE_TYPE_RANK_LIST = 6,
  BADGE_SCENE_TYPE_NEW_SUBSCRIBER = 7,
  BADGE_SCENE_TYPE_USER_GRADE = 8,
  BADGE_SCENE_TYPE_STATE_CONTROLLED_MEDIA = 9,
  BADGE_SCENE_TYPE_FANS = 10,
  BADGE_SCENE_TYPE_LIVE_PRO = 11,
  BADGE_SCENE_TYPE_ANCHOR = 12,
  UNRECOGNIZED = -1,
}

export enum BadgeStruct_DisplayStatus {
  DISPLAY_STATUS_NORMAL = 0,
  DISPLAY_STATUS_SHADOW = 1,
  UNRECOGNIZED = -1,
}

export enum BadgeStruct_BadgeExhibitionType {
  BADGE_EXHIBITION_TYPE_BADGE = 0,
  BADGE_EXHIBITION_TYPE_IDENTITY_LABEL = 1,
  UNRECOGNIZED = -1,
}

export enum BadgeStruct_Position {
  POSITIONUNKNOWN = 0,
  POSITIONLEFT = 1,
  POSITIONRIGHT = 2,
  UNRECOGNIZED = -1,
}

export enum BadgeStruct_HorizontalPaddingRule {
  HORIZONTAL_PADDING_RULE_USE_MIDDLE_AND_WIDTH = 0,
  HORIZONTAL_PADDING_RULE_USE_LEFT_AND_MIDDLE_AND_RIGHT = 1,
  UNRECOGNIZED = -1,
}

export enum BadgeStruct_VerticalPaddingRule {
  VERTICAL_PADDING_RULE_USE_DEFAULT = 0,
  VERTICAL_PADDING_RULE_USE_TOP_AND_BOTTOM = 1,
  UNRECOGNIZED = -1,
}

export interface BadgeStruct_CombineBadge {
  badgeDisplayType: number;
  icon: Image | undefined;
  text: BadgeStruct_TextBadge | undefined;
  str: string;
  padding: BadgeStruct_PaddingInfo | undefined;
  fontStyle: FontStyle | undefined;
  profileCardPanel: BadgeStruct_ProfileCardPanel | undefined;
  background: BadgeStruct_CombineBadgeBackground | undefined;
  backgroundDarkMode: BadgeStruct_CombineBadgeBackground | undefined;
  iconAutoMirrored: boolean;
  bgAutoMirrored: boolean;
  publicScreenShowStyle: number;
  personalCardShowStyle: number;
  rankListOnlineAudienceShowStyle: number;
  multiGuestShowStyle: number;
  arrowConfig: BadgeStruct_ArrowConfig | undefined;
  paddingNewFont: BadgeStruct_PaddingInfo | undefined;
}

export interface BadgeStruct_ArrowConfig {
  icon: Image | undefined;
}

export interface BadgeStruct_ProfileContent {
  useContent: boolean;
  iconList: BadgeStruct_IconConfig[];
  numberConfig: BadgeStruct_NumberConfig | undefined;
}

export interface BadgeStruct_ProjectionConfig {
  useProjection: boolean;
  icon: Image | undefined;
}

export interface BadgeStruct_NumberConfig {
  number: string;
  fontStyle: FontStyle | undefined;
  background: BadgeStruct_CombineBadgeBackground | undefined;
}

export interface BadgeStruct_ProfileCardPanel {
  useNewProfileCardStyle: boolean;
  /** BadgeTextPosition badgeTextPosition = 2; // Enum */
  projectionConfig: BadgeStruct_ProjectionConfig | undefined;
  profileContent: BadgeStruct_ProfileContent | undefined;
}

export interface BadgeStruct_CombineBadgeBackground {
  image: Image | undefined;
  backgroundColorCode: string;
  borderColorCode: string;
}

export interface BadgeStruct_ImageBadge {
  badgeDisplayType: BadgeStruct_BadgeDisplayType;
  image: Image | undefined;
}

export interface BadgeStruct_TextBadge {
  badgeDisplayType: BadgeStruct_BadgeDisplayType;
  key: string;
  defaultPattern: string;
  pieces: string[];
}

export interface BadgeStruct_IconConfig {
  icon: Image | undefined;
  background: BadgeStruct_CombineBadgeBackground | undefined;
}

export interface BadgeStruct_StringBadge {
  badgeDisplayType: BadgeStruct_BadgeDisplayType;
  str: string;
}

export interface BadgeStruct_PaddingInfo {
  useSpecific: boolean;
  middlePadding: number;
  badgeWidth: number;
  leftPadding: number;
  rightPadding: number;
  iconTopPadding: number;
  iconBottomPadding: number;
  horizontalPaddingRule: BadgeStruct_HorizontalPaddingRule;
  verticalPaddingRule: BadgeStruct_VerticalPaddingRule;
}

/** @Gift */
export interface Gift {
  giftImage: Image | undefined;
  describe: string;
  duration: number;
  id: string;
  forLinkMic: boolean;
  combo: boolean;
  giftType: number;
  diamondCount: number;
  isDisplayedOnPanel: boolean;
  primaryEffectId: string;
  giftLabelIcon: Image | undefined;
  giftName: string;
  icon: Image | undefined;
  goldEffect: string;
  previewImage: Image | undefined;
  giftPanelBanner: Gift_GiftPanelBanner | undefined;
  isBroadcastGift: boolean;
  isEffectBefview: boolean;
  isRandomGift: boolean;
  isBoxGift: boolean;
  canPutInGiftBox: boolean;
  giftBoxInfo: Gift_GiftBoxInfo | undefined;
}

export interface Gift_GiftPanelBanner {
  displayText: Text | undefined;
  leftIcon: Image | undefined;
  schemaUrl: string;
  bgColors: string[];
  bannerLynxUrl: string;
  bannerPriority: number;
  bannerLynxExtra: string;
  bgImage: Image | undefined;
}

export interface Gift_BatchGiftInfo {
  canBatchSend: boolean;
  availableCounts: string[];
}

export interface Gift_CrossScreenEffectInfo {
  singleActionEffectIds: { [key: string]: number };
  actionEffectIds: { [key: string]: number };
  reactionEffectIds: { [key: string]: number };
}

export interface Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntry {
  key: string;
  value: number;
}

export interface Gift_CrossScreenEffectInfo_ActionEffectIdsEntry {
  key: string;
  value: number;
}

export interface Gift_CrossScreenEffectInfo_ReactionEffectIdsEntry {
  key: string;
  value: number;
}

export interface Gift_GiftSponsorInfo {
  sponsorId: string;
  sponsorCount: string;
  currentCount: string;
  leftCountToSponsor: string;
  canSponsor: boolean;
}

export interface Gift_UGGiftStructInfo {
  isUgGift: boolean;
  ugPointsCost: string;
}

export interface Gift_GiftSkin {
  giftSkinId: string;
  giftSkinName: string;
  staticImage: Image | undefined;
  animatedImage: Image | undefined;
}

export interface Gift_GiftText {
  giftTextId: string;
  giftTextName: string;
}

export interface Gift_GiftSkinToGiftTextsInfo {
  giftSkinId: string;
  giftTextIds: string[];
}

export interface Gift_GiftBoxInfo {
  capacity: string;
  isPrimaryBox: boolean;
  schemeUrl: string;
}

/** @User */
export interface User {
  userId: string;
  nickname: string;
  bioDescription: string;
  profilePicture: Image | undefined;
  profilePictureMedium: Image | undefined;
  profilePictureLarge: Image | undefined;
  verified: boolean;
  status: number;
  createTime: string;
  modifyTime: string;
  secret: number;
  shareQrcodeUri: string;
  badgeImageList: Image[];
  followInfo: User_FollowInfo | undefined;
  userHonor: UserHonor | undefined;
  fansClub: FansClubMember | undefined;
  border: BorderInfo | undefined;
  specialId: string;
  avatarBorder: Image | undefined;
  medal: Image | undefined;
  userBadges: Image[];
  newUserBadges: Image[];
  topVipNo: number;
  userAttr: User_UserAttr | undefined;
  ownRoom: User_OwnRoom | undefined;
  payScore: string;
  fanTicketCount: string;
  anchorInfo: User_AnchorLevel | undefined;
  linkMicStats: LinkmicStatus;
  uniqueId: string;
  enableShowCommerceSale: boolean;
  withFusionShopEntry: boolean;
  payScores: string;
  anchorLevel: User_AnchorLevel | undefined;
  verifiedContent: string;
  authorInfo: Author | undefined;
  topFans: User[];
  secUid: string;
  userRole: number;
  rewardInfo: User_ActivityInfo | undefined;
  personalCard: Image | undefined;
  authenticationInfo: User_AuthenticationInfo | undefined;
  mediaBadgeImageList: Image[];
  commerceWebcastConfigIds: string[];
  borders: BorderInfo[];
  comboBadgeInfo: User_ComboBadgeInfo | undefined;
  subscribeInfo: User_SubscribeInfo | undefined;
  badges: BadgeStruct[];
  mintTypeLabel: string[];
  fansClubInfo: User_FansClubInfo | undefined;
  allowFindByContacts: boolean;
  allowOthersDownloadVideo: boolean;
  allowOthersDownloadWhenSharingVideo: boolean;
  allowShareShowProfile: boolean;
  allowShowInGossip: boolean;
  allowShowMyAction: boolean;
  allowStrangeComment: boolean;
  allowUnfollowerComment: boolean;
  allowUseLinkmic: boolean;
  avatarJpg: Image | undefined;
  backgroundImgUrl: string;
  blockStatus: number;
  commentRestrict: number;
  constellation: string;
  disableIchat: number;
  enableIchatImg: string;
  exp: number;
  foldStrangerChat: boolean;
  followStatus: string;
  ichatRestrictType: number;
  idStr: string;
  isFollower: boolean;
  isFollowing: boolean;
  needProfileGuide: boolean;
  pushCommentStatus: boolean;
  pushDigg: boolean;
  pushFollow: boolean;
  pushFriendAction: boolean;
  pushIchat: boolean;
  pushStatus: boolean;
  pushVideoPost: boolean;
  pushVideoRecommend: boolean;
  verifiedReason: string;
  enableCarManagementPermission: boolean;
  upcomingEventList: User_LiveEventInfo[];
  scmLabel: string;
  ecommerceEntrance: User_EcommerceEntrance | undefined;
  isBlock: boolean;
  isSubscribe: boolean;
  isAnchorMarked: boolean;
}

export interface User_LiveEventInfo {
  eventId: string;
  startTime: string;
  duration: string;
  title: string;
  description: string;
  hasSubscribed: boolean;
  isPaidEvent: boolean;
  ticketAmount: string;
  /** @warning Enum not found, should be PayMethod */
  payMethod: string;
}

/**
 * @EventPayMethod
 * webcast.data.LiveEventInfo
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export enum User_LiveEventInfo_EventPayMethod {
  EVENTPAYMETHODINVALID = 0,
  EVENTPAYMETHODCOINS = 1,
  EVENTPAYMETHODCASH = 2,
  UNRECOGNIZED = -1,
}

/**
 * @WalletPackage
 * proto.webcast.data.LiveEventInfo
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_LiveEventInfo_WalletPackage {
  iapId: string;
  usdPriceShow: string;
}

/**
 * @ActivityInfo
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_ActivityInfo {
  badge: Image | undefined;
  storytag: Image | undefined;
}

/**
 * @AnchorLevel
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_AnchorLevel {
  level: string;
  experience: string;
  lowestExperienceThisLevel: string;
  highestExperienceThisLevel: string;
  taskStartExperience: string;
  taskStartTime: string;
  taskDecreaseExperience: string;
  taskTargetExperience: string;
  taskEndTime: string;
  profileDialogBg: Image | undefined;
  profileDialogBgBack: Image | undefined;
  stageLevel: Image | undefined;
  smallIcon: Image | undefined;
}

/**
 * @AuthenticationInfo
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_AuthenticationInfo {
  customVerify: string;
  enterpriseVerifyReason: string;
  authenticationBadge: Image | undefined;
}

/**
 * @AuthorStats
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_AuthorStats {
  videoTotalCount: string;
  videoTotalPlayCount: string;
  videoTotalShareCount: string;
  videoTotalSeriesCount: string;
  varietyShowPlayCount: string;
  videoTotalFavoriteCount: string;
}

/**
 * @Border
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_Border {
  icon: Image | undefined;
  level: string;
  source: string;
  profileDecorationRibbon: Image | undefined;
  avatarBackgroundColor: string;
  avatarBackgroundBorderColor: string;
}

/**
 * @ComboBadgeInfo
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_ComboBadgeInfo {
  icon: Image | undefined;
  comboCount: string;
}

/**
 * @EcommerceEntrance
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_EcommerceEntrance {
  /** Enum */
  entranceType: User_EcommerceEntrance_EntranceType;
  /** Enum */
  creatorType: User_EcommerceEntrance_CreatorType;
  schema: string;
  shopEntranceInfo: User_EcommerceEntrance_ShopEntranceInfo | undefined;
  showcaseEntranceInfo: User_EcommerceEntrance_ShowcaseEntranceInfo | undefined;
}

/**
 * @CreatorType
 * webcast.data.User.EcommerceEntrance
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export enum User_EcommerceEntrance_CreatorType {
  UNDEFINED = 0,
  OFFICIAL = 1,
  MARKET = 2,
  NORMAL = 3,
  UNRECOGNIZED = -1,
}

/**
 * @EntranceType
 * webcast.data.User.EcommerceEntrance
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export enum User_EcommerceEntrance_EntranceType {
  PROFILE = 0,
  SHOWCASE = 1,
  SHOP = 2,
  UNRECOGNIZED = -1,
}

/**
 * @ShopEntranceInfo
 * proto.webcast.data.User.EcommerceEntrance
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_EcommerceEntrance_ShopEntranceInfo {
  shopId: string;
  shopName: string;
  shopRating: string;
  storeLabel: User_EcommerceEntrance_ShopEntranceInfo_StoreLabel | undefined;
  formatSoldCount: string;
  soldCount: string;
  expRatePercentile: number;
  expRateTopDisplay: string;
  rateDisplayStyle: number;
  showRateNotApplicable: boolean;
}

/**
 * @StoreLabel
 * proto.webcast.data.User.EcommerceEntrance.ShopEntranceInfo
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_EcommerceEntrance_ShopEntranceInfo_StoreLabel {
  officialLabel: User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel | undefined;
  isBytemall: boolean;
}

/**
 * @StoreBrandLabelType
 * webcast.data.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export enum User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreBrandLabelType {
  NONE = 0,
  OFFICIAL = 1,
  AUTHORIZED = 2,
  STORE_BRAND_LABEL_TYPE_BLUE_V = 3,
  STORE_BRAND_LABEL_TYPE_TOP_CHOICE = 4,
  UNRECOGNIZED = -1,
}

/**
 * @StoreOfficialLabel
 * proto.webcast.data.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel {
  labelImageLight: User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage | undefined;
  labelImageDark:
    | User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage
    | undefined;
  /** @warning Enum not found, should be LabelType */
  labelType: string;
  labelTypeStr: string;
}

/**
 * @ShopLabelImage
 * proto.webcast.data.User.EcommerceEntrance.ShopEntranceInfo.StoreLabel.StoreOfficialLabel
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage {
  height: number;
  width: number;
  minetype: string;
  thumbUri: string;
  thumbUriList: string[];
  uri: string;
  urlList: string[];
  color: string;
}

/**
 * @ShowcaseEntranceInfo
 * proto.webcast.data.User.EcommerceEntrance
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_EcommerceEntrance_ShowcaseEntranceInfo {
  formatSoldCount: string;
  soldCount: string;
}

/**
 * @FansClub
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_FansClub {
  data: User_FansClub_FansClubData | undefined;
}

/**
 * @PreferntialType
 * webcast.data.User.FansClub
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export enum User_FansClub_PreferntialType {
  PRESONALPROFILE = 0,
  OTHERROOM = 1,
  UNRECOGNIZED = -1,
}

/**
 * @FansClubData
 * proto.webcast.data.User.FansClub
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_FansClub_FansClubData {
  clubName: string;
  level: number;
  /** Enum */
  userFansClubStatus: User_FansClub_FansClubData_UserFansClubStatus;
  availableGiftIdsList: string[];
  anchorId: string;
}

/**
 * @BadgeIcon
 * webcast.data.User.FansClub.FansClubData
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export enum User_FansClub_FansClubData_BadgeIcon {
  UNKNOWN = 0,
  ICON = 1,
  SMALLICON = 2,
  UNRECOGNIZED = -1,
}

/**
 * @UserFansClubStatus
 * webcast.data.User.FansClub.FansClubData
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export enum User_FansClub_FansClubData_UserFansClubStatus {
  NOTJOINED = 0,
  ACTIVE = 1,
  INACTIVE = 2,
  UNRECOGNIZED = -1,
}

/**
 * @FansClubInfo
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_FansClubInfo {
  isSleeping: boolean;
  fansLevel: string;
  fansScore: string;
  badge: Image | undefined;
  fansCount: string;
  fansClubName: string;
}

/**
 * @FollowInfo
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_FollowInfo {
  followingCount: string;
  followerCount: string;
  followStatus: string;
  pushStatus: string;
}

/**
 * @OwnRoom
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_OwnRoom {
  roomIdsList: string[];
  roomIdsStrList: string[];
}

/**
 * @PayGrade
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_PayGrade {
  diamondIcon: Image | undefined;
  name: string;
  icon: Image | undefined;
  nextName: string;
  level: string;
  nextIcon: Image | undefined;
  gradeDescribe: string;
  gradeIconList: GradeIcon[];
  screenChatType: string;
  imIcon: Image | undefined;
  imIconWithLevel: Image | undefined;
  liveIcon: Image | undefined;
  newImIconWithLevel: Image | undefined;
  newLiveIcon: Image | undefined;
  upgradeNeedConsume: string;
  nextPrivileges: string;
  background: Image | undefined;
  backgroundBack: Image | undefined;
  score: string;
  gradeBanner: string;
  profileDialogBg: Image | undefined;
  profileDialogBgBack: Image | undefined;
}

/**
 * @SubscribeBadge
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_SubscribeBadge {
  originImg: Image | undefined;
  previewImg: Image | undefined;
}

/**
 * @SubscribeInfo
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_SubscribeInfo {
  qualification: boolean;
  isSubscribe: boolean;
  badge: User_SubscribeBadge | undefined;
  enableSubscription: boolean;
  subscriberCount: string;
  isInGracePeriod: boolean;
  isSubscribedToAnchor: boolean;
  userGiftSubAuth: boolean;
  anchorGiftSubAuth: boolean;
}

/**
 * @UserAttr
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_UserAttr {
  isMuted: boolean;
  isAdmin: boolean;
  isSuperAdmin: boolean;
  muteDuration: string;
}

/**
 * @UserStats
 * proto.webcast.data.User
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface User_UserStats {
  id: string;
  idStr: string;
  followingCount: string;
  followerCount: string;
  recordCount: string;
  totalDuration: string;
  dailyFanTicketCount: string;
  dailyIncome: string;
  itemCount: string;
  favoriteItemCount: string;
  diamondConsumedCount: string;
  tuwenItemCount: string;
}

/** @Emote */
export interface Emote {
  emoteId: string;
  image:
    | Image
    | undefined;
  /** Enum */
  auditStatus: AuditStatus;
  uuid: string;
  /** Enum */
  emoteType: EmoteType;
  /** Enum */
  contentSource: ContentSource;
  /** Enum */
  emotePrivateType: EmotePrivateType;
  packageId: string;
  auditInfo: Emote_AuditInfo | undefined;
  rewardCondition: RewardCondition;
  emoteUploadInfo: Emote_EmoteUploadInfo | undefined;
  createTime: string;
  emoteScene: EmoteScene;
}

export interface Emote_AuditInfo {
  violationId: string;
  taskType: Emote_AuditInfo_AuditTaskType;
}

export enum Emote_AuditInfo_AuditTaskType {
  AUDIT_TASK_TYPE_DEFAULT = 0,
  AUDIT_TASK_TYPE_APPEAL = 1,
  UNRECOGNIZED = -1,
}

export interface Emote_EmoteUploadInfo {
  userId: string;
  emoteUploadSource: UserEmoteUploadSource;
  userInfo: User | undefined;
  userIdStr: string;
}

/** @PunishEventInfo */
export interface PunishEventInfo {
  punishType: string;
  punishReason: string;
  punishId: string;
  violationUid: string;
  /** Enum */
  punishTypeId: PunishTypeId;
  duration: string;
  punishPerceptionCode: string;
  violationUidStr: string;
  showReason: string;
}

/** @MsgFilter */
export interface MsgFilter {
  isGifter: boolean;
  isSubscribedToAnchor: boolean;
}

/**
 * @UserIdentity
 * proto.webcast.data
 */
export interface UserIdentity {
  isGiftGiverOfAnchor: boolean;
  isSubscriberOfAnchor: boolean;
  isMutualFollowingWithAnchor: boolean;
  isFollowerOfAnchor: boolean;
  isModeratorOfAnchor: boolean;
  isAnchor: boolean;
}

/**
 * @Goal
 * proto.webcast.data
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface LiveStreamGoal {
  id: string;
  type: number;
  status: number;
  subGoals: LiveStreamGoal_LiveStreamSubGoal[];
  description: string;
  auditStatus: AuditStatus;
  cycleType: number;
  startTime: string;
  expireTime: string;
  realFinishTime: string;
  contributors: LiveStreamGoal_LiveStreamGoalContributor[];
  contributorsLength: number;
  idStr: string;
  auditDescription: string;
  stats: LiveStreamGoal_GoalStats | undefined;
  goalExtraInfo: string;
  mode: number;
  auditInfo: LiveStreamGoal_AuditInfo | undefined;
  challengeType: string;
  isUneditable: boolean;
}

export interface LiveStreamGoal_AuditInfo {
  violationId: string;
  taskType: number;
}

export interface LiveStreamGoal_LiveStreamSubGoal {
  type: number;
  id: string;
  progress: string;
  target: string;
  gift: LiveStreamGoal_LiveStreamSubGoalGift | undefined;
  idStr: string;
  pinInfo: LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo | undefined;
  source: number;
  recommendedText: string;
  recommendedHeader: string;
}

export interface LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo {
  pinStartTime: string;
  pinEndTime: string;
  pinReadyTime: string;
}

export interface LiveStreamGoal_LiveStreamSubGoalGift {
  name: string;
  icon: Image | undefined;
  diamondCount: string;
  type: number;
}

export interface LiveStreamGoal_LiveStreamGoalContributor {
  userId: string;
  avatar: Image | undefined;
  displayId: string;
  score: string;
  userIdStr: string;
  inRoom: boolean;
  isFriend: boolean;
  followByOwner: boolean;
  isFistContribute: boolean;
  subGoalContributions: LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution[];
}

export interface LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution {
  id: string;
  contributionCount: string;
}

export interface LiveStreamGoal_GoalStats {
  totalCoins: string;
  totalContributor: string;
  comparison: LiveStreamGoal_GoalStats_GoalComparison | undefined;
  totalNewFans: string;
}

export interface LiveStreamGoal_GoalStats_GoalComparison {
  coinsIncr: string;
  contributorIncr: string;
}

/**
 * @Indicator
 * proto.webcast.data
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface LiveStreamGoalIndicator {
  key: string;
  op: number;
}

export interface Ranking {
  type: string;
  label: string;
  color: TikTokColor | undefined;
  details: ValueLabel[];
}

export interface TikTokColor {
  color: string;
  id: string;
  data1: number;
}

export interface ValueLabel {
  data: number;
  label: string;
  label2: string;
  label3: string;
}

export interface TimeStampContainer {
  timestamp1: string;
  timestamp2: string;
  timestamp3: string;
}

export interface PollStartContent {
  StartTime: string;
  EndTime: string;
  OptionList: PollOptionInfo[];
  Title: string;
  Operator: User | undefined;
}

export interface PollEndContent {
  EndType: PollEndType;
  OptionList: PollOptionInfo[];
  Operator: User | undefined;
}

export interface PollOptionInfo {
  Votes: number;
  DisplayContent: string;
  OptionIdx: number;
  VoteUserList: VoteUser[];
}

export interface VoteUser {
  UserId: string;
  NickName: string;
  AvatarThumb: Image | undefined;
}

export interface PollUpdateVotesContent {
  OptionList: PollOptionInfo[];
}

export interface UserFanTicket {
  UserId: string;
  FanTicket: string;
  MatchTotalScore: string;
  MatchRank: number;
}

export interface FanTicketRoomNoticeContent {
  UserFanTicketList: UserFanTicket[];
  TotalLinkMicFanTicket: string;
  MatchId: string;
  EventTime: string;
  FanTicketIconUrl: string;
  playId: string;
  playScene: PlayScene;
}

export interface LinkerAcceptNoticeContent {
  fromUserId: string;
  fromRoomId: string;
  toUserId: string;
}

export interface LinkerCancelContent {
  fromUserId: string;
  toUserId: string;
  cancelType: string;
  actionId: string;
}

export interface ListUser {
  user: User | undefined;
  linkmicId: string;
  linkmicIdStr: string;
  linkStatus: LinkmicRoleType;
  linkType: LinkType;
  userPosition: number;
  silenceStatus: LinkSilenceStatus;
  modifyTime: string;
  linkerId: string;
  roleType: LinkRoleType;
}

/** it is just empty */
export interface LinkerCloseContent {
}

export interface LinkerCreateContent {
  ownerId: string;
  ownerRoomId: string;
  /** Assuming this is LinkType enum */
  linkType: string;
}

export interface LinkerEnterContent {
  linkedUsersList: ListUser[];
  anchorMultiLiveEnum: LinkmicMultiLiveEnum;
  anchorSettingInfo: MultiLiveAnchorPanelSettings | undefined;
}

export interface LinkerInviteContent {
  fromUserId: string;
  fromRoomId: string;
  toRtcExtInfo: string;
  rtcJoinChannel: boolean;
  vendor: string;
  secFromUserId: string;
  toLinkmicIdStr: string;
  fromUser: User | undefined;
  requiredMicIdx: string;
  rtcExtInfoMap: { [key: string]: string };
  multiLiveLayoutEnable: LinkmicMultiLiveEnum;
  multiLiveSetting: MultiLiveAnchorPanelSettings | undefined;
  fromLinkmicIdStr: string;
  fromTopHostInfo: LinkerInviteContent_InviteTopHostInfo | undefined;
  actionId: string;
  linkedUsers: LinkerInviteContent_LinkmicUserInfo[];
  dialogInfo: LinkerInviteContent_PerceptionDialogInfo | undefined;
  punishEventInfo: PunishEventInfo | undefined;
  fromRoomAgeRestricted: number;
  abTestSetting: LinkerInviteContent_CohostABTestSetting[];
  linkerInviteMsgExtra: LinkerInviteContent_LinkerInviteMessageExtra | undefined;
}

export interface LinkerInviteContent_RtcExtInfoMapEntry {
  key: string;
  value: string;
}

export interface LinkerInviteContent_InviteTopHostInfo {
  rankType: string;
  topIndex: string;
}

export interface LinkerInviteContent_LinkmicUserInfo {
  userId: string;
  linkmicIdStr: string;
  roomId: string;
  linkedTime: string;
}

export interface LinkerInviteContent_PerceptionDialogInfo {
  iconType: PerceptionDialogIconType;
  title: Text | undefined;
  subTitle: Text | undefined;
  adviceActionText: Text | undefined;
  defaultActionText: Text | undefined;
  violationDetailUrl: string;
  scene: Scene;
  targetUserId: string;
  targetRoomId: string;
  countDownTime: string;
  showFeedback: boolean;
  feedbackOptions: LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption[];
  policyTip: string;
  appealPopup: number;
}

export interface LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption {
  id: string;
  contentKey: string;
}

export interface LinkerInviteContent_CohostABTestSetting {
  key: string;
  value: LinkerInviteContent_CohostABTestSetting_CohostABTestList | undefined;
}

export interface LinkerInviteContent_CohostABTestSetting_CohostABTestList {
  abTestList: LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest[];
}

export interface LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest {
  abTestType: CohostABTestType;
  group: string;
}

export interface LinkerInviteContent_LinkerInviteMessageExtra {
  matchType: number;
  inviteType: number;
  subType: number;
  theme: string;
  duration: number;
  layout: number;
  tips: string;
  inviterRivalExtra: LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra | undefined;
  otherRivalExtra: LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra[];
  topicInfo: CohostTopic | undefined;
  algoRequestId: string;
}

export interface LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra {
  textType: TextType;
  text: string;
  label: string;
  userCount: number;
  avatarThumb: Image | undefined;
  displayId: string;
  authenticationInfo: LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo | undefined;
  nickname: string;
  followStatus: string;
  mHashtag: LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag | undefined;
  userId: string;
  isBestTeammate: boolean;
  optPairInfo: LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo | undefined;
  followerCount: string;
}

export interface LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo {
  customVerify: string;
  enterpriseVerifyReason: string;
  authenticationBadge: Image | undefined;
}

export interface LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag {
  id: string;
  title: string;
  image: Image | undefined;
  namespace: HashtagNamespace;
}

export interface LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo {
  mappingId: string;
  displayUserList: LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser[];
  buttonNoticeType: OptPairStatus;
  expectedTimeSec: string;
  optPairType: string;
}

export interface LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser {
  user: User | undefined;
  roomId: string;
}

export interface CohostTopic {
  id: string;
  titleKey: string;
  titleText: string;
  liked: boolean;
  totalHeat: string;
  totalRivals: string;
  rivalsAvatar: Image[];
}

export interface LinkerKickOutContent {
  fromUserId: string;
  kickoutReason: KickoutReason;
}

export interface LinkerLeaveContent {
  userId: string;
  linkmicIdStr: string;
  sendLeaveUid: string;
  leaveReason: string;
}

/** Empty */
export interface LinkerLinkedListChangeContent {
}

/** Empty */
export interface CohostListChangeContent {
}

export interface LinkerListChangeContent {
  linkedUsers: ListUser[];
  appliedUsers: ListUser[];
  connectingUsers: ListUser[];
}

export interface LinkerMediaChangeContent {
  op: GuestMicCameraManageOp;
  toUserId: string;
  anchorId: string;
  roomId: string;
  changeScene: GuestMicCameraChangeScene;
  operatorInfo: LinkerMediaChangeContent_LinkerMediaChangeOperator | undefined;
}

export interface LinkerMediaChangeContent_LinkerMediaChangeOperator {
  userId: string;
  operatorType: LinkMicUserAdminType;
  nickName: string;
  displayId: string;
}

/** Empty */
export interface LinkerMicIdxUpdateContent {
}

export interface LinkerMuteContent {
  userId: string;
  status: MuteStatus;
}

export interface LinkerRandomMatchContent {
  user: User | undefined;
  roomId: string;
  inviteType: string;
  matchId: string;
  innerChannelId: string;
}

export interface LinkerReplyContent {
  fromUserId: string;
  fromRoomId: string;
  fromUserLinkmicInfo: LinkerReplyContent_LinkmicInfo | undefined;
  toUserId: string;
  toUserLinkmicInfo: LinkerReplyContent_LinkmicInfo | undefined;
  linkType: string;
  replyStatus: string;
  linkerSetting: LinkerSetting | undefined;
  fromUser: User | undefined;
  toUser: User | undefined;
}

export interface LinkerReplyContent_LinkmicInfo {
  accessKey: string;
  linkMicId: string;
  joinable: boolean;
  confluenceType: number;
  rtcExtInfo: string;
  rtcAppId: string;
  rtcAppSign: string;
  linkmicIdStr: string;
  vendor: string;
}

export interface LinkerSetting {
  MaxMemberLimit: string;
  LinkType: string;
  Scene: Scene;
  OwnerUserId: string;
  OwnerRoomId: string;
  Vendor: string;
}

export interface LinkerSysKickOutContent {
  userId: string;
  linkmicIdStr: string;
}

export interface LinkmicUserToastContent {
  userId: string;
  roomId: string;
  displayText: Text | undefined;
  leavedUserId: string;
}

export interface LinkerUpdateUserContent {
  fromUserId: string;
  toUserId: string;
  updateInfo: { [key: string]: string };
}

export interface LinkerUpdateUserContent_UpdateInfoEntry {
  key: string;
  value: string;
}

export interface LinkerUpdateUserSettingContent {
  multiLiveAnchorPanelSettings: MultiLiveAnchorPanelSettings | undefined;
}

/** Empty */
export interface LinkerWaitingListChangeContent {
}

export interface MultiLiveAnchorPanelSettings {
  userId: string;
  layout: string;
  fixMicNum: string;
  allowRequestFromUser: string;
  allowRequestFromFollowerOnly: string;
  applierSortSetting: LinkmicApplierSortSetting;
  applierSortGiftScoreThreshold: string;
  allowRequestFromFriends: number;
  allowRequestFromFollowers: number;
  allowRequestFromOthers: number;
  enableShowMultiGuestLayout: number;
}

export interface Player {
  roomId: string;
  userId: string;
}

export interface AllListUser {
  linkedList: LinkLayerListUser[];
  appliedList: LinkLayerListUser[];
  invitedList: LinkLayerListUser[];
  readyList: LinkLayerListUser[];
}

export interface LinkLayerListUser {
  user: User | undefined;
  linkmicId: string;
  pos: Position | undefined;
  linkedTimeNano: string;
  appVersion: string;
  magicNumber1: string;
}

export interface Position {
  type: number;
  link: LinkPosition | undefined;
}

export interface LinkPosition {
  position: number;
  opt: number;
}

export interface GroupPlayer {
  channelId: string;
  user: User | undefined;
}

export interface DSLConfig {
  sceneVersion: number;
  layoutId: string;
}

export interface GroupChannelAllUser {
  groupChannelId: string;
  userList: GroupChannelUser[];
  contentVersion: string;
}

export interface GroupChannelUser {
  channelId: string;
  status: GroupStatus;
  type: TextType;
  allUser: AllListUser | undefined;
  joinTime: string;
  linkedTime: string;
  ownerUser: GroupPlayer | undefined;
  groupLinkmicId: string;
}

export interface RTCExtraInfo {
  liveRtcEngineConfig: RTCExtraInfo_RTCEngineConfig | undefined;
  liveRtcVideoParamList: RTCExtraInfo_RTCLiveVideoParam[];
  rtcBitrateMap: RTCExtraInfo_RTCBitrateMap | undefined;
  rtcFps: number;
  rtcMixBase: RTCExtraInfo_RTCMixBase | undefined;
  byteRtcExtInfo: RTCExtraInfo_ByteRTCExtInfo | undefined;
  rtcInfoExtra: RTCExtraInfo_RTCInfoExtra | undefined;
  rtcBusinessId: string;
  rtcOther: RTCExtraInfo_RTCOther | undefined;
  interactClientType: number;
}

export interface RTCExtraInfo_RTCMixBase {
  bitrate: number;
}

export interface RTCExtraInfo_ByteRTCExtInfo {
  defaultSignaling: number;
}

export interface RTCExtraInfo_RTCInfoExtra {
  version: string;
}

export interface RTCExtraInfo_RTCOther {
  transCodingSecond: number;
}

export interface RTCExtraInfo_RTCEngineConfig {
  rtcAppId: string;
  rtcUserId: string;
  rtcToken: string;
  rtcChannelId: string;
}

export interface RTCExtraInfo_RTCLiveVideoParam {
  strategyId: number;
  params: RTCExtraInfo_RTCVideoParam | undefined;
}

export interface RTCExtraInfo_RTCVideoParam {
  width: number;
  height: number;
  fps: number;
  bitrateKbps: number;
}

export interface RTCExtraInfo_RTCBitrateMap {
  xx1: number;
  xx2: number;
  xx3: number;
  xx4: number;
}

export interface CreateChannelContent {
  owner: Player | undefined;
  ownerLinkMicId: string;
}

export interface ListChangeContent {
  listChangeType: number;
  userList: AllListUser | undefined;
  linkedUserUiPositions: string[];
  contentPos: ContentPosition[];
}

export interface ContentPosition {
  contentID: string;
  contentType: ContentPositionType;
  pos: MicPositionData | undefined;
  contentLinkmicID: string;
  startTimeNano: string;
}

export interface MicPositionData {
  type: number;
  linkPosition: LinkPosition | undefined;
}

export interface MultiLiveContent {
  applyBizContent: MultiLiveContent_ApplyBizContent | undefined;
  inviteBizContent: MultiLiveContent_InviteBizContent | undefined;
  replyBizContent: MultiLiveContent_ReplyBizContent | undefined;
  permitBizContent: MultiLiveContent_PermitBizContent | undefined;
  joinDirectBizContent: MultiLiveContent_JoinDirectBizContent | undefined;
  kickOutBizContent: MultiLiveContent_KickOutBizContent | undefined;
}

export interface MultiLiveContent_ApplyBizContent {
  user: User | undefined;
}

export interface MultiLiveContent_JoinDirectBizContent {
  replyImMsgId: string;
  outsideRoomInviteSource: MultiGuestOutsideRoomInviteSource;
}

export interface MultiLiveContent_InviteBizContent {
  anchorSettingInfo: MultiLiveAnchorPanelSettings | undefined;
  inviteSource: ContentInviteSource;
  operatorUserInfo: User | undefined;
  operatorLinkAdminType: LinkMicUserAdminType;
  inviteeUserInfo: User | undefined;
  shareRevenueSetting: LinkmicShareRevenueSetting;
}

export interface MultiLiveContent_ReplyBizContent {
  linkType: number;
  isTurnOffInvitation: number;
  replyUserInfo: User | undefined;
}

export interface MultiLiveContent_PermitBizContent {
  anchorSettingInfo: MultiLiveAnchorPanelSettings | undefined;
  expireTimestamp: string;
  operatorUserInfo: User | undefined;
  operatorLinkAdminType: LinkMicUserAdminType;
  linkUserType: LinkUserType;
}

export interface MultiLiveContent_KickOutBizContent {
  operatorUserInfo: User | undefined;
  operatorLinkAdminType: LinkMicUserAdminType;
  kickPlayerUserInfo: User | undefined;
}

export interface InviteContent {
  invitor: Player | undefined;
  inviteeRtcExtInfo: RTCExtraInfo | undefined;
  invitorLinkMicId: string;
  inviteeLinkMicId: string;
  isOwner: boolean;
  pos: Position | undefined;
  dsl: DSLConfig | undefined;
  invitee: User | undefined;
  operator: User | undefined;
}

/**
 * @ApplyContent
 * proto.webcast.im
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface ApplyContent {
  applier: Player | undefined;
  applierLinkMicId: string;
}

/**
 * @PermitApplyContent
 * proto.webcast.im
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface PermitApplyContent {
  permiter: Player | undefined;
  permiterLinkMicId: string;
  applierPos:
    | Position
    | undefined;
  /** Enum */
  replyStatus: ReplyStatus;
  dsl: DSLConfig | undefined;
  applier: User | undefined;
  operator: User | undefined;
  applierLinkMicId: string;
}

/**
 * @ReplyInviteContent
 * proto.webcast.im
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface ReplyInviteContent {
  invitee: Player | undefined;
  replyStatus: ReplyStatus;
  inviteeLinkMicId: string;
  inviteePos: Position | undefined;
  inviteOperatorUser: Player | undefined;
  linkedUserUiPositions: string[];
  uiPos: PosIdentity[];
}

/**
 * @KickOutContent
 * proto.webcast.im
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface KickOutContent {
  offliner: Player | undefined;
  kickoutReason: KickoutReason;
  linkedUserUiPositions: string[];
  uiPos: PosIdentity[];
}

export interface PosIdentity {
  type: PosIdentityType;
  value: string;
}

/**
 * @CancelApplyContent
 * proto.webcast.im
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface CancelApplyContent {
  applier: Player | undefined;
  applierLinkMicId: string;
}

/**
 * @CancelInviteContent
 * proto.webcast.im
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface CancelInviteContent {
  invitor: Player | undefined;
  invitorLinkMicId: string;
  inviteeLinkMicId: string;
  inviteSeqId: string;
  invitee: Player | undefined;
}

/**
 * @LeaveContent
 * proto.webcast.im
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface LeaveContent {
  leaver: Player | undefined;
  leaveReason: string;
  linkedUserUiPositions: string[];
  uiPos: PosIdentity[];
}

/**
 * @FinishChannelContent
 * proto.webcast.im
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface FinishChannelContent {
  owner: Player | undefined;
  finishReason: string;
}

/**
 * @JoinDirectContent
 * proto.webcast.im
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface JoinDirectContent {
  joiner: LinkLayerListUser | undefined;
  allUsers: AllListUser | undefined;
}

/**
 * @LeaveJoinGroupContent
 * proto.webcast.im
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface LeaveJoinGroupContent {
  operator: GroupPlayer | undefined;
  groupChannelId: string;
  leaveSource: string;
  linkedUserUiPositions: string[];
}

/**
 * @PermitJoinGroupContent
 * proto.webcast.im
 */
export interface PermitJoinGroupContent {
  approver: GroupPlayer | undefined;
  agreeStatus: AgreeStatus;
  type: JoinType;
  groupExtInfoList: RTCExtraInfo[];
  groupUser: GroupChannelAllUser | undefined;
  migrationDetails: MigrationDetails | undefined;
  linkedUserUiPositions: string[];
}

export interface MigrationDetails {
  isMigrate: boolean;
  sourceGroupChannelId: string;
  targetGroupChannelId: string;
}

/**
 * @CancelJoinGroupContent
 * proto.webcast.im
 */
export interface CancelJoinGroupContent {
  leaverList: GroupPlayer[];
  operator: GroupPlayer | undefined;
  type: JoinType;
  groupUser: GroupChannelAllUser | undefined;
}

export interface P2PGroupChangeContent {
  groupExtInfoList: RTCExtraInfo[];
  groupUser: GroupChannelAllUser | undefined;
  migrationDetails: MigrationDetails | undefined;
  contentPos: ContentPosition[];
}

export interface GroupChangeContent {
  groupUser: GroupChannelAllUser | undefined;
  linkedUserUiPositions: string[];
}

export interface BusinessContent {
  overLength: string;
  multiLiveContent: MultiLiveContent | undefined;
  cohostContent: BusinessContent_CohostContent | undefined;
}

export interface BusinessContent_CohostContent {
  joinGroupBizContent: BusinessContent_JoinGroupBizContent | undefined;
  permitJoinGroupBizContent: BusinessContent_PermitJoinGroupBizContent | undefined;
  listChangeBizContent: BusinessContent_ListChangeBizContent | undefined;
}

export interface BusinessContent_PermitJoinGroupBizContent {
  replyStatus: ReplyStatus;
  sourceType: SourceType;
}

export interface BusinessContent_ListChangeBizContent {
  userInfos: { [key: string]: BusinessContent_CohostUserInfo };
  waitingUsers: BusinessContent_ListChangeBizContent_VirtualWaitingUser[];
}

export interface BusinessContent_ListChangeBizContent_UserInfosEntry {
  key: string;
  value: BusinessContent_CohostUserInfo | undefined;
}

export interface BusinessContent_ListChangeBizContent_VirtualWaitingUser {
  userId: string;
  timestamp: string;
  avatars: Image[];
}

export interface BusinessContent_CohostUserInfo {
  permissionType: string;
  sourceType: SourceType;
  isLowVersion: boolean;
  bestTeammateUid: string;
  hasTopicPerm: boolean;
  streamConfig: BusinessContent_CohostUserInfo_CohostStreamConfig | undefined;
  inDifferentInviteTypeControlGroup: boolean;
  nickname: string;
  displayId: string;
  avatarThumb: Image | undefined;
  followStatus: string;
  userIdStr: string;
}

export interface BusinessContent_CohostUserInfo_CohostStreamConfig {
  screenShareStreamId: string;
}

export interface BusinessContent_JoinGroupBizContent {
  fromRoomAgeRestricted: number;
  fromTag: BusinessContent_Tag | undefined;
  dialog: BusinessContent_PerceptionDialogInfo | undefined;
  punishInfo: PunishEventInfo | undefined;
  topicInfo: CohostTopic | undefined;
  algoRequestId: string;
  cohostLayoutMode: CohostLayoutMode;
  tag: BusinessContent_JoinGroupBizContent_TagV2 | undefined;
  gameTag: BusinessContent_JoinGroupBizContent_RivalsGameTag | undefined;
  newUserEducation: string;
  joinGroupMsgExtra: BusinessContent_JoinGroupMessageExtra | undefined;
}

export interface BusinessContent_JoinGroupBizContent_RivalsGameTag {
  tagId: string;
  tagDisplayText: string;
}

export interface BusinessContent_JoinGroupBizContent_TagV2 {
  tagClassification: TagClassification;
  tagType: number;
  tagValue: string;
  starlingKey: string;
  secondDegreeRelationContent: BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent | undefined;
  cohostHistoryDay: string;
  similarInterestContent: BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent | undefined;
}

export interface BusinessContent_JoinGroupBizContent_TagV2_UserInfo {
  userId: string;
  nickName: string;
  avatarThumb: Image | undefined;
}

export interface BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent {
  relatedUsers: BusinessContent_JoinGroupBizContent_TagV2_UserInfo[];
  totalRelatedUserCnt: string;
}

export interface BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent {
  contentId: string;
  displayText: string;
}

export interface BusinessContent_Tag {
  tagType: number;
  tagValue: string;
  tagText: string;
}

export interface BusinessContent_PerceptionDialogInfo {
  /** @warning Enum not found, should be IconType */
  iconType: string;
  title: Text | undefined;
  subTitle: Text | undefined;
  adviceActionText: Text | undefined;
  defaultActionText: Text | undefined;
  violationDetailUrl: string;
  scene: number;
  targetUserId: string;
  targetRoomId: string;
  countDownTime: string;
  showFeedback: boolean;
  feedbackOptionsList: BusinessContent_PerceptionFeedbackOption[];
  policyTip: string;
}

export interface BusinessContent_PerceptionFeedbackOption {
  id: string;
  contentKey: string;
}

export interface BusinessContent_JoinGroupMessageExtra {
  sourceType: string;
  extra: BusinessContent_JoinGroupMessageExtra_RivalExtra | undefined;
  otherUsersList: BusinessContent_JoinGroupMessageExtra_RivalExtra[];
}

/**
 * @RivalExtra
 * proto.webcast.im.JoinGroupMessageExtra
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface BusinessContent_JoinGroupMessageExtra_RivalExtra {
  userCount: string;
  avatarThumb: Image | undefined;
  displayId: string;
  authenticationInfo: BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo | undefined;
  nickname: string;
  followStatus: string;
  hashtag: BusinessContent_Hashtag | undefined;
  topHostInfo: BusinessContent_TopHostInfo | undefined;
  userId: string;
  isBestTeammate: boolean;
}

export interface BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo {
  customVerify: string;
  enterpriseVerifyReason: string;
  authenticationBadge: Image | undefined;
}

export interface BusinessContent_Hashtag {
  id: string;
  title: string;
  image: Image | undefined;
  namespace: HashtagNamespace;
}

export interface BusinessContent_TopHostInfo {
  rankType: string;
  topIndex: string;
}

export interface JoinGroupContent {
  groupUser: GroupChannelAllUser | undefined;
  joinUser: GroupPlayer | undefined;
  type: JoinType;
  groupExtInfo: RTCExtraInfo[];
}

export interface PrivilegeLogExtra {
  dataVersion: string;
  privilegeId: string;
  privilegeVersion: string;
  privilegeOrderId: string;
  level: string;
}

export interface FontStyle {
  fontSize: number;
  fontWidth: number;
  fontColor: string;
  borderColor: string;
}

export interface UserHonor {
  totalDiamond: string;
  diamondIcon: Image | undefined;
  currentHonorName: string;
  currentHonorIcon: Image | undefined;
  nextHonorName: string;
  level: number;
  nextHonorIcon: Image | undefined;
  currentDiamond: string;
  thisGradeMinDiamond: string;
  thisGradeMaxDiamond: string;
  gradeDescribe: string;
  gradeIconList: GradeIcon[];
  screenChatType: string;
  imIcon: Image | undefined;
  imIconWithLevel: Image | undefined;
  liveIcon: Image | undefined;
  newImIconWithLevel: Image | undefined;
  newLiveIcon: Image | undefined;
  upgradeNeedConsume: string;
  nextPrivileges: string;
  profileDialogBg: Image | undefined;
  profileDialogBackBg: Image | undefined;
  score: string;
  gradeBanner: string;
}

/**
 * @GradeIcon
 * proto.webcast.data.User.PayGrade
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface GradeIcon {
  icon: Image | undefined;
  iconDiamond: string;
  level: string;
  levelStr: string;
}

export interface BorderInfo {
  icon: Image | undefined;
  level: string;
  source: string;
  profileDecorationRibbon: Image | undefined;
  borderLogExtra: PrivilegeLogExtra | undefined;
  ribbonLogExtra: PrivilegeLogExtra | undefined;
  avatarBackgroundColor: string;
  avatarBackgroundBorderColor: string;
}

export interface FansClubMember {
  data: FansClubData | undefined;
  preferData: { [key: number]: FansClubData };
}

export interface FansClubMember_PreferDataEntry {
  key: number;
  value: FansClubData | undefined;
}

export interface FansClubData {
  clubName: string;
  level: number;
  userFansClubStatus: number;
  badge: FansClubData_UserBadge | undefined;
  availableGiftIds: string[];
  anchorId: string;
}

export interface FansClubData_UserBadge {
  icons: { [key: number]: Image };
  title: string;
}

export interface FansClubData_UserBadge_IconsEntry {
  key: number;
  value: Image | undefined;
}

export interface Author {
  videoTotalCount: string;
  videoTotalPlayCount: string;
  videoTotalFavoriteCount: string;
}

export interface PublicAreaCommon {
  userLabel: Image | undefined;
  userConsumeInRoom: string;
}

export interface PublicAreaMessageCommon {
  scrollGapCount: string;
  anchorScrollGapCount: string;
  releaseToScrollArea: boolean;
  anchorReleaseToScrollArea: boolean;
  isAnchorMarked: boolean;
  creatorSuccessInfo: PublicAreaMessageCommon_CreatorSuccessInfo | undefined;
  portraitInfo: PublicAreaMessageCommon_PortraitInfo | undefined;
  userInteractionInfo: PublicAreaMessageCommon_UserInteractionInfo | undefined;
  adminFoldType: string;
}

export interface PublicAreaMessageCommon_TagItem {
  tagType: TagType;
  tagText: Text | undefined;
}

export interface PublicAreaMessageCommon_Topic {
  topicActionType: TopicActionType;
  topicText: Text | undefined;
  topicTips: Text | undefined;
}

export interface PublicAreaMessageCommon_CreatorSuccessInfo {
  tags: PublicAreaMessageCommon_TagItem[];
  topic: PublicAreaMessageCommon_Topic | undefined;
}

export interface PublicAreaMessageCommon_UserMetrics {
  type: UserMetricsType;
  metricsValue: string;
}

export interface PublicAreaMessageCommon_PortraitTag {
  tagId: string;
  priority: string;
  showValue: string;
  showArgs: string;
}

export interface PublicAreaMessageCommon_PortraitInfo {
  userMetrics: PublicAreaMessageCommon_UserMetrics[];
  portraitTag: PublicAreaMessageCommon_PortraitTag[];
}

export interface PublicAreaMessageCommon_UserInteractionInfo {
  likeCnt: string;
  commentCnt: string;
  shareCnt: string;
}

export interface GiftModeMeta {
  giftId: string;
  giftNameKey: string;
  giftIconImage: Image | undefined;
  giftModeDesc: Text | undefined;
}

export interface BattleTeamUser {
  userId: string;
  score: string;
  userIdStr: string;
}

export interface BattleSetting {
  battleId: string;
  startTimeMs: string;
  duration: number;
  channelId: string;
  status: number;
  inviteType: BattleInviteType;
  giftModeMeta: GiftModeMeta | undefined;
  battleType: BattleType;
  extraDurationSecond: string;
  endTimeMs: string;
}

export interface BattleTeamUserArmies {
  teamId: string;
  teamUsers: BattleTeamUser[];
  teamTotalScore: string;
  userArmies: BattleUserArmies | undefined;
  hostRank: string;
}

export interface BattleUserArmies {
  userArmy: BattleUserArmy[];
  hostScore: string;
  anchorIdStr: string;
}

export interface BattleUserArmy {
  userId: string;
  score: string;
  nickname: string;
  avatarThumb: Image | undefined;
  diamondScore: string;
  userIdStr: string;
}

export interface HighScoreControlCfg {
  normalControlApplied: boolean;
  threshold: string;
  originDisplayToUserList: string[];
}

function createBaseCommonMessageData(): CommonMessageData {
  return {
    method: "",
    msgId: "0",
    roomId: "0",
    createTime: "0",
    monitor: 0,
    isShowMsg: false,
    describe: "",
    displayText: undefined,
    foldType: "0",
    anchorFoldType: "0",
    priorityScore: "0",
    logId: "",
    msgProcessFilterK: "",
    msgProcessFilterV: "",
    fromIdc: "",
    toIdc: "",
    filterMsgTagsList: [],
    sei: undefined,
    dependRootId: undefined,
    dependId: undefined,
    anchorPriorityScore: "0",
    roomMessageHeatLevel: "0",
    foldTypeForWeb: "0",
    anchorFoldTypeForWeb: "0",
    clientSendTime: "0",
    dispatchStrategy: 0,
  };
}

export const CommonMessageData: MessageFns<CommonMessageData> = {
  encode(message: CommonMessageData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.method !== "") {
      writer.uint32(10).string(message.method);
    }
    if (message.msgId !== "0") {
      writer.uint32(16).int64(message.msgId);
    }
    if (message.roomId !== "0") {
      writer.uint32(24).int64(message.roomId);
    }
    if (message.createTime !== "0") {
      writer.uint32(32).int64(message.createTime);
    }
    if (message.monitor !== 0) {
      writer.uint32(40).int32(message.monitor);
    }
    if (message.isShowMsg !== false) {
      writer.uint32(48).bool(message.isShowMsg);
    }
    if (message.describe !== "") {
      writer.uint32(58).string(message.describe);
    }
    if (message.displayText !== undefined) {
      Text.encode(message.displayText, writer.uint32(66).fork()).join();
    }
    if (message.foldType !== "0") {
      writer.uint32(72).int64(message.foldType);
    }
    if (message.anchorFoldType !== "0") {
      writer.uint32(80).int64(message.anchorFoldType);
    }
    if (message.priorityScore !== "0") {
      writer.uint32(88).int64(message.priorityScore);
    }
    if (message.logId !== "") {
      writer.uint32(98).string(message.logId);
    }
    if (message.msgProcessFilterK !== "") {
      writer.uint32(106).string(message.msgProcessFilterK);
    }
    if (message.msgProcessFilterV !== "") {
      writer.uint32(114).string(message.msgProcessFilterV);
    }
    if (message.fromIdc !== "") {
      writer.uint32(122).string(message.fromIdc);
    }
    if (message.toIdc !== "") {
      writer.uint32(130).string(message.toIdc);
    }
    for (const v of message.filterMsgTagsList) {
      writer.uint32(138).string(v!);
    }
    if (message.sei !== undefined) {
      CommonMessageData_LiveMessageSEI.encode(message.sei, writer.uint32(146).fork()).join();
    }
    if (message.dependRootId !== undefined) {
      CommonMessageData_LiveMessageID.encode(message.dependRootId, writer.uint32(154).fork()).join();
    }
    if (message.dependId !== undefined) {
      CommonMessageData_LiveMessageID.encode(message.dependId, writer.uint32(162).fork()).join();
    }
    if (message.anchorPriorityScore !== "0") {
      writer.uint32(168).int64(message.anchorPriorityScore);
    }
    if (message.roomMessageHeatLevel !== "0") {
      writer.uint32(176).int64(message.roomMessageHeatLevel);
    }
    if (message.foldTypeForWeb !== "0") {
      writer.uint32(184).int64(message.foldTypeForWeb);
    }
    if (message.anchorFoldTypeForWeb !== "0") {
      writer.uint32(192).int64(message.anchorFoldTypeForWeb);
    }
    if (message.clientSendTime !== "0") {
      writer.uint32(200).int64(message.clientSendTime);
    }
    if (message.dispatchStrategy !== 0) {
      writer.uint32(208).int32(message.dispatchStrategy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommonMessageData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommonMessageData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.msgId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.roomId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.createTime = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.monitor = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isShowMsg = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.describe = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.displayText = Text.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.foldType = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.anchorFoldType = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.priorityScore = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.logId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.msgProcessFilterK = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.msgProcessFilterV = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.fromIdc = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.toIdc = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.filterMsgTagsList.push(reader.string());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.sei = CommonMessageData_LiveMessageSEI.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.dependRootId = CommonMessageData_LiveMessageID.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.dependId = CommonMessageData_LiveMessageID.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.anchorPriorityScore = reader.int64().toString();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.roomMessageHeatLevel = reader.int64().toString();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.foldTypeForWeb = reader.int64().toString();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.anchorFoldTypeForWeb = reader.int64().toString();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.clientSendTime = reader.int64().toString();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.dispatchStrategy = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<CommonMessageData>, I>>(base?: I): CommonMessageData {
    return CommonMessageData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommonMessageData>, I>>(object: I): CommonMessageData {
    const message = createBaseCommonMessageData();
    message.method = object.method ?? "";
    message.msgId = object.msgId ?? "0";
    message.roomId = object.roomId ?? "0";
    message.createTime = object.createTime ?? "0";
    message.monitor = object.monitor ?? 0;
    message.isShowMsg = object.isShowMsg ?? false;
    message.describe = object.describe ?? "";
    message.displayText = (object.displayText !== undefined && object.displayText !== null)
      ? Text.fromPartial(object.displayText)
      : undefined;
    message.foldType = object.foldType ?? "0";
    message.anchorFoldType = object.anchorFoldType ?? "0";
    message.priorityScore = object.priorityScore ?? "0";
    message.logId = object.logId ?? "";
    message.msgProcessFilterK = object.msgProcessFilterK ?? "";
    message.msgProcessFilterV = object.msgProcessFilterV ?? "";
    message.fromIdc = object.fromIdc ?? "";
    message.toIdc = object.toIdc ?? "";
    message.filterMsgTagsList = object.filterMsgTagsList?.map((e) => e) || [];
    message.sei = (object.sei !== undefined && object.sei !== null)
      ? CommonMessageData_LiveMessageSEI.fromPartial(object.sei)
      : undefined;
    message.dependRootId = (object.dependRootId !== undefined && object.dependRootId !== null)
      ? CommonMessageData_LiveMessageID.fromPartial(object.dependRootId)
      : undefined;
    message.dependId = (object.dependId !== undefined && object.dependId !== null)
      ? CommonMessageData_LiveMessageID.fromPartial(object.dependId)
      : undefined;
    message.anchorPriorityScore = object.anchorPriorityScore ?? "0";
    message.roomMessageHeatLevel = object.roomMessageHeatLevel ?? "0";
    message.foldTypeForWeb = object.foldTypeForWeb ?? "0";
    message.anchorFoldTypeForWeb = object.anchorFoldTypeForWeb ?? "0";
    message.clientSendTime = object.clientSendTime ?? "0";
    message.dispatchStrategy = object.dispatchStrategy ?? 0;
    return message;
  },
};

function createBaseCommonMessageData_LiveMessageSEI(): CommonMessageData_LiveMessageSEI {
  return { uniqueId: undefined, timestamp: "0" };
}

export const CommonMessageData_LiveMessageSEI: MessageFns<CommonMessageData_LiveMessageSEI> = {
  encode(message: CommonMessageData_LiveMessageSEI, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uniqueId !== undefined) {
      CommonMessageData_LiveMessageID.encode(message.uniqueId, writer.uint32(10).fork()).join();
    }
    if (message.timestamp !== "0") {
      writer.uint32(16).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommonMessageData_LiveMessageSEI {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommonMessageData_LiveMessageSEI();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uniqueId = CommonMessageData_LiveMessageID.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<CommonMessageData_LiveMessageSEI>, I>>(
    base?: I,
  ): CommonMessageData_LiveMessageSEI {
    return CommonMessageData_LiveMessageSEI.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommonMessageData_LiveMessageSEI>, I>>(
    object: I,
  ): CommonMessageData_LiveMessageSEI {
    const message = createBaseCommonMessageData_LiveMessageSEI();
    message.uniqueId = (object.uniqueId !== undefined && object.uniqueId !== null)
      ? CommonMessageData_LiveMessageID.fromPartial(object.uniqueId)
      : undefined;
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseCommonMessageData_LiveMessageID(): CommonMessageData_LiveMessageID {
  return { primaryId: "", messageScene: "" };
}

export const CommonMessageData_LiveMessageID: MessageFns<CommonMessageData_LiveMessageID> = {
  encode(message: CommonMessageData_LiveMessageID, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.primaryId !== "") {
      writer.uint32(10).string(message.primaryId);
    }
    if (message.messageScene !== "") {
      writer.uint32(18).string(message.messageScene);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommonMessageData_LiveMessageID {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommonMessageData_LiveMessageID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.primaryId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageScene = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<CommonMessageData_LiveMessageID>, I>>(base?: I): CommonMessageData_LiveMessageID {
    return CommonMessageData_LiveMessageID.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommonMessageData_LiveMessageID>, I>>(
    object: I,
  ): CommonMessageData_LiveMessageID {
    const message = createBaseCommonMessageData_LiveMessageID();
    message.primaryId = object.primaryId ?? "";
    message.messageScene = object.messageScene ?? "";
    return message;
  },
};

function createBaseText(): Text {
  return { displayType: "", defaultPattern: "", defaultFormat: undefined, piecesList: [] };
}

export const Text: MessageFns<Text> = {
  encode(message: Text, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayType !== "") {
      writer.uint32(10).string(message.displayType);
    }
    if (message.defaultPattern !== "") {
      writer.uint32(18).string(message.defaultPattern);
    }
    if (message.defaultFormat !== undefined) {
      Text_TextFormat.encode(message.defaultFormat, writer.uint32(26).fork()).join();
    }
    for (const v of message.piecesList) {
      Text_TextPiece.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Text {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.defaultPattern = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.defaultFormat = Text_TextFormat.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.piecesList.push(Text_TextPiece.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Text>, I>>(base?: I): Text {
    return Text.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Text>, I>>(object: I): Text {
    const message = createBaseText();
    message.displayType = object.displayType ?? "";
    message.defaultPattern = object.defaultPattern ?? "";
    message.defaultFormat = (object.defaultFormat !== undefined && object.defaultFormat !== null)
      ? Text_TextFormat.fromPartial(object.defaultFormat)
      : undefined;
    message.piecesList = object.piecesList?.map((e) => Text_TextPiece.fromPartial(e)) || [];
    return message;
  },
};

function createBaseText_TextPiece(): Text_TextPiece {
  return {
    type: 0,
    format: undefined,
    stringValue: "",
    userValue: undefined,
    giftValue: undefined,
    patternRefValue: undefined,
  };
}

export const Text_TextPiece: MessageFns<Text_TextPiece> = {
  encode(message: Text_TextPiece, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.format !== undefined) {
      Text_TextFormat.encode(message.format, writer.uint32(18).fork()).join();
    }
    if (message.stringValue !== "") {
      writer.uint32(90).string(message.stringValue);
    }
    if (message.userValue !== undefined) {
      Text_TextPieceUser.encode(message.userValue, writer.uint32(170).fork()).join();
    }
    if (message.giftValue !== undefined) {
      Text_TextPieceGift.encode(message.giftValue, writer.uint32(178).fork()).join();
    }
    if (message.patternRefValue !== undefined) {
      Text_TextPiecePatternRef.encode(message.patternRefValue, writer.uint32(194).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Text_TextPiece {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseText_TextPiece();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.format = Text_TextFormat.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.userValue = Text_TextPieceUser.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.giftValue = Text_TextPieceGift.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.patternRefValue = Text_TextPiecePatternRef.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Text_TextPiece>, I>>(base?: I): Text_TextPiece {
    return Text_TextPiece.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Text_TextPiece>, I>>(object: I): Text_TextPiece {
    const message = createBaseText_TextPiece();
    message.type = object.type ?? 0;
    message.format = (object.format !== undefined && object.format !== null)
      ? Text_TextFormat.fromPartial(object.format)
      : undefined;
    message.stringValue = object.stringValue ?? "";
    message.userValue = (object.userValue !== undefined && object.userValue !== null)
      ? Text_TextPieceUser.fromPartial(object.userValue)
      : undefined;
    message.giftValue = (object.giftValue !== undefined && object.giftValue !== null)
      ? Text_TextPieceGift.fromPartial(object.giftValue)
      : undefined;
    message.patternRefValue = (object.patternRefValue !== undefined && object.patternRefValue !== null)
      ? Text_TextPiecePatternRef.fromPartial(object.patternRefValue)
      : undefined;
    return message;
  },
};

function createBaseText_TextFormat(): Text_TextFormat {
  return {
    color: "",
    bold: false,
    italic: false,
    weight: 0,
    italicAngle: 0,
    fontSize: 0,
    useHeighLightColor: false,
    useRemoteClor: false,
  };
}

export const Text_TextFormat: MessageFns<Text_TextFormat> = {
  encode(message: Text_TextFormat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.color !== "") {
      writer.uint32(10).string(message.color);
    }
    if (message.bold !== false) {
      writer.uint32(16).bool(message.bold);
    }
    if (message.italic !== false) {
      writer.uint32(24).bool(message.italic);
    }
    if (message.weight !== 0) {
      writer.uint32(32).int32(message.weight);
    }
    if (message.italicAngle !== 0) {
      writer.uint32(40).int32(message.italicAngle);
    }
    if (message.fontSize !== 0) {
      writer.uint32(48).int32(message.fontSize);
    }
    if (message.useHeighLightColor !== false) {
      writer.uint32(56).bool(message.useHeighLightColor);
    }
    if (message.useRemoteClor !== false) {
      writer.uint32(64).bool(message.useRemoteClor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Text_TextFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseText_TextFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.color = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.bold = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.italic = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.weight = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.italicAngle = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.fontSize = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.useHeighLightColor = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.useRemoteClor = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Text_TextFormat>, I>>(base?: I): Text_TextFormat {
    return Text_TextFormat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Text_TextFormat>, I>>(object: I): Text_TextFormat {
    const message = createBaseText_TextFormat();
    message.color = object.color ?? "";
    message.bold = object.bold ?? false;
    message.italic = object.italic ?? false;
    message.weight = object.weight ?? 0;
    message.italicAngle = object.italicAngle ?? 0;
    message.fontSize = object.fontSize ?? 0;
    message.useHeighLightColor = object.useHeighLightColor ?? false;
    message.useRemoteClor = object.useRemoteClor ?? false;
    return message;
  },
};

function createBaseText_TextPieceGift(): Text_TextPieceGift {
  return { giftId: 0, nameRef: undefined, showType: 0, colorId: "0" };
}

export const Text_TextPieceGift: MessageFns<Text_TextPieceGift> = {
  encode(message: Text_TextPieceGift, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftId !== 0) {
      writer.uint32(8).int32(message.giftId);
    }
    if (message.nameRef !== undefined) {
      Text_PatternRef.encode(message.nameRef, writer.uint32(18).fork()).join();
    }
    if (message.showType !== 0) {
      writer.uint32(24).int32(message.showType);
    }
    if (message.colorId !== "0") {
      writer.uint32(32).int64(message.colorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Text_TextPieceGift {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseText_TextPieceGift();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.giftId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nameRef = Text_PatternRef.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.showType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.colorId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Text_TextPieceGift>, I>>(base?: I): Text_TextPieceGift {
    return Text_TextPieceGift.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Text_TextPieceGift>, I>>(object: I): Text_TextPieceGift {
    const message = createBaseText_TextPieceGift();
    message.giftId = object.giftId ?? 0;
    message.nameRef = (object.nameRef !== undefined && object.nameRef !== null)
      ? Text_PatternRef.fromPartial(object.nameRef)
      : undefined;
    message.showType = object.showType ?? 0;
    message.colorId = object.colorId ?? "0";
    return message;
  },
};

function createBaseText_TextPiecePatternRef(): Text_TextPiecePatternRef {
  return { key: "", defaultPattern: "" };
}

export const Text_TextPiecePatternRef: MessageFns<Text_TextPiecePatternRef> = {
  encode(message: Text_TextPiecePatternRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.defaultPattern !== "") {
      writer.uint32(18).string(message.defaultPattern);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Text_TextPiecePatternRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseText_TextPiecePatternRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.defaultPattern = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Text_TextPiecePatternRef>, I>>(base?: I): Text_TextPiecePatternRef {
    return Text_TextPiecePatternRef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Text_TextPiecePatternRef>, I>>(object: I): Text_TextPiecePatternRef {
    const message = createBaseText_TextPiecePatternRef();
    message.key = object.key ?? "";
    message.defaultPattern = object.defaultPattern ?? "";
    return message;
  },
};

function createBaseText_TextPieceUser(): Text_TextPieceUser {
  return { user: undefined, withColon: false };
}

export const Text_TextPieceUser: MessageFns<Text_TextPieceUser> = {
  encode(message: Text_TextPieceUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.withColon !== false) {
      writer.uint32(16).bool(message.withColon);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Text_TextPieceUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseText_TextPieceUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.withColon = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Text_TextPieceUser>, I>>(base?: I): Text_TextPieceUser {
    return Text_TextPieceUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Text_TextPieceUser>, I>>(object: I): Text_TextPieceUser {
    const message = createBaseText_TextPieceUser();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.withColon = object.withColon ?? false;
    return message;
  },
};

function createBaseText_PatternRef(): Text_PatternRef {
  return { key: "", defaultPattern: "" };
}

export const Text_PatternRef: MessageFns<Text_PatternRef> = {
  encode(message: Text_PatternRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.defaultPattern !== "") {
      writer.uint32(18).string(message.defaultPattern);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Text_PatternRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseText_PatternRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.defaultPattern = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Text_PatternRef>, I>>(base?: I): Text_PatternRef {
    return Text_PatternRef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Text_PatternRef>, I>>(object: I): Text_PatternRef {
    const message = createBaseText_PatternRef();
    message.key = object.key ?? "";
    message.defaultPattern = object.defaultPattern ?? "";
    return message;
  },
};

function createBaseImage(): Image {
  return {
    url: [],
    mUri: "",
    height: 0,
    width: 0,
    avgColor: "",
    imageType: 0,
    schema: "",
    content: undefined,
    isAnimated: false,
  };
}

export const Image: MessageFns<Image> = {
  encode(message: Image, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.url) {
      writer.uint32(10).string(v!);
    }
    if (message.mUri !== "") {
      writer.uint32(18).string(message.mUri);
    }
    if (message.height !== 0) {
      writer.uint32(24).int32(message.height);
    }
    if (message.width !== 0) {
      writer.uint32(32).int32(message.width);
    }
    if (message.avgColor !== "") {
      writer.uint32(42).string(message.avgColor);
    }
    if (message.imageType !== 0) {
      writer.uint32(48).int32(message.imageType);
    }
    if (message.schema !== "") {
      writer.uint32(58).string(message.schema);
    }
    if (message.content !== undefined) {
      Image_Content.encode(message.content, writer.uint32(66).fork()).join();
    }
    if (message.isAnimated !== false) {
      writer.uint32(72).bool(message.isAnimated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Image {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mUri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.avgColor = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.imageType = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.content = Image_Content.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isAnimated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Image>, I>>(base?: I): Image {
    return Image.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Image>, I>>(object: I): Image {
    const message = createBaseImage();
    message.url = object.url?.map((e) => e) || [];
    message.mUri = object.mUri ?? "";
    message.height = object.height ?? 0;
    message.width = object.width ?? 0;
    message.avgColor = object.avgColor ?? "";
    message.imageType = object.imageType ?? 0;
    message.schema = object.schema ?? "";
    message.content = (object.content !== undefined && object.content !== null)
      ? Image_Content.fromPartial(object.content)
      : undefined;
    message.isAnimated = object.isAnimated ?? false;
    return message;
  },
};

function createBaseImage_Content(): Image_Content {
  return { name: "", fontColor: "", level: "0" };
}

export const Image_Content: MessageFns<Image_Content> = {
  encode(message: Image_Content, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.fontColor !== "") {
      writer.uint32(18).string(message.fontColor);
    }
    if (message.level !== "0") {
      writer.uint32(24).int64(message.level);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Image_Content {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImage_Content();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fontColor = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.level = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Image_Content>, I>>(base?: I): Image_Content {
    return Image_Content.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Image_Content>, I>>(object: I): Image_Content {
    const message = createBaseImage_Content();
    message.name = object.name ?? "";
    message.fontColor = object.fontColor ?? "";
    message.level = object.level ?? "0";
    return message;
  },
};

function createBaseBadgeStruct(): BadgeStruct {
  return {
    badgeDisplayType: 0,
    badgePriorityType: 0,
    badgeScene: 0,
    position: 0,
    displayStatus: 0,
    greyedByClient: "0",
    exhibitionType: 0,
    schemaUrl: "",
    display: false,
    logExtra: undefined,
    image: undefined,
    text: undefined,
    str: undefined,
    combine: undefined,
    isCustomized: false,
  };
}

export const BadgeStruct: MessageFns<BadgeStruct> = {
  encode(message: BadgeStruct, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.badgeDisplayType !== 0) {
      writer.uint32(8).int32(message.badgeDisplayType);
    }
    if (message.badgePriorityType !== 0) {
      writer.uint32(16).int32(message.badgePriorityType);
    }
    if (message.badgeScene !== 0) {
      writer.uint32(24).int32(message.badgeScene);
    }
    if (message.position !== 0) {
      writer.uint32(32).int32(message.position);
    }
    if (message.displayStatus !== 0) {
      writer.uint32(40).int32(message.displayStatus);
    }
    if (message.greyedByClient !== "0") {
      writer.uint32(48).int64(message.greyedByClient);
    }
    if (message.exhibitionType !== 0) {
      writer.uint32(56).int32(message.exhibitionType);
    }
    if (message.schemaUrl !== "") {
      writer.uint32(82).string(message.schemaUrl);
    }
    if (message.display !== false) {
      writer.uint32(88).bool(message.display);
    }
    if (message.logExtra !== undefined) {
      PrivilegeLogExtra.encode(message.logExtra, writer.uint32(98).fork()).join();
    }
    if (message.image !== undefined) {
      BadgeStruct_ImageBadge.encode(message.image, writer.uint32(162).fork()).join();
    }
    if (message.text !== undefined) {
      BadgeStruct_TextBadge.encode(message.text, writer.uint32(170).fork()).join();
    }
    if (message.str !== undefined) {
      BadgeStruct_StringBadge.encode(message.str, writer.uint32(178).fork()).join();
    }
    if (message.combine !== undefined) {
      BadgeStruct_CombineBadge.encode(message.combine, writer.uint32(186).fork()).join();
    }
    if (message.isCustomized !== false) {
      writer.uint32(192).bool(message.isCustomized);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.badgeDisplayType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.badgePriorityType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.badgeScene = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.position = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.displayStatus = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.greyedByClient = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.exhibitionType = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.schemaUrl = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.display = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.logExtra = PrivilegeLogExtra.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.image = BadgeStruct_ImageBadge.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.text = BadgeStruct_TextBadge.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.str = BadgeStruct_StringBadge.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.combine = BadgeStruct_CombineBadge.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.isCustomized = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BadgeStruct>, I>>(base?: I): BadgeStruct {
    return BadgeStruct.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BadgeStruct>, I>>(object: I): BadgeStruct {
    const message = createBaseBadgeStruct();
    message.badgeDisplayType = object.badgeDisplayType ?? 0;
    message.badgePriorityType = object.badgePriorityType ?? 0;
    message.badgeScene = object.badgeScene ?? 0;
    message.position = object.position ?? 0;
    message.displayStatus = object.displayStatus ?? 0;
    message.greyedByClient = object.greyedByClient ?? "0";
    message.exhibitionType = object.exhibitionType ?? 0;
    message.schemaUrl = object.schemaUrl ?? "";
    message.display = object.display ?? false;
    message.logExtra = (object.logExtra !== undefined && object.logExtra !== null)
      ? PrivilegeLogExtra.fromPartial(object.logExtra)
      : undefined;
    message.image = (object.image !== undefined && object.image !== null)
      ? BadgeStruct_ImageBadge.fromPartial(object.image)
      : undefined;
    message.text = (object.text !== undefined && object.text !== null)
      ? BadgeStruct_TextBadge.fromPartial(object.text)
      : undefined;
    message.str = (object.str !== undefined && object.str !== null)
      ? BadgeStruct_StringBadge.fromPartial(object.str)
      : undefined;
    message.combine = (object.combine !== undefined && object.combine !== null)
      ? BadgeStruct_CombineBadge.fromPartial(object.combine)
      : undefined;
    message.isCustomized = object.isCustomized ?? false;
    return message;
  },
};

function createBaseBadgeStruct_CombineBadge(): BadgeStruct_CombineBadge {
  return {
    badgeDisplayType: 0,
    icon: undefined,
    text: undefined,
    str: "",
    padding: undefined,
    fontStyle: undefined,
    profileCardPanel: undefined,
    background: undefined,
    backgroundDarkMode: undefined,
    iconAutoMirrored: false,
    bgAutoMirrored: false,
    publicScreenShowStyle: 0,
    personalCardShowStyle: 0,
    rankListOnlineAudienceShowStyle: 0,
    multiGuestShowStyle: 0,
    arrowConfig: undefined,
    paddingNewFont: undefined,
  };
}

export const BadgeStruct_CombineBadge: MessageFns<BadgeStruct_CombineBadge> = {
  encode(message: BadgeStruct_CombineBadge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.badgeDisplayType !== 0) {
      writer.uint32(8).int32(message.badgeDisplayType);
    }
    if (message.icon !== undefined) {
      Image.encode(message.icon, writer.uint32(18).fork()).join();
    }
    if (message.text !== undefined) {
      BadgeStruct_TextBadge.encode(message.text, writer.uint32(26).fork()).join();
    }
    if (message.str !== "") {
      writer.uint32(34).string(message.str);
    }
    if (message.padding !== undefined) {
      BadgeStruct_PaddingInfo.encode(message.padding, writer.uint32(42).fork()).join();
    }
    if (message.fontStyle !== undefined) {
      FontStyle.encode(message.fontStyle, writer.uint32(50).fork()).join();
    }
    if (message.profileCardPanel !== undefined) {
      BadgeStruct_ProfileCardPanel.encode(message.profileCardPanel, writer.uint32(58).fork()).join();
    }
    if (message.background !== undefined) {
      BadgeStruct_CombineBadgeBackground.encode(message.background, writer.uint32(90).fork()).join();
    }
    if (message.backgroundDarkMode !== undefined) {
      BadgeStruct_CombineBadgeBackground.encode(message.backgroundDarkMode, writer.uint32(98).fork()).join();
    }
    if (message.iconAutoMirrored !== false) {
      writer.uint32(104).bool(message.iconAutoMirrored);
    }
    if (message.bgAutoMirrored !== false) {
      writer.uint32(112).bool(message.bgAutoMirrored);
    }
    if (message.publicScreenShowStyle !== 0) {
      writer.uint32(120).int32(message.publicScreenShowStyle);
    }
    if (message.personalCardShowStyle !== 0) {
      writer.uint32(128).int32(message.personalCardShowStyle);
    }
    if (message.rankListOnlineAudienceShowStyle !== 0) {
      writer.uint32(136).int32(message.rankListOnlineAudienceShowStyle);
    }
    if (message.multiGuestShowStyle !== 0) {
      writer.uint32(144).int32(message.multiGuestShowStyle);
    }
    if (message.arrowConfig !== undefined) {
      BadgeStruct_ArrowConfig.encode(message.arrowConfig, writer.uint32(154).fork()).join();
    }
    if (message.paddingNewFont !== undefined) {
      BadgeStruct_PaddingInfo.encode(message.paddingNewFont, writer.uint32(162).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_CombineBadge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_CombineBadge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.badgeDisplayType = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.icon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.text = BadgeStruct_TextBadge.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.str = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.padding = BadgeStruct_PaddingInfo.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fontStyle = FontStyle.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.profileCardPanel = BadgeStruct_ProfileCardPanel.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.background = BadgeStruct_CombineBadgeBackground.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.backgroundDarkMode = BadgeStruct_CombineBadgeBackground.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.iconAutoMirrored = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.bgAutoMirrored = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.publicScreenShowStyle = reader.int32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.personalCardShowStyle = reader.int32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.rankListOnlineAudienceShowStyle = reader.int32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.multiGuestShowStyle = reader.int32();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.arrowConfig = BadgeStruct_ArrowConfig.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.paddingNewFont = BadgeStruct_PaddingInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BadgeStruct_CombineBadge>, I>>(base?: I): BadgeStruct_CombineBadge {
    return BadgeStruct_CombineBadge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BadgeStruct_CombineBadge>, I>>(object: I): BadgeStruct_CombineBadge {
    const message = createBaseBadgeStruct_CombineBadge();
    message.badgeDisplayType = object.badgeDisplayType ?? 0;
    message.icon = (object.icon !== undefined && object.icon !== null) ? Image.fromPartial(object.icon) : undefined;
    message.text = (object.text !== undefined && object.text !== null)
      ? BadgeStruct_TextBadge.fromPartial(object.text)
      : undefined;
    message.str = object.str ?? "";
    message.padding = (object.padding !== undefined && object.padding !== null)
      ? BadgeStruct_PaddingInfo.fromPartial(object.padding)
      : undefined;
    message.fontStyle = (object.fontStyle !== undefined && object.fontStyle !== null)
      ? FontStyle.fromPartial(object.fontStyle)
      : undefined;
    message.profileCardPanel = (object.profileCardPanel !== undefined && object.profileCardPanel !== null)
      ? BadgeStruct_ProfileCardPanel.fromPartial(object.profileCardPanel)
      : undefined;
    message.background = (object.background !== undefined && object.background !== null)
      ? BadgeStruct_CombineBadgeBackground.fromPartial(object.background)
      : undefined;
    message.backgroundDarkMode = (object.backgroundDarkMode !== undefined && object.backgroundDarkMode !== null)
      ? BadgeStruct_CombineBadgeBackground.fromPartial(object.backgroundDarkMode)
      : undefined;
    message.iconAutoMirrored = object.iconAutoMirrored ?? false;
    message.bgAutoMirrored = object.bgAutoMirrored ?? false;
    message.publicScreenShowStyle = object.publicScreenShowStyle ?? 0;
    message.personalCardShowStyle = object.personalCardShowStyle ?? 0;
    message.rankListOnlineAudienceShowStyle = object.rankListOnlineAudienceShowStyle ?? 0;
    message.multiGuestShowStyle = object.multiGuestShowStyle ?? 0;
    message.arrowConfig = (object.arrowConfig !== undefined && object.arrowConfig !== null)
      ? BadgeStruct_ArrowConfig.fromPartial(object.arrowConfig)
      : undefined;
    message.paddingNewFont = (object.paddingNewFont !== undefined && object.paddingNewFont !== null)
      ? BadgeStruct_PaddingInfo.fromPartial(object.paddingNewFont)
      : undefined;
    return message;
  },
};

function createBaseBadgeStruct_ArrowConfig(): BadgeStruct_ArrowConfig {
  return { icon: undefined };
}

export const BadgeStruct_ArrowConfig: MessageFns<BadgeStruct_ArrowConfig> = {
  encode(message: BadgeStruct_ArrowConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.icon !== undefined) {
      Image.encode(message.icon, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_ArrowConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_ArrowConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.icon = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BadgeStruct_ArrowConfig>, I>>(base?: I): BadgeStruct_ArrowConfig {
    return BadgeStruct_ArrowConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BadgeStruct_ArrowConfig>, I>>(object: I): BadgeStruct_ArrowConfig {
    const message = createBaseBadgeStruct_ArrowConfig();
    message.icon = (object.icon !== undefined && object.icon !== null) ? Image.fromPartial(object.icon) : undefined;
    return message;
  },
};

function createBaseBadgeStruct_ProfileContent(): BadgeStruct_ProfileContent {
  return { useContent: false, iconList: [], numberConfig: undefined };
}

export const BadgeStruct_ProfileContent: MessageFns<BadgeStruct_ProfileContent> = {
  encode(message: BadgeStruct_ProfileContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useContent !== false) {
      writer.uint32(8).bool(message.useContent);
    }
    for (const v of message.iconList) {
      BadgeStruct_IconConfig.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.numberConfig !== undefined) {
      BadgeStruct_NumberConfig.encode(message.numberConfig, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_ProfileContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_ProfileContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.useContent = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.iconList.push(BadgeStruct_IconConfig.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.numberConfig = BadgeStruct_NumberConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BadgeStruct_ProfileContent>, I>>(base?: I): BadgeStruct_ProfileContent {
    return BadgeStruct_ProfileContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BadgeStruct_ProfileContent>, I>>(object: I): BadgeStruct_ProfileContent {
    const message = createBaseBadgeStruct_ProfileContent();
    message.useContent = object.useContent ?? false;
    message.iconList = object.iconList?.map((e) => BadgeStruct_IconConfig.fromPartial(e)) || [];
    message.numberConfig = (object.numberConfig !== undefined && object.numberConfig !== null)
      ? BadgeStruct_NumberConfig.fromPartial(object.numberConfig)
      : undefined;
    return message;
  },
};

function createBaseBadgeStruct_ProjectionConfig(): BadgeStruct_ProjectionConfig {
  return { useProjection: false, icon: undefined };
}

export const BadgeStruct_ProjectionConfig: MessageFns<BadgeStruct_ProjectionConfig> = {
  encode(message: BadgeStruct_ProjectionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useProjection !== false) {
      writer.uint32(8).bool(message.useProjection);
    }
    if (message.icon !== undefined) {
      Image.encode(message.icon, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_ProjectionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_ProjectionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.useProjection = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.icon = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BadgeStruct_ProjectionConfig>, I>>(base?: I): BadgeStruct_ProjectionConfig {
    return BadgeStruct_ProjectionConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BadgeStruct_ProjectionConfig>, I>>(object: I): BadgeStruct_ProjectionConfig {
    const message = createBaseBadgeStruct_ProjectionConfig();
    message.useProjection = object.useProjection ?? false;
    message.icon = (object.icon !== undefined && object.icon !== null) ? Image.fromPartial(object.icon) : undefined;
    return message;
  },
};

function createBaseBadgeStruct_NumberConfig(): BadgeStruct_NumberConfig {
  return { number: "0", fontStyle: undefined, background: undefined };
}

export const BadgeStruct_NumberConfig: MessageFns<BadgeStruct_NumberConfig> = {
  encode(message: BadgeStruct_NumberConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.number !== "0") {
      writer.uint32(8).int64(message.number);
    }
    if (message.fontStyle !== undefined) {
      FontStyle.encode(message.fontStyle, writer.uint32(18).fork()).join();
    }
    if (message.background !== undefined) {
      BadgeStruct_CombineBadgeBackground.encode(message.background, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_NumberConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_NumberConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.number = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fontStyle = FontStyle.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.background = BadgeStruct_CombineBadgeBackground.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BadgeStruct_NumberConfig>, I>>(base?: I): BadgeStruct_NumberConfig {
    return BadgeStruct_NumberConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BadgeStruct_NumberConfig>, I>>(object: I): BadgeStruct_NumberConfig {
    const message = createBaseBadgeStruct_NumberConfig();
    message.number = object.number ?? "0";
    message.fontStyle = (object.fontStyle !== undefined && object.fontStyle !== null)
      ? FontStyle.fromPartial(object.fontStyle)
      : undefined;
    message.background = (object.background !== undefined && object.background !== null)
      ? BadgeStruct_CombineBadgeBackground.fromPartial(object.background)
      : undefined;
    return message;
  },
};

function createBaseBadgeStruct_ProfileCardPanel(): BadgeStruct_ProfileCardPanel {
  return { useNewProfileCardStyle: false, projectionConfig: undefined, profileContent: undefined };
}

export const BadgeStruct_ProfileCardPanel: MessageFns<BadgeStruct_ProfileCardPanel> = {
  encode(message: BadgeStruct_ProfileCardPanel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useNewProfileCardStyle !== false) {
      writer.uint32(8).bool(message.useNewProfileCardStyle);
    }
    if (message.projectionConfig !== undefined) {
      BadgeStruct_ProjectionConfig.encode(message.projectionConfig, writer.uint32(26).fork()).join();
    }
    if (message.profileContent !== undefined) {
      BadgeStruct_ProfileContent.encode(message.profileContent, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_ProfileCardPanel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_ProfileCardPanel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.useNewProfileCardStyle = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.projectionConfig = BadgeStruct_ProjectionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.profileContent = BadgeStruct_ProfileContent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BadgeStruct_ProfileCardPanel>, I>>(base?: I): BadgeStruct_ProfileCardPanel {
    return BadgeStruct_ProfileCardPanel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BadgeStruct_ProfileCardPanel>, I>>(object: I): BadgeStruct_ProfileCardPanel {
    const message = createBaseBadgeStruct_ProfileCardPanel();
    message.useNewProfileCardStyle = object.useNewProfileCardStyle ?? false;
    message.projectionConfig = (object.projectionConfig !== undefined && object.projectionConfig !== null)
      ? BadgeStruct_ProjectionConfig.fromPartial(object.projectionConfig)
      : undefined;
    message.profileContent = (object.profileContent !== undefined && object.profileContent !== null)
      ? BadgeStruct_ProfileContent.fromPartial(object.profileContent)
      : undefined;
    return message;
  },
};

function createBaseBadgeStruct_CombineBadgeBackground(): BadgeStruct_CombineBadgeBackground {
  return { image: undefined, backgroundColorCode: "", borderColorCode: "" };
}

export const BadgeStruct_CombineBadgeBackground: MessageFns<BadgeStruct_CombineBadgeBackground> = {
  encode(message: BadgeStruct_CombineBadgeBackground, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.image !== undefined) {
      Image.encode(message.image, writer.uint32(10).fork()).join();
    }
    if (message.backgroundColorCode !== "") {
      writer.uint32(18).string(message.backgroundColorCode);
    }
    if (message.borderColorCode !== "") {
      writer.uint32(26).string(message.borderColorCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_CombineBadgeBackground {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_CombineBadgeBackground();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.image = Image.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.backgroundColorCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.borderColorCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BadgeStruct_CombineBadgeBackground>, I>>(
    base?: I,
  ): BadgeStruct_CombineBadgeBackground {
    return BadgeStruct_CombineBadgeBackground.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BadgeStruct_CombineBadgeBackground>, I>>(
    object: I,
  ): BadgeStruct_CombineBadgeBackground {
    const message = createBaseBadgeStruct_CombineBadgeBackground();
    message.image = (object.image !== undefined && object.image !== null) ? Image.fromPartial(object.image) : undefined;
    message.backgroundColorCode = object.backgroundColorCode ?? "";
    message.borderColorCode = object.borderColorCode ?? "";
    return message;
  },
};

function createBaseBadgeStruct_ImageBadge(): BadgeStruct_ImageBadge {
  return { badgeDisplayType: 0, image: undefined };
}

export const BadgeStruct_ImageBadge: MessageFns<BadgeStruct_ImageBadge> = {
  encode(message: BadgeStruct_ImageBadge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.badgeDisplayType !== 0) {
      writer.uint32(8).int32(message.badgeDisplayType);
    }
    if (message.image !== undefined) {
      Image.encode(message.image, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_ImageBadge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_ImageBadge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.badgeDisplayType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.image = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BadgeStruct_ImageBadge>, I>>(base?: I): BadgeStruct_ImageBadge {
    return BadgeStruct_ImageBadge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BadgeStruct_ImageBadge>, I>>(object: I): BadgeStruct_ImageBadge {
    const message = createBaseBadgeStruct_ImageBadge();
    message.badgeDisplayType = object.badgeDisplayType ?? 0;
    message.image = (object.image !== undefined && object.image !== null) ? Image.fromPartial(object.image) : undefined;
    return message;
  },
};

function createBaseBadgeStruct_TextBadge(): BadgeStruct_TextBadge {
  return { badgeDisplayType: 0, key: "", defaultPattern: "", pieces: [] };
}

export const BadgeStruct_TextBadge: MessageFns<BadgeStruct_TextBadge> = {
  encode(message: BadgeStruct_TextBadge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.badgeDisplayType !== 0) {
      writer.uint32(8).int32(message.badgeDisplayType);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.defaultPattern !== "") {
      writer.uint32(26).string(message.defaultPattern);
    }
    for (const v of message.pieces) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_TextBadge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_TextBadge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.badgeDisplayType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.defaultPattern = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pieces.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BadgeStruct_TextBadge>, I>>(base?: I): BadgeStruct_TextBadge {
    return BadgeStruct_TextBadge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BadgeStruct_TextBadge>, I>>(object: I): BadgeStruct_TextBadge {
    const message = createBaseBadgeStruct_TextBadge();
    message.badgeDisplayType = object.badgeDisplayType ?? 0;
    message.key = object.key ?? "";
    message.defaultPattern = object.defaultPattern ?? "";
    message.pieces = object.pieces?.map((e) => e) || [];
    return message;
  },
};

function createBaseBadgeStruct_IconConfig(): BadgeStruct_IconConfig {
  return { icon: undefined, background: undefined };
}

export const BadgeStruct_IconConfig: MessageFns<BadgeStruct_IconConfig> = {
  encode(message: BadgeStruct_IconConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.icon !== undefined) {
      Image.encode(message.icon, writer.uint32(10).fork()).join();
    }
    if (message.background !== undefined) {
      BadgeStruct_CombineBadgeBackground.encode(message.background, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_IconConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_IconConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.icon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.background = BadgeStruct_CombineBadgeBackground.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BadgeStruct_IconConfig>, I>>(base?: I): BadgeStruct_IconConfig {
    return BadgeStruct_IconConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BadgeStruct_IconConfig>, I>>(object: I): BadgeStruct_IconConfig {
    const message = createBaseBadgeStruct_IconConfig();
    message.icon = (object.icon !== undefined && object.icon !== null) ? Image.fromPartial(object.icon) : undefined;
    message.background = (object.background !== undefined && object.background !== null)
      ? BadgeStruct_CombineBadgeBackground.fromPartial(object.background)
      : undefined;
    return message;
  },
};

function createBaseBadgeStruct_StringBadge(): BadgeStruct_StringBadge {
  return { badgeDisplayType: 0, str: "" };
}

export const BadgeStruct_StringBadge: MessageFns<BadgeStruct_StringBadge> = {
  encode(message: BadgeStruct_StringBadge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.badgeDisplayType !== 0) {
      writer.uint32(8).int32(message.badgeDisplayType);
    }
    if (message.str !== "") {
      writer.uint32(18).string(message.str);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_StringBadge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_StringBadge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.badgeDisplayType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.str = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BadgeStruct_StringBadge>, I>>(base?: I): BadgeStruct_StringBadge {
    return BadgeStruct_StringBadge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BadgeStruct_StringBadge>, I>>(object: I): BadgeStruct_StringBadge {
    const message = createBaseBadgeStruct_StringBadge();
    message.badgeDisplayType = object.badgeDisplayType ?? 0;
    message.str = object.str ?? "";
    return message;
  },
};

function createBaseBadgeStruct_PaddingInfo(): BadgeStruct_PaddingInfo {
  return {
    useSpecific: false,
    middlePadding: 0,
    badgeWidth: 0,
    leftPadding: 0,
    rightPadding: 0,
    iconTopPadding: 0,
    iconBottomPadding: 0,
    horizontalPaddingRule: 0,
    verticalPaddingRule: 0,
  };
}

export const BadgeStruct_PaddingInfo: MessageFns<BadgeStruct_PaddingInfo> = {
  encode(message: BadgeStruct_PaddingInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useSpecific !== false) {
      writer.uint32(8).bool(message.useSpecific);
    }
    if (message.middlePadding !== 0) {
      writer.uint32(16).int32(message.middlePadding);
    }
    if (message.badgeWidth !== 0) {
      writer.uint32(24).int32(message.badgeWidth);
    }
    if (message.leftPadding !== 0) {
      writer.uint32(32).int32(message.leftPadding);
    }
    if (message.rightPadding !== 0) {
      writer.uint32(40).int32(message.rightPadding);
    }
    if (message.iconTopPadding !== 0) {
      writer.uint32(48).int32(message.iconTopPadding);
    }
    if (message.iconBottomPadding !== 0) {
      writer.uint32(56).int32(message.iconBottomPadding);
    }
    if (message.horizontalPaddingRule !== 0) {
      writer.uint32(64).int32(message.horizontalPaddingRule);
    }
    if (message.verticalPaddingRule !== 0) {
      writer.uint32(72).int32(message.verticalPaddingRule);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadgeStruct_PaddingInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeStruct_PaddingInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.useSpecific = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.middlePadding = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.badgeWidth = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.leftPadding = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.rightPadding = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.iconTopPadding = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.iconBottomPadding = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.horizontalPaddingRule = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.verticalPaddingRule = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BadgeStruct_PaddingInfo>, I>>(base?: I): BadgeStruct_PaddingInfo {
    return BadgeStruct_PaddingInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BadgeStruct_PaddingInfo>, I>>(object: I): BadgeStruct_PaddingInfo {
    const message = createBaseBadgeStruct_PaddingInfo();
    message.useSpecific = object.useSpecific ?? false;
    message.middlePadding = object.middlePadding ?? 0;
    message.badgeWidth = object.badgeWidth ?? 0;
    message.leftPadding = object.leftPadding ?? 0;
    message.rightPadding = object.rightPadding ?? 0;
    message.iconTopPadding = object.iconTopPadding ?? 0;
    message.iconBottomPadding = object.iconBottomPadding ?? 0;
    message.horizontalPaddingRule = object.horizontalPaddingRule ?? 0;
    message.verticalPaddingRule = object.verticalPaddingRule ?? 0;
    return message;
  },
};

function createBaseGift(): Gift {
  return {
    giftImage: undefined,
    describe: "",
    duration: 0,
    id: "0",
    forLinkMic: false,
    combo: false,
    giftType: 0,
    diamondCount: 0,
    isDisplayedOnPanel: false,
    primaryEffectId: "0",
    giftLabelIcon: undefined,
    giftName: "",
    icon: undefined,
    goldEffect: "",
    previewImage: undefined,
    giftPanelBanner: undefined,
    isBroadcastGift: false,
    isEffectBefview: false,
    isRandomGift: false,
    isBoxGift: false,
    canPutInGiftBox: false,
    giftBoxInfo: undefined,
  };
}

export const Gift: MessageFns<Gift> = {
  encode(message: Gift, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftImage !== undefined) {
      Image.encode(message.giftImage, writer.uint32(10).fork()).join();
    }
    if (message.describe !== "") {
      writer.uint32(18).string(message.describe);
    }
    if (message.duration !== 0) {
      writer.uint32(32).int32(message.duration);
    }
    if (message.id !== "0") {
      writer.uint32(40).int64(message.id);
    }
    if (message.forLinkMic !== false) {
      writer.uint32(56).bool(message.forLinkMic);
    }
    if (message.combo !== false) {
      writer.uint32(80).bool(message.combo);
    }
    if (message.giftType !== 0) {
      writer.uint32(88).int32(message.giftType);
    }
    if (message.diamondCount !== 0) {
      writer.uint32(96).int32(message.diamondCount);
    }
    if (message.isDisplayedOnPanel !== false) {
      writer.uint32(104).bool(message.isDisplayedOnPanel);
    }
    if (message.primaryEffectId !== "0") {
      writer.uint32(112).int64(message.primaryEffectId);
    }
    if (message.giftLabelIcon !== undefined) {
      Image.encode(message.giftLabelIcon, writer.uint32(122).fork()).join();
    }
    if (message.giftName !== "") {
      writer.uint32(130).string(message.giftName);
    }
    if (message.icon !== undefined) {
      Image.encode(message.icon, writer.uint32(170).fork()).join();
    }
    if (message.goldEffect !== "") {
      writer.uint32(194).string(message.goldEffect);
    }
    if (message.previewImage !== undefined) {
      Image.encode(message.previewImage, writer.uint32(378).fork()).join();
    }
    if (message.giftPanelBanner !== undefined) {
      Gift_GiftPanelBanner.encode(message.giftPanelBanner, writer.uint32(386).fork()).join();
    }
    if (message.isBroadcastGift !== false) {
      writer.uint32(392).bool(message.isBroadcastGift);
    }
    if (message.isEffectBefview !== false) {
      writer.uint32(400).bool(message.isEffectBefview);
    }
    if (message.isRandomGift !== false) {
      writer.uint32(408).bool(message.isRandomGift);
    }
    if (message.isBoxGift !== false) {
      writer.uint32(416).bool(message.isBoxGift);
    }
    if (message.canPutInGiftBox !== false) {
      writer.uint32(424).bool(message.canPutInGiftBox);
    }
    if (message.giftBoxInfo !== undefined) {
      Gift_GiftBoxInfo.encode(message.giftBoxInfo, writer.uint32(434).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.giftImage = Image.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.describe = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.duration = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.forLinkMic = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.combo = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.giftType = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.diamondCount = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isDisplayedOnPanel = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.primaryEffectId = reader.int64().toString();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.giftLabelIcon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.giftName = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.icon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.goldEffect = reader.string();
          continue;
        }
        case 47: {
          if (tag !== 378) {
            break;
          }

          message.previewImage = Image.decode(reader, reader.uint32());
          continue;
        }
        case 48: {
          if (tag !== 386) {
            break;
          }

          message.giftPanelBanner = Gift_GiftPanelBanner.decode(reader, reader.uint32());
          continue;
        }
        case 49: {
          if (tag !== 392) {
            break;
          }

          message.isBroadcastGift = reader.bool();
          continue;
        }
        case 50: {
          if (tag !== 400) {
            break;
          }

          message.isEffectBefview = reader.bool();
          continue;
        }
        case 51: {
          if (tag !== 408) {
            break;
          }

          message.isRandomGift = reader.bool();
          continue;
        }
        case 52: {
          if (tag !== 416) {
            break;
          }

          message.isBoxGift = reader.bool();
          continue;
        }
        case 53: {
          if (tag !== 424) {
            break;
          }

          message.canPutInGiftBox = reader.bool();
          continue;
        }
        case 54: {
          if (tag !== 434) {
            break;
          }

          message.giftBoxInfo = Gift_GiftBoxInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Gift>, I>>(base?: I): Gift {
    return Gift.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Gift>, I>>(object: I): Gift {
    const message = createBaseGift();
    message.giftImage = (object.giftImage !== undefined && object.giftImage !== null)
      ? Image.fromPartial(object.giftImage)
      : undefined;
    message.describe = object.describe ?? "";
    message.duration = object.duration ?? 0;
    message.id = object.id ?? "0";
    message.forLinkMic = object.forLinkMic ?? false;
    message.combo = object.combo ?? false;
    message.giftType = object.giftType ?? 0;
    message.diamondCount = object.diamondCount ?? 0;
    message.isDisplayedOnPanel = object.isDisplayedOnPanel ?? false;
    message.primaryEffectId = object.primaryEffectId ?? "0";
    message.giftLabelIcon = (object.giftLabelIcon !== undefined && object.giftLabelIcon !== null)
      ? Image.fromPartial(object.giftLabelIcon)
      : undefined;
    message.giftName = object.giftName ?? "";
    message.icon = (object.icon !== undefined && object.icon !== null) ? Image.fromPartial(object.icon) : undefined;
    message.goldEffect = object.goldEffect ?? "";
    message.previewImage = (object.previewImage !== undefined && object.previewImage !== null)
      ? Image.fromPartial(object.previewImage)
      : undefined;
    message.giftPanelBanner = (object.giftPanelBanner !== undefined && object.giftPanelBanner !== null)
      ? Gift_GiftPanelBanner.fromPartial(object.giftPanelBanner)
      : undefined;
    message.isBroadcastGift = object.isBroadcastGift ?? false;
    message.isEffectBefview = object.isEffectBefview ?? false;
    message.isRandomGift = object.isRandomGift ?? false;
    message.isBoxGift = object.isBoxGift ?? false;
    message.canPutInGiftBox = object.canPutInGiftBox ?? false;
    message.giftBoxInfo = (object.giftBoxInfo !== undefined && object.giftBoxInfo !== null)
      ? Gift_GiftBoxInfo.fromPartial(object.giftBoxInfo)
      : undefined;
    return message;
  },
};

function createBaseGift_GiftPanelBanner(): Gift_GiftPanelBanner {
  return {
    displayText: undefined,
    leftIcon: undefined,
    schemaUrl: "",
    bgColors: [],
    bannerLynxUrl: "",
    bannerPriority: 0,
    bannerLynxExtra: "",
    bgImage: undefined,
  };
}

export const Gift_GiftPanelBanner: MessageFns<Gift_GiftPanelBanner> = {
  encode(message: Gift_GiftPanelBanner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayText !== undefined) {
      Text.encode(message.displayText, writer.uint32(10).fork()).join();
    }
    if (message.leftIcon !== undefined) {
      Image.encode(message.leftIcon, writer.uint32(18).fork()).join();
    }
    if (message.schemaUrl !== "") {
      writer.uint32(26).string(message.schemaUrl);
    }
    for (const v of message.bgColors) {
      writer.uint32(42).string(v!);
    }
    if (message.bannerLynxUrl !== "") {
      writer.uint32(50).string(message.bannerLynxUrl);
    }
    if (message.bannerPriority !== 0) {
      writer.uint32(56).int32(message.bannerPriority);
    }
    if (message.bannerLynxExtra !== "") {
      writer.uint32(66).string(message.bannerLynxExtra);
    }
    if (message.bgImage !== undefined) {
      Image.encode(message.bgImage, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_GiftPanelBanner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_GiftPanelBanner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayText = Text.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.leftIcon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.schemaUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bgColors.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bannerLynxUrl = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.bannerPriority = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.bannerLynxExtra = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.bgImage = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Gift_GiftPanelBanner>, I>>(base?: I): Gift_GiftPanelBanner {
    return Gift_GiftPanelBanner.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Gift_GiftPanelBanner>, I>>(object: I): Gift_GiftPanelBanner {
    const message = createBaseGift_GiftPanelBanner();
    message.displayText = (object.displayText !== undefined && object.displayText !== null)
      ? Text.fromPartial(object.displayText)
      : undefined;
    message.leftIcon = (object.leftIcon !== undefined && object.leftIcon !== null)
      ? Image.fromPartial(object.leftIcon)
      : undefined;
    message.schemaUrl = object.schemaUrl ?? "";
    message.bgColors = object.bgColors?.map((e) => e) || [];
    message.bannerLynxUrl = object.bannerLynxUrl ?? "";
    message.bannerPriority = object.bannerPriority ?? 0;
    message.bannerLynxExtra = object.bannerLynxExtra ?? "";
    message.bgImage = (object.bgImage !== undefined && object.bgImage !== null)
      ? Image.fromPartial(object.bgImage)
      : undefined;
    return message;
  },
};

function createBaseGift_BatchGiftInfo(): Gift_BatchGiftInfo {
  return { canBatchSend: false, availableCounts: [] };
}

export const Gift_BatchGiftInfo: MessageFns<Gift_BatchGiftInfo> = {
  encode(message: Gift_BatchGiftInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.canBatchSend !== false) {
      writer.uint32(8).bool(message.canBatchSend);
    }
    writer.uint32(18).fork();
    for (const v of message.availableCounts) {
      writer.int64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_BatchGiftInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_BatchGiftInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.canBatchSend = reader.bool();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.availableCounts.push(reader.int64().toString());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.availableCounts.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Gift_BatchGiftInfo>, I>>(base?: I): Gift_BatchGiftInfo {
    return Gift_BatchGiftInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Gift_BatchGiftInfo>, I>>(object: I): Gift_BatchGiftInfo {
    const message = createBaseGift_BatchGiftInfo();
    message.canBatchSend = object.canBatchSend ?? false;
    message.availableCounts = object.availableCounts?.map((e) => e) || [];
    return message;
  },
};

function createBaseGift_CrossScreenEffectInfo(): Gift_CrossScreenEffectInfo {
  return { singleActionEffectIds: {}, actionEffectIds: {}, reactionEffectIds: {} };
}

export const Gift_CrossScreenEffectInfo: MessageFns<Gift_CrossScreenEffectInfo> = {
  encode(message: Gift_CrossScreenEffectInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.singleActionEffectIds).forEach(([key, value]) => {
      Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntry.encode({ key: key as any, value }, writer.uint32(10).fork())
        .join();
    });
    Object.entries(message.actionEffectIds).forEach(([key, value]) => {
      Gift_CrossScreenEffectInfo_ActionEffectIdsEntry.encode({ key: key as any, value }, writer.uint32(18).fork())
        .join();
    });
    Object.entries(message.reactionEffectIds).forEach(([key, value]) => {
      Gift_CrossScreenEffectInfo_ReactionEffectIdsEntry.encode({ key: key as any, value }, writer.uint32(26).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_CrossScreenEffectInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_CrossScreenEffectInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.singleActionEffectIds[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = Gift_CrossScreenEffectInfo_ActionEffectIdsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.actionEffectIds[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = Gift_CrossScreenEffectInfo_ReactionEffectIdsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.reactionEffectIds[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Gift_CrossScreenEffectInfo>, I>>(base?: I): Gift_CrossScreenEffectInfo {
    return Gift_CrossScreenEffectInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Gift_CrossScreenEffectInfo>, I>>(object: I): Gift_CrossScreenEffectInfo {
    const message = createBaseGift_CrossScreenEffectInfo();
    message.singleActionEffectIds = Object.entries(object.singleActionEffectIds ?? {}).reduce<
      { [key: string]: number }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.actionEffectIds = Object.entries(object.actionEffectIds ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    message.reactionEffectIds = Object.entries(object.reactionEffectIds ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseGift_CrossScreenEffectInfo_SingleActionEffectIdsEntry(): Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntry {
  return { key: "0", value: 0 };
}

export const Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntry: MessageFns<
  Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntry
> = {
  encode(
    message: Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_CrossScreenEffectInfo_SingleActionEffectIdsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntry>, I>>(
    base?: I,
  ): Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntry {
    return Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntry>, I>>(
    object: I,
  ): Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntry {
    const message = createBaseGift_CrossScreenEffectInfo_SingleActionEffectIdsEntry();
    message.key = object.key ?? "0";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseGift_CrossScreenEffectInfo_ActionEffectIdsEntry(): Gift_CrossScreenEffectInfo_ActionEffectIdsEntry {
  return { key: "0", value: 0 };
}

export const Gift_CrossScreenEffectInfo_ActionEffectIdsEntry: MessageFns<
  Gift_CrossScreenEffectInfo_ActionEffectIdsEntry
> = {
  encode(
    message: Gift_CrossScreenEffectInfo_ActionEffectIdsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_CrossScreenEffectInfo_ActionEffectIdsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_CrossScreenEffectInfo_ActionEffectIdsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Gift_CrossScreenEffectInfo_ActionEffectIdsEntry>, I>>(
    base?: I,
  ): Gift_CrossScreenEffectInfo_ActionEffectIdsEntry {
    return Gift_CrossScreenEffectInfo_ActionEffectIdsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Gift_CrossScreenEffectInfo_ActionEffectIdsEntry>, I>>(
    object: I,
  ): Gift_CrossScreenEffectInfo_ActionEffectIdsEntry {
    const message = createBaseGift_CrossScreenEffectInfo_ActionEffectIdsEntry();
    message.key = object.key ?? "0";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseGift_CrossScreenEffectInfo_ReactionEffectIdsEntry(): Gift_CrossScreenEffectInfo_ReactionEffectIdsEntry {
  return { key: "0", value: 0 };
}

export const Gift_CrossScreenEffectInfo_ReactionEffectIdsEntry: MessageFns<
  Gift_CrossScreenEffectInfo_ReactionEffectIdsEntry
> = {
  encode(
    message: Gift_CrossScreenEffectInfo_ReactionEffectIdsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_CrossScreenEffectInfo_ReactionEffectIdsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_CrossScreenEffectInfo_ReactionEffectIdsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Gift_CrossScreenEffectInfo_ReactionEffectIdsEntry>, I>>(
    base?: I,
  ): Gift_CrossScreenEffectInfo_ReactionEffectIdsEntry {
    return Gift_CrossScreenEffectInfo_ReactionEffectIdsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Gift_CrossScreenEffectInfo_ReactionEffectIdsEntry>, I>>(
    object: I,
  ): Gift_CrossScreenEffectInfo_ReactionEffectIdsEntry {
    const message = createBaseGift_CrossScreenEffectInfo_ReactionEffectIdsEntry();
    message.key = object.key ?? "0";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseGift_GiftSponsorInfo(): Gift_GiftSponsorInfo {
  return { sponsorId: "0", sponsorCount: "0", currentCount: "0", leftCountToSponsor: "0", canSponsor: false };
}

export const Gift_GiftSponsorInfo: MessageFns<Gift_GiftSponsorInfo> = {
  encode(message: Gift_GiftSponsorInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sponsorId !== "0") {
      writer.uint32(8).int64(message.sponsorId);
    }
    if (message.sponsorCount !== "0") {
      writer.uint32(16).int64(message.sponsorCount);
    }
    if (message.currentCount !== "0") {
      writer.uint32(24).int64(message.currentCount);
    }
    if (message.leftCountToSponsor !== "0") {
      writer.uint32(32).int64(message.leftCountToSponsor);
    }
    if (message.canSponsor !== false) {
      writer.uint32(40).bool(message.canSponsor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_GiftSponsorInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_GiftSponsorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sponsorId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sponsorCount = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.currentCount = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.leftCountToSponsor = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.canSponsor = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Gift_GiftSponsorInfo>, I>>(base?: I): Gift_GiftSponsorInfo {
    return Gift_GiftSponsorInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Gift_GiftSponsorInfo>, I>>(object: I): Gift_GiftSponsorInfo {
    const message = createBaseGift_GiftSponsorInfo();
    message.sponsorId = object.sponsorId ?? "0";
    message.sponsorCount = object.sponsorCount ?? "0";
    message.currentCount = object.currentCount ?? "0";
    message.leftCountToSponsor = object.leftCountToSponsor ?? "0";
    message.canSponsor = object.canSponsor ?? false;
    return message;
  },
};

function createBaseGift_UGGiftStructInfo(): Gift_UGGiftStructInfo {
  return { isUgGift: false, ugPointsCost: "0" };
}

export const Gift_UGGiftStructInfo: MessageFns<Gift_UGGiftStructInfo> = {
  encode(message: Gift_UGGiftStructInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isUgGift !== false) {
      writer.uint32(8).bool(message.isUgGift);
    }
    if (message.ugPointsCost !== "0") {
      writer.uint32(16).int64(message.ugPointsCost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_UGGiftStructInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_UGGiftStructInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isUgGift = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ugPointsCost = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Gift_UGGiftStructInfo>, I>>(base?: I): Gift_UGGiftStructInfo {
    return Gift_UGGiftStructInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Gift_UGGiftStructInfo>, I>>(object: I): Gift_UGGiftStructInfo {
    const message = createBaseGift_UGGiftStructInfo();
    message.isUgGift = object.isUgGift ?? false;
    message.ugPointsCost = object.ugPointsCost ?? "0";
    return message;
  },
};

function createBaseGift_GiftSkin(): Gift_GiftSkin {
  return { giftSkinId: "0", giftSkinName: "", staticImage: undefined, animatedImage: undefined };
}

export const Gift_GiftSkin: MessageFns<Gift_GiftSkin> = {
  encode(message: Gift_GiftSkin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftSkinId !== "0") {
      writer.uint32(8).int64(message.giftSkinId);
    }
    if (message.giftSkinName !== "") {
      writer.uint32(18).string(message.giftSkinName);
    }
    if (message.staticImage !== undefined) {
      Image.encode(message.staticImage, writer.uint32(26).fork()).join();
    }
    if (message.animatedImage !== undefined) {
      Image.encode(message.animatedImage, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_GiftSkin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_GiftSkin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.giftSkinId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.giftSkinName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.staticImage = Image.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.animatedImage = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Gift_GiftSkin>, I>>(base?: I): Gift_GiftSkin {
    return Gift_GiftSkin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Gift_GiftSkin>, I>>(object: I): Gift_GiftSkin {
    const message = createBaseGift_GiftSkin();
    message.giftSkinId = object.giftSkinId ?? "0";
    message.giftSkinName = object.giftSkinName ?? "";
    message.staticImage = (object.staticImage !== undefined && object.staticImage !== null)
      ? Image.fromPartial(object.staticImage)
      : undefined;
    message.animatedImage = (object.animatedImage !== undefined && object.animatedImage !== null)
      ? Image.fromPartial(object.animatedImage)
      : undefined;
    return message;
  },
};

function createBaseGift_GiftText(): Gift_GiftText {
  return { giftTextId: "0", giftTextName: "" };
}

export const Gift_GiftText: MessageFns<Gift_GiftText> = {
  encode(message: Gift_GiftText, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftTextId !== "0") {
      writer.uint32(8).int64(message.giftTextId);
    }
    if (message.giftTextName !== "") {
      writer.uint32(18).string(message.giftTextName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_GiftText {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_GiftText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.giftTextId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.giftTextName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Gift_GiftText>, I>>(base?: I): Gift_GiftText {
    return Gift_GiftText.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Gift_GiftText>, I>>(object: I): Gift_GiftText {
    const message = createBaseGift_GiftText();
    message.giftTextId = object.giftTextId ?? "0";
    message.giftTextName = object.giftTextName ?? "";
    return message;
  },
};

function createBaseGift_GiftSkinToGiftTextsInfo(): Gift_GiftSkinToGiftTextsInfo {
  return { giftSkinId: "0", giftTextIds: [] };
}

export const Gift_GiftSkinToGiftTextsInfo: MessageFns<Gift_GiftSkinToGiftTextsInfo> = {
  encode(message: Gift_GiftSkinToGiftTextsInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftSkinId !== "0") {
      writer.uint32(8).int64(message.giftSkinId);
    }
    writer.uint32(18).fork();
    for (const v of message.giftTextIds) {
      writer.int64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_GiftSkinToGiftTextsInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_GiftSkinToGiftTextsInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.giftSkinId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.giftTextIds.push(reader.int64().toString());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.giftTextIds.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Gift_GiftSkinToGiftTextsInfo>, I>>(base?: I): Gift_GiftSkinToGiftTextsInfo {
    return Gift_GiftSkinToGiftTextsInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Gift_GiftSkinToGiftTextsInfo>, I>>(object: I): Gift_GiftSkinToGiftTextsInfo {
    const message = createBaseGift_GiftSkinToGiftTextsInfo();
    message.giftSkinId = object.giftSkinId ?? "0";
    message.giftTextIds = object.giftTextIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseGift_GiftBoxInfo(): Gift_GiftBoxInfo {
  return { capacity: "0", isPrimaryBox: false, schemeUrl: "" };
}

export const Gift_GiftBoxInfo: MessageFns<Gift_GiftBoxInfo> = {
  encode(message: Gift_GiftBoxInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.capacity !== "0") {
      writer.uint32(8).int64(message.capacity);
    }
    if (message.isPrimaryBox !== false) {
      writer.uint32(16).bool(message.isPrimaryBox);
    }
    if (message.schemeUrl !== "") {
      writer.uint32(26).string(message.schemeUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gift_GiftBoxInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGift_GiftBoxInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.capacity = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isPrimaryBox = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.schemeUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Gift_GiftBoxInfo>, I>>(base?: I): Gift_GiftBoxInfo {
    return Gift_GiftBoxInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Gift_GiftBoxInfo>, I>>(object: I): Gift_GiftBoxInfo {
    const message = createBaseGift_GiftBoxInfo();
    message.capacity = object.capacity ?? "0";
    message.isPrimaryBox = object.isPrimaryBox ?? false;
    message.schemeUrl = object.schemeUrl ?? "";
    return message;
  },
};

function createBaseUser(): User {
  return {
    userId: "0",
    nickname: "",
    bioDescription: "",
    profilePicture: undefined,
    profilePictureMedium: undefined,
    profilePictureLarge: undefined,
    verified: false,
    status: 0,
    createTime: "0",
    modifyTime: "0",
    secret: 0,
    shareQrcodeUri: "",
    badgeImageList: [],
    followInfo: undefined,
    userHonor: undefined,
    fansClub: undefined,
    border: undefined,
    specialId: "",
    avatarBorder: undefined,
    medal: undefined,
    userBadges: [],
    newUserBadges: [],
    topVipNo: 0,
    userAttr: undefined,
    ownRoom: undefined,
    payScore: "0",
    fanTicketCount: "0",
    anchorInfo: undefined,
    linkMicStats: 0,
    uniqueId: "",
    enableShowCommerceSale: false,
    withFusionShopEntry: false,
    payScores: "0",
    anchorLevel: undefined,
    verifiedContent: "",
    authorInfo: undefined,
    topFans: [],
    secUid: "",
    userRole: 0,
    rewardInfo: undefined,
    personalCard: undefined,
    authenticationInfo: undefined,
    mediaBadgeImageList: [],
    commerceWebcastConfigIds: [],
    borders: [],
    comboBadgeInfo: undefined,
    subscribeInfo: undefined,
    badges: [],
    mintTypeLabel: [],
    fansClubInfo: undefined,
    allowFindByContacts: false,
    allowOthersDownloadVideo: false,
    allowOthersDownloadWhenSharingVideo: false,
    allowShareShowProfile: false,
    allowShowInGossip: false,
    allowShowMyAction: false,
    allowStrangeComment: false,
    allowUnfollowerComment: false,
    allowUseLinkmic: false,
    avatarJpg: undefined,
    backgroundImgUrl: "",
    blockStatus: 0,
    commentRestrict: 0,
    constellation: "",
    disableIchat: 0,
    enableIchatImg: "0",
    exp: 0,
    foldStrangerChat: false,
    followStatus: "0",
    ichatRestrictType: 0,
    idStr: "",
    isFollower: false,
    isFollowing: false,
    needProfileGuide: false,
    pushCommentStatus: false,
    pushDigg: false,
    pushFollow: false,
    pushFriendAction: false,
    pushIchat: false,
    pushStatus: false,
    pushVideoPost: false,
    pushVideoRecommend: false,
    verifiedReason: "",
    enableCarManagementPermission: false,
    upcomingEventList: [],
    scmLabel: "",
    ecommerceEntrance: undefined,
    isBlock: false,
    isSubscribe: false,
    isAnchorMarked: false,
  };
}

export const User: MessageFns<User> = {
  encode(message: User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.nickname !== "") {
      writer.uint32(26).string(message.nickname);
    }
    if (message.bioDescription !== "") {
      writer.uint32(42).string(message.bioDescription);
    }
    if (message.profilePicture !== undefined) {
      Image.encode(message.profilePicture, writer.uint32(74).fork()).join();
    }
    if (message.profilePictureMedium !== undefined) {
      Image.encode(message.profilePictureMedium, writer.uint32(82).fork()).join();
    }
    if (message.profilePictureLarge !== undefined) {
      Image.encode(message.profilePictureLarge, writer.uint32(90).fork()).join();
    }
    if (message.verified !== false) {
      writer.uint32(96).bool(message.verified);
    }
    if (message.status !== 0) {
      writer.uint32(120).int32(message.status);
    }
    if (message.createTime !== "0") {
      writer.uint32(128).int64(message.createTime);
    }
    if (message.modifyTime !== "0") {
      writer.uint32(136).int64(message.modifyTime);
    }
    if (message.secret !== 0) {
      writer.uint32(144).int32(message.secret);
    }
    if (message.shareQrcodeUri !== "") {
      writer.uint32(154).string(message.shareQrcodeUri);
    }
    for (const v of message.badgeImageList) {
      Image.encode(v!, writer.uint32(170).fork()).join();
    }
    if (message.followInfo !== undefined) {
      User_FollowInfo.encode(message.followInfo, writer.uint32(178).fork()).join();
    }
    if (message.userHonor !== undefined) {
      UserHonor.encode(message.userHonor, writer.uint32(186).fork()).join();
    }
    if (message.fansClub !== undefined) {
      FansClubMember.encode(message.fansClub, writer.uint32(194).fork()).join();
    }
    if (message.border !== undefined) {
      BorderInfo.encode(message.border, writer.uint32(202).fork()).join();
    }
    if (message.specialId !== "") {
      writer.uint32(210).string(message.specialId);
    }
    if (message.avatarBorder !== undefined) {
      Image.encode(message.avatarBorder, writer.uint32(218).fork()).join();
    }
    if (message.medal !== undefined) {
      Image.encode(message.medal, writer.uint32(226).fork()).join();
    }
    for (const v of message.userBadges) {
      Image.encode(v!, writer.uint32(234).fork()).join();
    }
    for (const v of message.newUserBadges) {
      Image.encode(v!, writer.uint32(242).fork()).join();
    }
    if (message.topVipNo !== 0) {
      writer.uint32(248).int32(message.topVipNo);
    }
    if (message.userAttr !== undefined) {
      User_UserAttr.encode(message.userAttr, writer.uint32(258).fork()).join();
    }
    if (message.ownRoom !== undefined) {
      User_OwnRoom.encode(message.ownRoom, writer.uint32(266).fork()).join();
    }
    if (message.payScore !== "0") {
      writer.uint32(272).int64(message.payScore);
    }
    if (message.fanTicketCount !== "0") {
      writer.uint32(280).int64(message.fanTicketCount);
    }
    if (message.anchorInfo !== undefined) {
      User_AnchorLevel.encode(message.anchorInfo, writer.uint32(290).fork()).join();
    }
    if (message.linkMicStats !== 0) {
      writer.uint32(296).int32(message.linkMicStats);
    }
    if (message.uniqueId !== "") {
      writer.uint32(306).string(message.uniqueId);
    }
    if (message.enableShowCommerceSale !== false) {
      writer.uint32(312).bool(message.enableShowCommerceSale);
    }
    if (message.withFusionShopEntry !== false) {
      writer.uint32(320).bool(message.withFusionShopEntry);
    }
    if (message.payScores !== "0") {
      writer.uint32(328).int64(message.payScores);
    }
    if (message.anchorLevel !== undefined) {
      User_AnchorLevel.encode(message.anchorLevel, writer.uint32(338).fork()).join();
    }
    if (message.verifiedContent !== "") {
      writer.uint32(346).string(message.verifiedContent);
    }
    if (message.authorInfo !== undefined) {
      Author.encode(message.authorInfo, writer.uint32(354).fork()).join();
    }
    for (const v of message.topFans) {
      User.encode(v!, writer.uint32(362).fork()).join();
    }
    if (message.secUid !== "") {
      writer.uint32(370).string(message.secUid);
    }
    if (message.userRole !== 0) {
      writer.uint32(376).int32(message.userRole);
    }
    if (message.rewardInfo !== undefined) {
      User_ActivityInfo.encode(message.rewardInfo, writer.uint32(394).fork()).join();
    }
    if (message.personalCard !== undefined) {
      Image.encode(message.personalCard, writer.uint32(418).fork()).join();
    }
    if (message.authenticationInfo !== undefined) {
      User_AuthenticationInfo.encode(message.authenticationInfo, writer.uint32(426).fork()).join();
    }
    for (const v of message.mediaBadgeImageList) {
      Image.encode(v!, writer.uint32(458).fork()).join();
    }
    writer.uint32(482).fork();
    for (const v of message.commerceWebcastConfigIds) {
      writer.int64(v);
    }
    writer.join();
    for (const v of message.borders) {
      BorderInfo.encode(v!, writer.uint32(490).fork()).join();
    }
    if (message.comboBadgeInfo !== undefined) {
      User_ComboBadgeInfo.encode(message.comboBadgeInfo, writer.uint32(498).fork()).join();
    }
    if (message.subscribeInfo !== undefined) {
      User_SubscribeInfo.encode(message.subscribeInfo, writer.uint32(506).fork()).join();
    }
    for (const v of message.badges) {
      BadgeStruct.encode(v!, writer.uint32(514).fork()).join();
    }
    writer.uint32(522).fork();
    for (const v of message.mintTypeLabel) {
      writer.int64(v);
    }
    writer.join();
    if (message.fansClubInfo !== undefined) {
      User_FansClubInfo.encode(message.fansClubInfo, writer.uint32(530).fork()).join();
    }
    if (message.allowFindByContacts !== false) {
      writer.uint32(8016).bool(message.allowFindByContacts);
    }
    if (message.allowOthersDownloadVideo !== false) {
      writer.uint32(8024).bool(message.allowOthersDownloadVideo);
    }
    if (message.allowOthersDownloadWhenSharingVideo !== false) {
      writer.uint32(8032).bool(message.allowOthersDownloadWhenSharingVideo);
    }
    if (message.allowShareShowProfile !== false) {
      writer.uint32(8040).bool(message.allowShareShowProfile);
    }
    if (message.allowShowInGossip !== false) {
      writer.uint32(8048).bool(message.allowShowInGossip);
    }
    if (message.allowShowMyAction !== false) {
      writer.uint32(8056).bool(message.allowShowMyAction);
    }
    if (message.allowStrangeComment !== false) {
      writer.uint32(8064).bool(message.allowStrangeComment);
    }
    if (message.allowUnfollowerComment !== false) {
      writer.uint32(8072).bool(message.allowUnfollowerComment);
    }
    if (message.allowUseLinkmic !== false) {
      writer.uint32(8080).bool(message.allowUseLinkmic);
    }
    if (message.avatarJpg !== undefined) {
      Image.encode(message.avatarJpg, writer.uint32(8098).fork()).join();
    }
    if (message.backgroundImgUrl !== "") {
      writer.uint32(8106).string(message.backgroundImgUrl);
    }
    if (message.blockStatus !== 0) {
      writer.uint32(8128).int32(message.blockStatus);
    }
    if (message.commentRestrict !== 0) {
      writer.uint32(8136).int32(message.commentRestrict);
    }
    if (message.constellation !== "") {
      writer.uint32(8146).string(message.constellation);
    }
    if (message.disableIchat !== 0) {
      writer.uint32(8152).int32(message.disableIchat);
    }
    if (message.enableIchatImg !== "0") {
      writer.uint32(8160).int64(message.enableIchatImg);
    }
    if (message.exp !== 0) {
      writer.uint32(8168).int32(message.exp);
    }
    if (message.foldStrangerChat !== false) {
      writer.uint32(8184).bool(message.foldStrangerChat);
    }
    if (message.followStatus !== "0") {
      writer.uint32(8192).int64(message.followStatus);
    }
    if (message.ichatRestrictType !== 0) {
      writer.uint32(8216).int32(message.ichatRestrictType);
    }
    if (message.idStr !== "") {
      writer.uint32(8226).string(message.idStr);
    }
    if (message.isFollower !== false) {
      writer.uint32(8232).bool(message.isFollower);
    }
    if (message.isFollowing !== false) {
      writer.uint32(8240).bool(message.isFollowing);
    }
    if (message.needProfileGuide !== false) {
      writer.uint32(8248).bool(message.needProfileGuide);
    }
    if (message.pushCommentStatus !== false) {
      writer.uint32(8264).bool(message.pushCommentStatus);
    }
    if (message.pushDigg !== false) {
      writer.uint32(8272).bool(message.pushDigg);
    }
    if (message.pushFollow !== false) {
      writer.uint32(8280).bool(message.pushFollow);
    }
    if (message.pushFriendAction !== false) {
      writer.uint32(8288).bool(message.pushFriendAction);
    }
    if (message.pushIchat !== false) {
      writer.uint32(8296).bool(message.pushIchat);
    }
    if (message.pushStatus !== false) {
      writer.uint32(8304).bool(message.pushStatus);
    }
    if (message.pushVideoPost !== false) {
      writer.uint32(8312).bool(message.pushVideoPost);
    }
    if (message.pushVideoRecommend !== false) {
      writer.uint32(8320).bool(message.pushVideoRecommend);
    }
    if (message.verifiedReason !== "") {
      writer.uint32(8346).string(message.verifiedReason);
    }
    if (message.enableCarManagementPermission !== false) {
      writer.uint32(8352).bool(message.enableCarManagementPermission);
    }
    for (const v of message.upcomingEventList) {
      User_LiveEventInfo.encode(v!, writer.uint32(8362).fork()).join();
    }
    if (message.scmLabel !== "") {
      writer.uint32(8370).string(message.scmLabel);
    }
    if (message.ecommerceEntrance !== undefined) {
      User_EcommerceEntrance.encode(message.ecommerceEntrance, writer.uint32(8378).fork()).join();
    }
    if (message.isBlock !== false) {
      writer.uint32(8384).bool(message.isBlock);
    }
    if (message.isSubscribe !== false) {
      writer.uint32(8720).bool(message.isSubscribe);
    }
    if (message.isAnchorMarked !== false) {
      writer.uint32(8728).bool(message.isAnchorMarked);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bioDescription = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.profilePicture = Image.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.profilePictureMedium = Image.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.profilePictureLarge = Image.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.verified = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.createTime = reader.int64().toString();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.modifyTime = reader.int64().toString();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.secret = reader.int32();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.shareQrcodeUri = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.badgeImageList.push(Image.decode(reader, reader.uint32()));
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.followInfo = User_FollowInfo.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.userHonor = UserHonor.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.fansClub = FansClubMember.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.border = BorderInfo.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.specialId = reader.string();
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.avatarBorder = Image.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.medal = Image.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.userBadges.push(Image.decode(reader, reader.uint32()));
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.newUserBadges.push(Image.decode(reader, reader.uint32()));
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.topVipNo = reader.int32();
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.userAttr = User_UserAttr.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.ownRoom = User_OwnRoom.decode(reader, reader.uint32());
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.payScore = reader.int64().toString();
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.fanTicketCount = reader.int64().toString();
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.anchorInfo = User_AnchorLevel.decode(reader, reader.uint32());
          continue;
        }
        case 37: {
          if (tag !== 296) {
            break;
          }

          message.linkMicStats = reader.int32() as any;
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.uniqueId = reader.string();
          continue;
        }
        case 39: {
          if (tag !== 312) {
            break;
          }

          message.enableShowCommerceSale = reader.bool();
          continue;
        }
        case 40: {
          if (tag !== 320) {
            break;
          }

          message.withFusionShopEntry = reader.bool();
          continue;
        }
        case 41: {
          if (tag !== 328) {
            break;
          }

          message.payScores = reader.int64().toString();
          continue;
        }
        case 42: {
          if (tag !== 338) {
            break;
          }

          message.anchorLevel = User_AnchorLevel.decode(reader, reader.uint32());
          continue;
        }
        case 43: {
          if (tag !== 346) {
            break;
          }

          message.verifiedContent = reader.string();
          continue;
        }
        case 44: {
          if (tag !== 354) {
            break;
          }

          message.authorInfo = Author.decode(reader, reader.uint32());
          continue;
        }
        case 45: {
          if (tag !== 362) {
            break;
          }

          message.topFans.push(User.decode(reader, reader.uint32()));
          continue;
        }
        case 46: {
          if (tag !== 370) {
            break;
          }

          message.secUid = reader.string();
          continue;
        }
        case 47: {
          if (tag !== 376) {
            break;
          }

          message.userRole = reader.int32();
          continue;
        }
        case 49: {
          if (tag !== 394) {
            break;
          }

          message.rewardInfo = User_ActivityInfo.decode(reader, reader.uint32());
          continue;
        }
        case 52: {
          if (tag !== 418) {
            break;
          }

          message.personalCard = Image.decode(reader, reader.uint32());
          continue;
        }
        case 53: {
          if (tag !== 426) {
            break;
          }

          message.authenticationInfo = User_AuthenticationInfo.decode(reader, reader.uint32());
          continue;
        }
        case 57: {
          if (tag !== 458) {
            break;
          }

          message.mediaBadgeImageList.push(Image.decode(reader, reader.uint32()));
          continue;
        }
        case 60: {
          if (tag === 480) {
            message.commerceWebcastConfigIds.push(reader.int64().toString());

            continue;
          }

          if (tag === 482) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.commerceWebcastConfigIds.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 61: {
          if (tag !== 490) {
            break;
          }

          message.borders.push(BorderInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 62: {
          if (tag !== 498) {
            break;
          }

          message.comboBadgeInfo = User_ComboBadgeInfo.decode(reader, reader.uint32());
          continue;
        }
        case 63: {
          if (tag !== 506) {
            break;
          }

          message.subscribeInfo = User_SubscribeInfo.decode(reader, reader.uint32());
          continue;
        }
        case 64: {
          if (tag !== 514) {
            break;
          }

          message.badges.push(BadgeStruct.decode(reader, reader.uint32()));
          continue;
        }
        case 65: {
          if (tag === 520) {
            message.mintTypeLabel.push(reader.int64().toString());

            continue;
          }

          if (tag === 522) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.mintTypeLabel.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 66: {
          if (tag !== 530) {
            break;
          }

          message.fansClubInfo = User_FansClubInfo.decode(reader, reader.uint32());
          continue;
        }
        case 1002: {
          if (tag !== 8016) {
            break;
          }

          message.allowFindByContacts = reader.bool();
          continue;
        }
        case 1003: {
          if (tag !== 8024) {
            break;
          }

          message.allowOthersDownloadVideo = reader.bool();
          continue;
        }
        case 1004: {
          if (tag !== 8032) {
            break;
          }

          message.allowOthersDownloadWhenSharingVideo = reader.bool();
          continue;
        }
        case 1005: {
          if (tag !== 8040) {
            break;
          }

          message.allowShareShowProfile = reader.bool();
          continue;
        }
        case 1006: {
          if (tag !== 8048) {
            break;
          }

          message.allowShowInGossip = reader.bool();
          continue;
        }
        case 1007: {
          if (tag !== 8056) {
            break;
          }

          message.allowShowMyAction = reader.bool();
          continue;
        }
        case 1008: {
          if (tag !== 8064) {
            break;
          }

          message.allowStrangeComment = reader.bool();
          continue;
        }
        case 1009: {
          if (tag !== 8072) {
            break;
          }

          message.allowUnfollowerComment = reader.bool();
          continue;
        }
        case 1010: {
          if (tag !== 8080) {
            break;
          }

          message.allowUseLinkmic = reader.bool();
          continue;
        }
        case 1012: {
          if (tag !== 8098) {
            break;
          }

          message.avatarJpg = Image.decode(reader, reader.uint32());
          continue;
        }
        case 1013: {
          if (tag !== 8106) {
            break;
          }

          message.backgroundImgUrl = reader.string();
          continue;
        }
        case 1016: {
          if (tag !== 8128) {
            break;
          }

          message.blockStatus = reader.int32();
          continue;
        }
        case 1017: {
          if (tag !== 8136) {
            break;
          }

          message.commentRestrict = reader.int32();
          continue;
        }
        case 1018: {
          if (tag !== 8146) {
            break;
          }

          message.constellation = reader.string();
          continue;
        }
        case 1019: {
          if (tag !== 8152) {
            break;
          }

          message.disableIchat = reader.int32();
          continue;
        }
        case 1020: {
          if (tag !== 8160) {
            break;
          }

          message.enableIchatImg = reader.int64().toString();
          continue;
        }
        case 1021: {
          if (tag !== 8168) {
            break;
          }

          message.exp = reader.int32();
          continue;
        }
        case 1023: {
          if (tag !== 8184) {
            break;
          }

          message.foldStrangerChat = reader.bool();
          continue;
        }
        case 1024: {
          if (tag !== 8192) {
            break;
          }

          message.followStatus = reader.int64().toString();
          continue;
        }
        case 1027: {
          if (tag !== 8216) {
            break;
          }

          message.ichatRestrictType = reader.int32();
          continue;
        }
        case 1028: {
          if (tag !== 8226) {
            break;
          }

          message.idStr = reader.string();
          continue;
        }
        case 1029: {
          if (tag !== 8232) {
            break;
          }

          message.isFollower = reader.bool();
          continue;
        }
        case 1030: {
          if (tag !== 8240) {
            break;
          }

          message.isFollowing = reader.bool();
          continue;
        }
        case 1031: {
          if (tag !== 8248) {
            break;
          }

          message.needProfileGuide = reader.bool();
          continue;
        }
        case 1033: {
          if (tag !== 8264) {
            break;
          }

          message.pushCommentStatus = reader.bool();
          continue;
        }
        case 1034: {
          if (tag !== 8272) {
            break;
          }

          message.pushDigg = reader.bool();
          continue;
        }
        case 1035: {
          if (tag !== 8280) {
            break;
          }

          message.pushFollow = reader.bool();
          continue;
        }
        case 1036: {
          if (tag !== 8288) {
            break;
          }

          message.pushFriendAction = reader.bool();
          continue;
        }
        case 1037: {
          if (tag !== 8296) {
            break;
          }

          message.pushIchat = reader.bool();
          continue;
        }
        case 1038: {
          if (tag !== 8304) {
            break;
          }

          message.pushStatus = reader.bool();
          continue;
        }
        case 1039: {
          if (tag !== 8312) {
            break;
          }

          message.pushVideoPost = reader.bool();
          continue;
        }
        case 1040: {
          if (tag !== 8320) {
            break;
          }

          message.pushVideoRecommend = reader.bool();
          continue;
        }
        case 1043: {
          if (tag !== 8346) {
            break;
          }

          message.verifiedReason = reader.string();
          continue;
        }
        case 1044: {
          if (tag !== 8352) {
            break;
          }

          message.enableCarManagementPermission = reader.bool();
          continue;
        }
        case 1045: {
          if (tag !== 8362) {
            break;
          }

          message.upcomingEventList.push(User_LiveEventInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 1046: {
          if (tag !== 8370) {
            break;
          }

          message.scmLabel = reader.string();
          continue;
        }
        case 1047: {
          if (tag !== 8378) {
            break;
          }

          message.ecommerceEntrance = User_EcommerceEntrance.decode(reader, reader.uint32());
          continue;
        }
        case 1048: {
          if (tag !== 8384) {
            break;
          }

          message.isBlock = reader.bool();
          continue;
        }
        case 1090: {
          if (tag !== 8720) {
            break;
          }

          message.isSubscribe = reader.bool();
          continue;
        }
        case 1091: {
          if (tag !== 8728) {
            break;
          }

          message.isAnchorMarked = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.userId = object.userId ?? "0";
    message.nickname = object.nickname ?? "";
    message.bioDescription = object.bioDescription ?? "";
    message.profilePicture = (object.profilePicture !== undefined && object.profilePicture !== null)
      ? Image.fromPartial(object.profilePicture)
      : undefined;
    message.profilePictureMedium = (object.profilePictureMedium !== undefined && object.profilePictureMedium !== null)
      ? Image.fromPartial(object.profilePictureMedium)
      : undefined;
    message.profilePictureLarge = (object.profilePictureLarge !== undefined && object.profilePictureLarge !== null)
      ? Image.fromPartial(object.profilePictureLarge)
      : undefined;
    message.verified = object.verified ?? false;
    message.status = object.status ?? 0;
    message.createTime = object.createTime ?? "0";
    message.modifyTime = object.modifyTime ?? "0";
    message.secret = object.secret ?? 0;
    message.shareQrcodeUri = object.shareQrcodeUri ?? "";
    message.badgeImageList = object.badgeImageList?.map((e) => Image.fromPartial(e)) || [];
    message.followInfo = (object.followInfo !== undefined && object.followInfo !== null)
      ? User_FollowInfo.fromPartial(object.followInfo)
      : undefined;
    message.userHonor = (object.userHonor !== undefined && object.userHonor !== null)
      ? UserHonor.fromPartial(object.userHonor)
      : undefined;
    message.fansClub = (object.fansClub !== undefined && object.fansClub !== null)
      ? FansClubMember.fromPartial(object.fansClub)
      : undefined;
    message.border = (object.border !== undefined && object.border !== null)
      ? BorderInfo.fromPartial(object.border)
      : undefined;
    message.specialId = object.specialId ?? "";
    message.avatarBorder = (object.avatarBorder !== undefined && object.avatarBorder !== null)
      ? Image.fromPartial(object.avatarBorder)
      : undefined;
    message.medal = (object.medal !== undefined && object.medal !== null) ? Image.fromPartial(object.medal) : undefined;
    message.userBadges = object.userBadges?.map((e) => Image.fromPartial(e)) || [];
    message.newUserBadges = object.newUserBadges?.map((e) => Image.fromPartial(e)) || [];
    message.topVipNo = object.topVipNo ?? 0;
    message.userAttr = (object.userAttr !== undefined && object.userAttr !== null)
      ? User_UserAttr.fromPartial(object.userAttr)
      : undefined;
    message.ownRoom = (object.ownRoom !== undefined && object.ownRoom !== null)
      ? User_OwnRoom.fromPartial(object.ownRoom)
      : undefined;
    message.payScore = object.payScore ?? "0";
    message.fanTicketCount = object.fanTicketCount ?? "0";
    message.anchorInfo = (object.anchorInfo !== undefined && object.anchorInfo !== null)
      ? User_AnchorLevel.fromPartial(object.anchorInfo)
      : undefined;
    message.linkMicStats = object.linkMicStats ?? 0;
    message.uniqueId = object.uniqueId ?? "";
    message.enableShowCommerceSale = object.enableShowCommerceSale ?? false;
    message.withFusionShopEntry = object.withFusionShopEntry ?? false;
    message.payScores = object.payScores ?? "0";
    message.anchorLevel = (object.anchorLevel !== undefined && object.anchorLevel !== null)
      ? User_AnchorLevel.fromPartial(object.anchorLevel)
      : undefined;
    message.verifiedContent = object.verifiedContent ?? "";
    message.authorInfo = (object.authorInfo !== undefined && object.authorInfo !== null)
      ? Author.fromPartial(object.authorInfo)
      : undefined;
    message.topFans = object.topFans?.map((e) => User.fromPartial(e)) || [];
    message.secUid = object.secUid ?? "";
    message.userRole = object.userRole ?? 0;
    message.rewardInfo = (object.rewardInfo !== undefined && object.rewardInfo !== null)
      ? User_ActivityInfo.fromPartial(object.rewardInfo)
      : undefined;
    message.personalCard = (object.personalCard !== undefined && object.personalCard !== null)
      ? Image.fromPartial(object.personalCard)
      : undefined;
    message.authenticationInfo = (object.authenticationInfo !== undefined && object.authenticationInfo !== null)
      ? User_AuthenticationInfo.fromPartial(object.authenticationInfo)
      : undefined;
    message.mediaBadgeImageList = object.mediaBadgeImageList?.map((e) => Image.fromPartial(e)) || [];
    message.commerceWebcastConfigIds = object.commerceWebcastConfigIds?.map((e) => e) || [];
    message.borders = object.borders?.map((e) => BorderInfo.fromPartial(e)) || [];
    message.comboBadgeInfo = (object.comboBadgeInfo !== undefined && object.comboBadgeInfo !== null)
      ? User_ComboBadgeInfo.fromPartial(object.comboBadgeInfo)
      : undefined;
    message.subscribeInfo = (object.subscribeInfo !== undefined && object.subscribeInfo !== null)
      ? User_SubscribeInfo.fromPartial(object.subscribeInfo)
      : undefined;
    message.badges = object.badges?.map((e) => BadgeStruct.fromPartial(e)) || [];
    message.mintTypeLabel = object.mintTypeLabel?.map((e) => e) || [];
    message.fansClubInfo = (object.fansClubInfo !== undefined && object.fansClubInfo !== null)
      ? User_FansClubInfo.fromPartial(object.fansClubInfo)
      : undefined;
    message.allowFindByContacts = object.allowFindByContacts ?? false;
    message.allowOthersDownloadVideo = object.allowOthersDownloadVideo ?? false;
    message.allowOthersDownloadWhenSharingVideo = object.allowOthersDownloadWhenSharingVideo ?? false;
    message.allowShareShowProfile = object.allowShareShowProfile ?? false;
    message.allowShowInGossip = object.allowShowInGossip ?? false;
    message.allowShowMyAction = object.allowShowMyAction ?? false;
    message.allowStrangeComment = object.allowStrangeComment ?? false;
    message.allowUnfollowerComment = object.allowUnfollowerComment ?? false;
    message.allowUseLinkmic = object.allowUseLinkmic ?? false;
    message.avatarJpg = (object.avatarJpg !== undefined && object.avatarJpg !== null)
      ? Image.fromPartial(object.avatarJpg)
      : undefined;
    message.backgroundImgUrl = object.backgroundImgUrl ?? "";
    message.blockStatus = object.blockStatus ?? 0;
    message.commentRestrict = object.commentRestrict ?? 0;
    message.constellation = object.constellation ?? "";
    message.disableIchat = object.disableIchat ?? 0;
    message.enableIchatImg = object.enableIchatImg ?? "0";
    message.exp = object.exp ?? 0;
    message.foldStrangerChat = object.foldStrangerChat ?? false;
    message.followStatus = object.followStatus ?? "0";
    message.ichatRestrictType = object.ichatRestrictType ?? 0;
    message.idStr = object.idStr ?? "";
    message.isFollower = object.isFollower ?? false;
    message.isFollowing = object.isFollowing ?? false;
    message.needProfileGuide = object.needProfileGuide ?? false;
    message.pushCommentStatus = object.pushCommentStatus ?? false;
    message.pushDigg = object.pushDigg ?? false;
    message.pushFollow = object.pushFollow ?? false;
    message.pushFriendAction = object.pushFriendAction ?? false;
    message.pushIchat = object.pushIchat ?? false;
    message.pushStatus = object.pushStatus ?? false;
    message.pushVideoPost = object.pushVideoPost ?? false;
    message.pushVideoRecommend = object.pushVideoRecommend ?? false;
    message.verifiedReason = object.verifiedReason ?? "";
    message.enableCarManagementPermission = object.enableCarManagementPermission ?? false;
    message.upcomingEventList = object.upcomingEventList?.map((e) => User_LiveEventInfo.fromPartial(e)) || [];
    message.scmLabel = object.scmLabel ?? "";
    message.ecommerceEntrance = (object.ecommerceEntrance !== undefined && object.ecommerceEntrance !== null)
      ? User_EcommerceEntrance.fromPartial(object.ecommerceEntrance)
      : undefined;
    message.isBlock = object.isBlock ?? false;
    message.isSubscribe = object.isSubscribe ?? false;
    message.isAnchorMarked = object.isAnchorMarked ?? false;
    return message;
  },
};

function createBaseUser_LiveEventInfo(): User_LiveEventInfo {
  return {
    eventId: "0",
    startTime: "0",
    duration: "0",
    title: "",
    description: "",
    hasSubscribed: false,
    isPaidEvent: false,
    ticketAmount: "0",
    payMethod: "0",
  };
}

export const User_LiveEventInfo: MessageFns<User_LiveEventInfo> = {
  encode(message: User_LiveEventInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "0") {
      writer.uint32(8).int64(message.eventId);
    }
    if (message.startTime !== "0") {
      writer.uint32(16).int64(message.startTime);
    }
    if (message.duration !== "0") {
      writer.uint32(24).int64(message.duration);
    }
    if (message.title !== "") {
      writer.uint32(34).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.hasSubscribed !== false) {
      writer.uint32(48).bool(message.hasSubscribed);
    }
    if (message.isPaidEvent !== false) {
      writer.uint32(56).bool(message.isPaidEvent);
    }
    if (message.ticketAmount !== "0") {
      writer.uint32(64).int64(message.ticketAmount);
    }
    if (message.payMethod !== "0") {
      writer.uint32(72).int64(message.payMethod);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_LiveEventInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_LiveEventInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.eventId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.startTime = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.duration = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.hasSubscribed = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isPaidEvent = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.ticketAmount = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.payMethod = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_LiveEventInfo>, I>>(base?: I): User_LiveEventInfo {
    return User_LiveEventInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_LiveEventInfo>, I>>(object: I): User_LiveEventInfo {
    const message = createBaseUser_LiveEventInfo();
    message.eventId = object.eventId ?? "0";
    message.startTime = object.startTime ?? "0";
    message.duration = object.duration ?? "0";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.hasSubscribed = object.hasSubscribed ?? false;
    message.isPaidEvent = object.isPaidEvent ?? false;
    message.ticketAmount = object.ticketAmount ?? "0";
    message.payMethod = object.payMethod ?? "0";
    return message;
  },
};

function createBaseUser_LiveEventInfo_WalletPackage(): User_LiveEventInfo_WalletPackage {
  return { iapId: "", usdPriceShow: "" };
}

export const User_LiveEventInfo_WalletPackage: MessageFns<User_LiveEventInfo_WalletPackage> = {
  encode(message: User_LiveEventInfo_WalletPackage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iapId !== "") {
      writer.uint32(10).string(message.iapId);
    }
    if (message.usdPriceShow !== "") {
      writer.uint32(18).string(message.usdPriceShow);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_LiveEventInfo_WalletPackage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_LiveEventInfo_WalletPackage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.iapId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.usdPriceShow = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_LiveEventInfo_WalletPackage>, I>>(
    base?: I,
  ): User_LiveEventInfo_WalletPackage {
    return User_LiveEventInfo_WalletPackage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_LiveEventInfo_WalletPackage>, I>>(
    object: I,
  ): User_LiveEventInfo_WalletPackage {
    const message = createBaseUser_LiveEventInfo_WalletPackage();
    message.iapId = object.iapId ?? "";
    message.usdPriceShow = object.usdPriceShow ?? "";
    return message;
  },
};

function createBaseUser_ActivityInfo(): User_ActivityInfo {
  return { badge: undefined, storytag: undefined };
}

export const User_ActivityInfo: MessageFns<User_ActivityInfo> = {
  encode(message: User_ActivityInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.badge !== undefined) {
      Image.encode(message.badge, writer.uint32(10).fork()).join();
    }
    if (message.storytag !== undefined) {
      Image.encode(message.storytag, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_ActivityInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_ActivityInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.badge = Image.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.storytag = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_ActivityInfo>, I>>(base?: I): User_ActivityInfo {
    return User_ActivityInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_ActivityInfo>, I>>(object: I): User_ActivityInfo {
    const message = createBaseUser_ActivityInfo();
    message.badge = (object.badge !== undefined && object.badge !== null) ? Image.fromPartial(object.badge) : undefined;
    message.storytag = (object.storytag !== undefined && object.storytag !== null)
      ? Image.fromPartial(object.storytag)
      : undefined;
    return message;
  },
};

function createBaseUser_AnchorLevel(): User_AnchorLevel {
  return {
    level: "0",
    experience: "0",
    lowestExperienceThisLevel: "0",
    highestExperienceThisLevel: "0",
    taskStartExperience: "0",
    taskStartTime: "0",
    taskDecreaseExperience: "0",
    taskTargetExperience: "0",
    taskEndTime: "0",
    profileDialogBg: undefined,
    profileDialogBgBack: undefined,
    stageLevel: undefined,
    smallIcon: undefined,
  };
}

export const User_AnchorLevel: MessageFns<User_AnchorLevel> = {
  encode(message: User_AnchorLevel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.level !== "0") {
      writer.uint32(8).int64(message.level);
    }
    if (message.experience !== "0") {
      writer.uint32(16).int64(message.experience);
    }
    if (message.lowestExperienceThisLevel !== "0") {
      writer.uint32(24).int64(message.lowestExperienceThisLevel);
    }
    if (message.highestExperienceThisLevel !== "0") {
      writer.uint32(32).int64(message.highestExperienceThisLevel);
    }
    if (message.taskStartExperience !== "0") {
      writer.uint32(40).int64(message.taskStartExperience);
    }
    if (message.taskStartTime !== "0") {
      writer.uint32(48).int64(message.taskStartTime);
    }
    if (message.taskDecreaseExperience !== "0") {
      writer.uint32(56).int64(message.taskDecreaseExperience);
    }
    if (message.taskTargetExperience !== "0") {
      writer.uint32(64).int64(message.taskTargetExperience);
    }
    if (message.taskEndTime !== "0") {
      writer.uint32(72).int64(message.taskEndTime);
    }
    if (message.profileDialogBg !== undefined) {
      Image.encode(message.profileDialogBg, writer.uint32(82).fork()).join();
    }
    if (message.profileDialogBgBack !== undefined) {
      Image.encode(message.profileDialogBgBack, writer.uint32(90).fork()).join();
    }
    if (message.stageLevel !== undefined) {
      Image.encode(message.stageLevel, writer.uint32(98).fork()).join();
    }
    if (message.smallIcon !== undefined) {
      Image.encode(message.smallIcon, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_AnchorLevel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_AnchorLevel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.level = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.experience = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lowestExperienceThisLevel = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.highestExperienceThisLevel = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.taskStartExperience = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.taskStartTime = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.taskDecreaseExperience = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.taskTargetExperience = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.taskEndTime = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.profileDialogBg = Image.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.profileDialogBgBack = Image.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.stageLevel = Image.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.smallIcon = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_AnchorLevel>, I>>(base?: I): User_AnchorLevel {
    return User_AnchorLevel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_AnchorLevel>, I>>(object: I): User_AnchorLevel {
    const message = createBaseUser_AnchorLevel();
    message.level = object.level ?? "0";
    message.experience = object.experience ?? "0";
    message.lowestExperienceThisLevel = object.lowestExperienceThisLevel ?? "0";
    message.highestExperienceThisLevel = object.highestExperienceThisLevel ?? "0";
    message.taskStartExperience = object.taskStartExperience ?? "0";
    message.taskStartTime = object.taskStartTime ?? "0";
    message.taskDecreaseExperience = object.taskDecreaseExperience ?? "0";
    message.taskTargetExperience = object.taskTargetExperience ?? "0";
    message.taskEndTime = object.taskEndTime ?? "0";
    message.profileDialogBg = (object.profileDialogBg !== undefined && object.profileDialogBg !== null)
      ? Image.fromPartial(object.profileDialogBg)
      : undefined;
    message.profileDialogBgBack = (object.profileDialogBgBack !== undefined && object.profileDialogBgBack !== null)
      ? Image.fromPartial(object.profileDialogBgBack)
      : undefined;
    message.stageLevel = (object.stageLevel !== undefined && object.stageLevel !== null)
      ? Image.fromPartial(object.stageLevel)
      : undefined;
    message.smallIcon = (object.smallIcon !== undefined && object.smallIcon !== null)
      ? Image.fromPartial(object.smallIcon)
      : undefined;
    return message;
  },
};

function createBaseUser_AuthenticationInfo(): User_AuthenticationInfo {
  return { customVerify: "", enterpriseVerifyReason: "", authenticationBadge: undefined };
}

export const User_AuthenticationInfo: MessageFns<User_AuthenticationInfo> = {
  encode(message: User_AuthenticationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customVerify !== "") {
      writer.uint32(10).string(message.customVerify);
    }
    if (message.enterpriseVerifyReason !== "") {
      writer.uint32(18).string(message.enterpriseVerifyReason);
    }
    if (message.authenticationBadge !== undefined) {
      Image.encode(message.authenticationBadge, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_AuthenticationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_AuthenticationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.customVerify = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.enterpriseVerifyReason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authenticationBadge = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_AuthenticationInfo>, I>>(base?: I): User_AuthenticationInfo {
    return User_AuthenticationInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_AuthenticationInfo>, I>>(object: I): User_AuthenticationInfo {
    const message = createBaseUser_AuthenticationInfo();
    message.customVerify = object.customVerify ?? "";
    message.enterpriseVerifyReason = object.enterpriseVerifyReason ?? "";
    message.authenticationBadge = (object.authenticationBadge !== undefined && object.authenticationBadge !== null)
      ? Image.fromPartial(object.authenticationBadge)
      : undefined;
    return message;
  },
};

function createBaseUser_AuthorStats(): User_AuthorStats {
  return {
    videoTotalCount: "0",
    videoTotalPlayCount: "0",
    videoTotalShareCount: "0",
    videoTotalSeriesCount: "0",
    varietyShowPlayCount: "0",
    videoTotalFavoriteCount: "0",
  };
}

export const User_AuthorStats: MessageFns<User_AuthorStats> = {
  encode(message: User_AuthorStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoTotalCount !== "0") {
      writer.uint32(8).int64(message.videoTotalCount);
    }
    if (message.videoTotalPlayCount !== "0") {
      writer.uint32(16).int64(message.videoTotalPlayCount);
    }
    if (message.videoTotalShareCount !== "0") {
      writer.uint32(24).int64(message.videoTotalShareCount);
    }
    if (message.videoTotalSeriesCount !== "0") {
      writer.uint32(32).int64(message.videoTotalSeriesCount);
    }
    if (message.varietyShowPlayCount !== "0") {
      writer.uint32(40).int64(message.varietyShowPlayCount);
    }
    if (message.videoTotalFavoriteCount !== "0") {
      writer.uint32(48).int64(message.videoTotalFavoriteCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_AuthorStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_AuthorStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.videoTotalCount = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.videoTotalPlayCount = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.videoTotalShareCount = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.videoTotalSeriesCount = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.varietyShowPlayCount = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.videoTotalFavoriteCount = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_AuthorStats>, I>>(base?: I): User_AuthorStats {
    return User_AuthorStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_AuthorStats>, I>>(object: I): User_AuthorStats {
    const message = createBaseUser_AuthorStats();
    message.videoTotalCount = object.videoTotalCount ?? "0";
    message.videoTotalPlayCount = object.videoTotalPlayCount ?? "0";
    message.videoTotalShareCount = object.videoTotalShareCount ?? "0";
    message.videoTotalSeriesCount = object.videoTotalSeriesCount ?? "0";
    message.varietyShowPlayCount = object.varietyShowPlayCount ?? "0";
    message.videoTotalFavoriteCount = object.videoTotalFavoriteCount ?? "0";
    return message;
  },
};

function createBaseUser_Border(): User_Border {
  return {
    icon: undefined,
    level: "0",
    source: "",
    profileDecorationRibbon: undefined,
    avatarBackgroundColor: "",
    avatarBackgroundBorderColor: "",
  };
}

export const User_Border: MessageFns<User_Border> = {
  encode(message: User_Border, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.icon !== undefined) {
      Image.encode(message.icon, writer.uint32(10).fork()).join();
    }
    if (message.level !== "0") {
      writer.uint32(16).int64(message.level);
    }
    if (message.source !== "") {
      writer.uint32(26).string(message.source);
    }
    if (message.profileDecorationRibbon !== undefined) {
      Image.encode(message.profileDecorationRibbon, writer.uint32(34).fork()).join();
    }
    if (message.avatarBackgroundColor !== "") {
      writer.uint32(58).string(message.avatarBackgroundColor);
    }
    if (message.avatarBackgroundBorderColor !== "") {
      writer.uint32(66).string(message.avatarBackgroundBorderColor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_Border {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_Border();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.icon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.level = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.profileDecorationRibbon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.avatarBackgroundColor = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.avatarBackgroundBorderColor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_Border>, I>>(base?: I): User_Border {
    return User_Border.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_Border>, I>>(object: I): User_Border {
    const message = createBaseUser_Border();
    message.icon = (object.icon !== undefined && object.icon !== null) ? Image.fromPartial(object.icon) : undefined;
    message.level = object.level ?? "0";
    message.source = object.source ?? "";
    message.profileDecorationRibbon =
      (object.profileDecorationRibbon !== undefined && object.profileDecorationRibbon !== null)
        ? Image.fromPartial(object.profileDecorationRibbon)
        : undefined;
    message.avatarBackgroundColor = object.avatarBackgroundColor ?? "";
    message.avatarBackgroundBorderColor = object.avatarBackgroundBorderColor ?? "";
    return message;
  },
};

function createBaseUser_ComboBadgeInfo(): User_ComboBadgeInfo {
  return { icon: undefined, comboCount: "0" };
}

export const User_ComboBadgeInfo: MessageFns<User_ComboBadgeInfo> = {
  encode(message: User_ComboBadgeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.icon !== undefined) {
      Image.encode(message.icon, writer.uint32(10).fork()).join();
    }
    if (message.comboCount !== "0") {
      writer.uint32(16).int64(message.comboCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_ComboBadgeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_ComboBadgeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.icon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.comboCount = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_ComboBadgeInfo>, I>>(base?: I): User_ComboBadgeInfo {
    return User_ComboBadgeInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_ComboBadgeInfo>, I>>(object: I): User_ComboBadgeInfo {
    const message = createBaseUser_ComboBadgeInfo();
    message.icon = (object.icon !== undefined && object.icon !== null) ? Image.fromPartial(object.icon) : undefined;
    message.comboCount = object.comboCount ?? "0";
    return message;
  },
};

function createBaseUser_EcommerceEntrance(): User_EcommerceEntrance {
  return { entranceType: 0, creatorType: 0, schema: "", shopEntranceInfo: undefined, showcaseEntranceInfo: undefined };
}

export const User_EcommerceEntrance: MessageFns<User_EcommerceEntrance> = {
  encode(message: User_EcommerceEntrance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entranceType !== 0) {
      writer.uint32(8).int32(message.entranceType);
    }
    if (message.creatorType !== 0) {
      writer.uint32(16).int32(message.creatorType);
    }
    if (message.schema !== "") {
      writer.uint32(26).string(message.schema);
    }
    if (message.shopEntranceInfo !== undefined) {
      User_EcommerceEntrance_ShopEntranceInfo.encode(message.shopEntranceInfo, writer.uint32(34).fork()).join();
    }
    if (message.showcaseEntranceInfo !== undefined) {
      User_EcommerceEntrance_ShowcaseEntranceInfo.encode(message.showcaseEntranceInfo, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_EcommerceEntrance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_EcommerceEntrance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.entranceType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.creatorType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shopEntranceInfo = User_EcommerceEntrance_ShopEntranceInfo.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.showcaseEntranceInfo = User_EcommerceEntrance_ShowcaseEntranceInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_EcommerceEntrance>, I>>(base?: I): User_EcommerceEntrance {
    return User_EcommerceEntrance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_EcommerceEntrance>, I>>(object: I): User_EcommerceEntrance {
    const message = createBaseUser_EcommerceEntrance();
    message.entranceType = object.entranceType ?? 0;
    message.creatorType = object.creatorType ?? 0;
    message.schema = object.schema ?? "";
    message.shopEntranceInfo = (object.shopEntranceInfo !== undefined && object.shopEntranceInfo !== null)
      ? User_EcommerceEntrance_ShopEntranceInfo.fromPartial(object.shopEntranceInfo)
      : undefined;
    message.showcaseEntranceInfo = (object.showcaseEntranceInfo !== undefined && object.showcaseEntranceInfo !== null)
      ? User_EcommerceEntrance_ShowcaseEntranceInfo.fromPartial(object.showcaseEntranceInfo)
      : undefined;
    return message;
  },
};

function createBaseUser_EcommerceEntrance_ShopEntranceInfo(): User_EcommerceEntrance_ShopEntranceInfo {
  return {
    shopId: "",
    shopName: "",
    shopRating: "",
    storeLabel: undefined,
    formatSoldCount: "",
    soldCount: "0",
    expRatePercentile: 0,
    expRateTopDisplay: "",
    rateDisplayStyle: 0,
    showRateNotApplicable: false,
  };
}

export const User_EcommerceEntrance_ShopEntranceInfo: MessageFns<User_EcommerceEntrance_ShopEntranceInfo> = {
  encode(message: User_EcommerceEntrance_ShopEntranceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shopId !== "") {
      writer.uint32(10).string(message.shopId);
    }
    if (message.shopName !== "") {
      writer.uint32(18).string(message.shopName);
    }
    if (message.shopRating !== "") {
      writer.uint32(26).string(message.shopRating);
    }
    if (message.storeLabel !== undefined) {
      User_EcommerceEntrance_ShopEntranceInfo_StoreLabel.encode(message.storeLabel, writer.uint32(34).fork()).join();
    }
    if (message.formatSoldCount !== "") {
      writer.uint32(42).string(message.formatSoldCount);
    }
    if (message.soldCount !== "0") {
      writer.uint32(48).int64(message.soldCount);
    }
    if (message.expRatePercentile !== 0) {
      writer.uint32(56).int32(message.expRatePercentile);
    }
    if (message.expRateTopDisplay !== "") {
      writer.uint32(66).string(message.expRateTopDisplay);
    }
    if (message.rateDisplayStyle !== 0) {
      writer.uint32(72).int32(message.rateDisplayStyle);
    }
    if (message.showRateNotApplicable !== false) {
      writer.uint32(80).bool(message.showRateNotApplicable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_EcommerceEntrance_ShopEntranceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_EcommerceEntrance_ShopEntranceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shopId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.shopName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.shopRating = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.storeLabel = User_EcommerceEntrance_ShopEntranceInfo_StoreLabel.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.formatSoldCount = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.soldCount = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.expRatePercentile = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.expRateTopDisplay = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.rateDisplayStyle = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.showRateNotApplicable = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_EcommerceEntrance_ShopEntranceInfo>, I>>(
    base?: I,
  ): User_EcommerceEntrance_ShopEntranceInfo {
    return User_EcommerceEntrance_ShopEntranceInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_EcommerceEntrance_ShopEntranceInfo>, I>>(
    object: I,
  ): User_EcommerceEntrance_ShopEntranceInfo {
    const message = createBaseUser_EcommerceEntrance_ShopEntranceInfo();
    message.shopId = object.shopId ?? "";
    message.shopName = object.shopName ?? "";
    message.shopRating = object.shopRating ?? "";
    message.storeLabel = (object.storeLabel !== undefined && object.storeLabel !== null)
      ? User_EcommerceEntrance_ShopEntranceInfo_StoreLabel.fromPartial(object.storeLabel)
      : undefined;
    message.formatSoldCount = object.formatSoldCount ?? "";
    message.soldCount = object.soldCount ?? "0";
    message.expRatePercentile = object.expRatePercentile ?? 0;
    message.expRateTopDisplay = object.expRateTopDisplay ?? "";
    message.rateDisplayStyle = object.rateDisplayStyle ?? 0;
    message.showRateNotApplicable = object.showRateNotApplicable ?? false;
    return message;
  },
};

function createBaseUser_EcommerceEntrance_ShopEntranceInfo_StoreLabel(): User_EcommerceEntrance_ShopEntranceInfo_StoreLabel {
  return { officialLabel: undefined, isBytemall: false };
}

export const User_EcommerceEntrance_ShopEntranceInfo_StoreLabel: MessageFns<
  User_EcommerceEntrance_ShopEntranceInfo_StoreLabel
> = {
  encode(
    message: User_EcommerceEntrance_ShopEntranceInfo_StoreLabel,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.officialLabel !== undefined) {
      User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel.encode(
        message.officialLabel,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.isBytemall !== false) {
      writer.uint32(16).bool(message.isBytemall);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_EcommerceEntrance_ShopEntranceInfo_StoreLabel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_EcommerceEntrance_ShopEntranceInfo_StoreLabel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.officialLabel = User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isBytemall = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_EcommerceEntrance_ShopEntranceInfo_StoreLabel>, I>>(
    base?: I,
  ): User_EcommerceEntrance_ShopEntranceInfo_StoreLabel {
    return User_EcommerceEntrance_ShopEntranceInfo_StoreLabel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_EcommerceEntrance_ShopEntranceInfo_StoreLabel>, I>>(
    object: I,
  ): User_EcommerceEntrance_ShopEntranceInfo_StoreLabel {
    const message = createBaseUser_EcommerceEntrance_ShopEntranceInfo_StoreLabel();
    message.officialLabel = (object.officialLabel !== undefined && object.officialLabel !== null)
      ? User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel.fromPartial(object.officialLabel)
      : undefined;
    message.isBytemall = object.isBytemall ?? false;
    return message;
  },
};

function createBaseUser_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel(): User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel {
  return { labelImageLight: undefined, labelImageDark: undefined, labelType: "0", labelTypeStr: "" };
}

export const User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel: MessageFns<
  User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel
> = {
  encode(
    message: User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.labelImageLight !== undefined) {
      User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage.encode(
        message.labelImageLight,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.labelImageDark !== undefined) {
      User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage.encode(
        message.labelImageDark,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.labelType !== "0") {
      writer.uint32(24).int64(message.labelType);
    }
    if (message.labelTypeStr !== "") {
      writer.uint32(34).string(message.labelTypeStr);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.labelImageLight = User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage
            .decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.labelImageDark = User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage
            .decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.labelType = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.labelTypeStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel>, I>>(
    base?: I,
  ): User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel {
    return User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel>, I>>(
    object: I,
  ): User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel {
    const message = createBaseUser_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel();
    message.labelImageLight = (object.labelImageLight !== undefined && object.labelImageLight !== null)
      ? User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage.fromPartial(
        object.labelImageLight,
      )
      : undefined;
    message.labelImageDark = (object.labelImageDark !== undefined && object.labelImageDark !== null)
      ? User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage.fromPartial(
        object.labelImageDark,
      )
      : undefined;
    message.labelType = object.labelType ?? "0";
    message.labelTypeStr = object.labelTypeStr ?? "";
    return message;
  },
};

function createBaseUser_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage(): User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage {
  return { height: 0, width: 0, minetype: "", thumbUri: "", thumbUriList: [], uri: "", urlList: [], color: "" };
}

export const User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage: MessageFns<
  User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage
> = {
  encode(
    message: User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.height !== 0) {
      writer.uint32(8).int32(message.height);
    }
    if (message.width !== 0) {
      writer.uint32(16).int32(message.width);
    }
    if (message.minetype !== "") {
      writer.uint32(26).string(message.minetype);
    }
    if (message.thumbUri !== "") {
      writer.uint32(34).string(message.thumbUri);
    }
    for (const v of message.thumbUriList) {
      writer.uint32(42).string(v!);
    }
    if (message.uri !== "") {
      writer.uint32(50).string(message.uri);
    }
    for (const v of message.urlList) {
      writer.uint32(58).string(v!);
    }
    if (message.color !== "") {
      writer.uint32(66).string(message.color);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.minetype = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.thumbUri = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.thumbUriList.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.urlList.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.color = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<
    I extends Exact<
      DeepPartial<User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage>,
      I
    >,
  >(base?: I): User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage {
    return User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage.fromPartial(
      base ?? ({} as any),
    );
  },
  fromPartial<
    I extends Exact<
      DeepPartial<User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage>,
      I
    >,
  >(object: I): User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage {
    const message = createBaseUser_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage();
    message.height = object.height ?? 0;
    message.width = object.width ?? 0;
    message.minetype = object.minetype ?? "";
    message.thumbUri = object.thumbUri ?? "";
    message.thumbUriList = object.thumbUriList?.map((e) => e) || [];
    message.uri = object.uri ?? "";
    message.urlList = object.urlList?.map((e) => e) || [];
    message.color = object.color ?? "";
    return message;
  },
};

function createBaseUser_EcommerceEntrance_ShowcaseEntranceInfo(): User_EcommerceEntrance_ShowcaseEntranceInfo {
  return { formatSoldCount: "", soldCount: "0" };
}

export const User_EcommerceEntrance_ShowcaseEntranceInfo: MessageFns<User_EcommerceEntrance_ShowcaseEntranceInfo> = {
  encode(
    message: User_EcommerceEntrance_ShowcaseEntranceInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.formatSoldCount !== "") {
      writer.uint32(10).string(message.formatSoldCount);
    }
    if (message.soldCount !== "0") {
      writer.uint32(16).int64(message.soldCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_EcommerceEntrance_ShowcaseEntranceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_EcommerceEntrance_ShowcaseEntranceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.formatSoldCount = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.soldCount = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_EcommerceEntrance_ShowcaseEntranceInfo>, I>>(
    base?: I,
  ): User_EcommerceEntrance_ShowcaseEntranceInfo {
    return User_EcommerceEntrance_ShowcaseEntranceInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_EcommerceEntrance_ShowcaseEntranceInfo>, I>>(
    object: I,
  ): User_EcommerceEntrance_ShowcaseEntranceInfo {
    const message = createBaseUser_EcommerceEntrance_ShowcaseEntranceInfo();
    message.formatSoldCount = object.formatSoldCount ?? "";
    message.soldCount = object.soldCount ?? "0";
    return message;
  },
};

function createBaseUser_FansClub(): User_FansClub {
  return { data: undefined };
}

export const User_FansClub: MessageFns<User_FansClub> = {
  encode(message: User_FansClub, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      User_FansClub_FansClubData.encode(message.data, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_FansClub {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_FansClub();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = User_FansClub_FansClubData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_FansClub>, I>>(base?: I): User_FansClub {
    return User_FansClub.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_FansClub>, I>>(object: I): User_FansClub {
    const message = createBaseUser_FansClub();
    message.data = (object.data !== undefined && object.data !== null)
      ? User_FansClub_FansClubData.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function createBaseUser_FansClub_FansClubData(): User_FansClub_FansClubData {
  return { clubName: "", level: 0, userFansClubStatus: 0, availableGiftIdsList: [], anchorId: "0" };
}

export const User_FansClub_FansClubData: MessageFns<User_FansClub_FansClubData> = {
  encode(message: User_FansClub_FansClubData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clubName !== "") {
      writer.uint32(10).string(message.clubName);
    }
    if (message.level !== 0) {
      writer.uint32(16).int32(message.level);
    }
    if (message.userFansClubStatus !== 0) {
      writer.uint32(24).int32(message.userFansClubStatus);
    }
    writer.uint32(42).fork();
    for (const v of message.availableGiftIdsList) {
      writer.int64(v);
    }
    writer.join();
    if (message.anchorId !== "0") {
      writer.uint32(48).int64(message.anchorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_FansClub_FansClubData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_FansClub_FansClubData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clubName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.level = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.userFansClubStatus = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.availableGiftIdsList.push(reader.int64().toString());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.availableGiftIdsList.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.anchorId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_FansClub_FansClubData>, I>>(base?: I): User_FansClub_FansClubData {
    return User_FansClub_FansClubData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_FansClub_FansClubData>, I>>(object: I): User_FansClub_FansClubData {
    const message = createBaseUser_FansClub_FansClubData();
    message.clubName = object.clubName ?? "";
    message.level = object.level ?? 0;
    message.userFansClubStatus = object.userFansClubStatus ?? 0;
    message.availableGiftIdsList = object.availableGiftIdsList?.map((e) => e) || [];
    message.anchorId = object.anchorId ?? "0";
    return message;
  },
};

function createBaseUser_FansClubInfo(): User_FansClubInfo {
  return { isSleeping: false, fansLevel: "0", fansScore: "0", badge: undefined, fansCount: "0", fansClubName: "" };
}

export const User_FansClubInfo: MessageFns<User_FansClubInfo> = {
  encode(message: User_FansClubInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isSleeping !== false) {
      writer.uint32(8).bool(message.isSleeping);
    }
    if (message.fansLevel !== "0") {
      writer.uint32(16).int64(message.fansLevel);
    }
    if (message.fansScore !== "0") {
      writer.uint32(24).int64(message.fansScore);
    }
    if (message.badge !== undefined) {
      Image.encode(message.badge, writer.uint32(34).fork()).join();
    }
    if (message.fansCount !== "0") {
      writer.uint32(40).int64(message.fansCount);
    }
    if (message.fansClubName !== "") {
      writer.uint32(50).string(message.fansClubName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_FansClubInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_FansClubInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isSleeping = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fansLevel = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fansScore = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.badge = Image.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.fansCount = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fansClubName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_FansClubInfo>, I>>(base?: I): User_FansClubInfo {
    return User_FansClubInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_FansClubInfo>, I>>(object: I): User_FansClubInfo {
    const message = createBaseUser_FansClubInfo();
    message.isSleeping = object.isSleeping ?? false;
    message.fansLevel = object.fansLevel ?? "0";
    message.fansScore = object.fansScore ?? "0";
    message.badge = (object.badge !== undefined && object.badge !== null) ? Image.fromPartial(object.badge) : undefined;
    message.fansCount = object.fansCount ?? "0";
    message.fansClubName = object.fansClubName ?? "";
    return message;
  },
};

function createBaseUser_FollowInfo(): User_FollowInfo {
  return { followingCount: "0", followerCount: "0", followStatus: "0", pushStatus: "0" };
}

export const User_FollowInfo: MessageFns<User_FollowInfo> = {
  encode(message: User_FollowInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.followingCount !== "0") {
      writer.uint32(8).int64(message.followingCount);
    }
    if (message.followerCount !== "0") {
      writer.uint32(16).int64(message.followerCount);
    }
    if (message.followStatus !== "0") {
      writer.uint32(24).int64(message.followStatus);
    }
    if (message.pushStatus !== "0") {
      writer.uint32(32).int64(message.pushStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_FollowInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_FollowInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.followingCount = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.followerCount = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.followStatus = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pushStatus = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_FollowInfo>, I>>(base?: I): User_FollowInfo {
    return User_FollowInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_FollowInfo>, I>>(object: I): User_FollowInfo {
    const message = createBaseUser_FollowInfo();
    message.followingCount = object.followingCount ?? "0";
    message.followerCount = object.followerCount ?? "0";
    message.followStatus = object.followStatus ?? "0";
    message.pushStatus = object.pushStatus ?? "0";
    return message;
  },
};

function createBaseUser_OwnRoom(): User_OwnRoom {
  return { roomIdsList: [], roomIdsStrList: [] };
}

export const User_OwnRoom: MessageFns<User_OwnRoom> = {
  encode(message: User_OwnRoom, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.roomIdsList) {
      writer.int64(v);
    }
    writer.join();
    for (const v of message.roomIdsStrList) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_OwnRoom {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_OwnRoom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.roomIdsList.push(reader.int64().toString());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.roomIdsList.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.roomIdsStrList.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_OwnRoom>, I>>(base?: I): User_OwnRoom {
    return User_OwnRoom.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_OwnRoom>, I>>(object: I): User_OwnRoom {
    const message = createBaseUser_OwnRoom();
    message.roomIdsList = object.roomIdsList?.map((e) => e) || [];
    message.roomIdsStrList = object.roomIdsStrList?.map((e) => e) || [];
    return message;
  },
};

function createBaseUser_PayGrade(): User_PayGrade {
  return {
    diamondIcon: undefined,
    name: "",
    icon: undefined,
    nextName: "",
    level: "0",
    nextIcon: undefined,
    gradeDescribe: "",
    gradeIconList: [],
    screenChatType: "0",
    imIcon: undefined,
    imIconWithLevel: undefined,
    liveIcon: undefined,
    newImIconWithLevel: undefined,
    newLiveIcon: undefined,
    upgradeNeedConsume: "0",
    nextPrivileges: "",
    background: undefined,
    backgroundBack: undefined,
    score: "0",
    gradeBanner: "",
    profileDialogBg: undefined,
    profileDialogBgBack: undefined,
  };
}

export const User_PayGrade: MessageFns<User_PayGrade> = {
  encode(message: User_PayGrade, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.diamondIcon !== undefined) {
      Image.encode(message.diamondIcon, writer.uint32(18).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.icon !== undefined) {
      Image.encode(message.icon, writer.uint32(34).fork()).join();
    }
    if (message.nextName !== "") {
      writer.uint32(42).string(message.nextName);
    }
    if (message.level !== "0") {
      writer.uint32(48).int64(message.level);
    }
    if (message.nextIcon !== undefined) {
      Image.encode(message.nextIcon, writer.uint32(58).fork()).join();
    }
    if (message.gradeDescribe !== "") {
      writer.uint32(106).string(message.gradeDescribe);
    }
    for (const v of message.gradeIconList) {
      GradeIcon.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.screenChatType !== "0") {
      writer.uint32(120).int64(message.screenChatType);
    }
    if (message.imIcon !== undefined) {
      Image.encode(message.imIcon, writer.uint32(130).fork()).join();
    }
    if (message.imIconWithLevel !== undefined) {
      Image.encode(message.imIconWithLevel, writer.uint32(138).fork()).join();
    }
    if (message.liveIcon !== undefined) {
      Image.encode(message.liveIcon, writer.uint32(146).fork()).join();
    }
    if (message.newImIconWithLevel !== undefined) {
      Image.encode(message.newImIconWithLevel, writer.uint32(154).fork()).join();
    }
    if (message.newLiveIcon !== undefined) {
      Image.encode(message.newLiveIcon, writer.uint32(162).fork()).join();
    }
    if (message.upgradeNeedConsume !== "0") {
      writer.uint32(168).int64(message.upgradeNeedConsume);
    }
    if (message.nextPrivileges !== "") {
      writer.uint32(178).string(message.nextPrivileges);
    }
    if (message.background !== undefined) {
      Image.encode(message.background, writer.uint32(186).fork()).join();
    }
    if (message.backgroundBack !== undefined) {
      Image.encode(message.backgroundBack, writer.uint32(194).fork()).join();
    }
    if (message.score !== "0") {
      writer.uint32(200).int64(message.score);
    }
    if (message.gradeBanner !== "") {
      writer.uint32(8010).string(message.gradeBanner);
    }
    if (message.profileDialogBg !== undefined) {
      Image.encode(message.profileDialogBg, writer.uint32(8018).fork()).join();
    }
    if (message.profileDialogBgBack !== undefined) {
      Image.encode(message.profileDialogBgBack, writer.uint32(8026).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_PayGrade {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_PayGrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.diamondIcon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.icon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nextName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.level = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.nextIcon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.gradeDescribe = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.gradeIconList.push(GradeIcon.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.screenChatType = reader.int64().toString();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.imIcon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.imIconWithLevel = Image.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.liveIcon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.newImIconWithLevel = Image.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.newLiveIcon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.upgradeNeedConsume = reader.int64().toString();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.nextPrivileges = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.background = Image.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.backgroundBack = Image.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.score = reader.int64().toString();
          continue;
        }
        case 1001: {
          if (tag !== 8010) {
            break;
          }

          message.gradeBanner = reader.string();
          continue;
        }
        case 1002: {
          if (tag !== 8018) {
            break;
          }

          message.profileDialogBg = Image.decode(reader, reader.uint32());
          continue;
        }
        case 1003: {
          if (tag !== 8026) {
            break;
          }

          message.profileDialogBgBack = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_PayGrade>, I>>(base?: I): User_PayGrade {
    return User_PayGrade.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_PayGrade>, I>>(object: I): User_PayGrade {
    const message = createBaseUser_PayGrade();
    message.diamondIcon = (object.diamondIcon !== undefined && object.diamondIcon !== null)
      ? Image.fromPartial(object.diamondIcon)
      : undefined;
    message.name = object.name ?? "";
    message.icon = (object.icon !== undefined && object.icon !== null) ? Image.fromPartial(object.icon) : undefined;
    message.nextName = object.nextName ?? "";
    message.level = object.level ?? "0";
    message.nextIcon = (object.nextIcon !== undefined && object.nextIcon !== null)
      ? Image.fromPartial(object.nextIcon)
      : undefined;
    message.gradeDescribe = object.gradeDescribe ?? "";
    message.gradeIconList = object.gradeIconList?.map((e) => GradeIcon.fromPartial(e)) || [];
    message.screenChatType = object.screenChatType ?? "0";
    message.imIcon = (object.imIcon !== undefined && object.imIcon !== null)
      ? Image.fromPartial(object.imIcon)
      : undefined;
    message.imIconWithLevel = (object.imIconWithLevel !== undefined && object.imIconWithLevel !== null)
      ? Image.fromPartial(object.imIconWithLevel)
      : undefined;
    message.liveIcon = (object.liveIcon !== undefined && object.liveIcon !== null)
      ? Image.fromPartial(object.liveIcon)
      : undefined;
    message.newImIconWithLevel = (object.newImIconWithLevel !== undefined && object.newImIconWithLevel !== null)
      ? Image.fromPartial(object.newImIconWithLevel)
      : undefined;
    message.newLiveIcon = (object.newLiveIcon !== undefined && object.newLiveIcon !== null)
      ? Image.fromPartial(object.newLiveIcon)
      : undefined;
    message.upgradeNeedConsume = object.upgradeNeedConsume ?? "0";
    message.nextPrivileges = object.nextPrivileges ?? "";
    message.background = (object.background !== undefined && object.background !== null)
      ? Image.fromPartial(object.background)
      : undefined;
    message.backgroundBack = (object.backgroundBack !== undefined && object.backgroundBack !== null)
      ? Image.fromPartial(object.backgroundBack)
      : undefined;
    message.score = object.score ?? "0";
    message.gradeBanner = object.gradeBanner ?? "";
    message.profileDialogBg = (object.profileDialogBg !== undefined && object.profileDialogBg !== null)
      ? Image.fromPartial(object.profileDialogBg)
      : undefined;
    message.profileDialogBgBack = (object.profileDialogBgBack !== undefined && object.profileDialogBgBack !== null)
      ? Image.fromPartial(object.profileDialogBgBack)
      : undefined;
    return message;
  },
};

function createBaseUser_SubscribeBadge(): User_SubscribeBadge {
  return { originImg: undefined, previewImg: undefined };
}

export const User_SubscribeBadge: MessageFns<User_SubscribeBadge> = {
  encode(message: User_SubscribeBadge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.originImg !== undefined) {
      Image.encode(message.originImg, writer.uint32(26).fork()).join();
    }
    if (message.previewImg !== undefined) {
      Image.encode(message.previewImg, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_SubscribeBadge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_SubscribeBadge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.originImg = Image.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.previewImg = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_SubscribeBadge>, I>>(base?: I): User_SubscribeBadge {
    return User_SubscribeBadge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_SubscribeBadge>, I>>(object: I): User_SubscribeBadge {
    const message = createBaseUser_SubscribeBadge();
    message.originImg = (object.originImg !== undefined && object.originImg !== null)
      ? Image.fromPartial(object.originImg)
      : undefined;
    message.previewImg = (object.previewImg !== undefined && object.previewImg !== null)
      ? Image.fromPartial(object.previewImg)
      : undefined;
    return message;
  },
};

function createBaseUser_SubscribeInfo(): User_SubscribeInfo {
  return {
    qualification: false,
    isSubscribe: false,
    badge: undefined,
    enableSubscription: false,
    subscriberCount: "0",
    isInGracePeriod: false,
    isSubscribedToAnchor: false,
    userGiftSubAuth: false,
    anchorGiftSubAuth: false,
  };
}

export const User_SubscribeInfo: MessageFns<User_SubscribeInfo> = {
  encode(message: User_SubscribeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.qualification !== false) {
      writer.uint32(8).bool(message.qualification);
    }
    if (message.isSubscribe !== false) {
      writer.uint32(16).bool(message.isSubscribe);
    }
    if (message.badge !== undefined) {
      User_SubscribeBadge.encode(message.badge, writer.uint32(26).fork()).join();
    }
    if (message.enableSubscription !== false) {
      writer.uint32(32).bool(message.enableSubscription);
    }
    if (message.subscriberCount !== "0") {
      writer.uint32(40).int64(message.subscriberCount);
    }
    if (message.isInGracePeriod !== false) {
      writer.uint32(48).bool(message.isInGracePeriod);
    }
    if (message.isSubscribedToAnchor !== false) {
      writer.uint32(56).bool(message.isSubscribedToAnchor);
    }
    if (message.userGiftSubAuth !== false) {
      writer.uint32(72).bool(message.userGiftSubAuth);
    }
    if (message.anchorGiftSubAuth !== false) {
      writer.uint32(80).bool(message.anchorGiftSubAuth);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_SubscribeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_SubscribeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.qualification = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSubscribe = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.badge = User_SubscribeBadge.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.enableSubscription = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.subscriberCount = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isInGracePeriod = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isSubscribedToAnchor = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.userGiftSubAuth = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.anchorGiftSubAuth = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_SubscribeInfo>, I>>(base?: I): User_SubscribeInfo {
    return User_SubscribeInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_SubscribeInfo>, I>>(object: I): User_SubscribeInfo {
    const message = createBaseUser_SubscribeInfo();
    message.qualification = object.qualification ?? false;
    message.isSubscribe = object.isSubscribe ?? false;
    message.badge = (object.badge !== undefined && object.badge !== null)
      ? User_SubscribeBadge.fromPartial(object.badge)
      : undefined;
    message.enableSubscription = object.enableSubscription ?? false;
    message.subscriberCount = object.subscriberCount ?? "0";
    message.isInGracePeriod = object.isInGracePeriod ?? false;
    message.isSubscribedToAnchor = object.isSubscribedToAnchor ?? false;
    message.userGiftSubAuth = object.userGiftSubAuth ?? false;
    message.anchorGiftSubAuth = object.anchorGiftSubAuth ?? false;
    return message;
  },
};

function createBaseUser_UserAttr(): User_UserAttr {
  return { isMuted: false, isAdmin: false, isSuperAdmin: false, muteDuration: "0" };
}

export const User_UserAttr: MessageFns<User_UserAttr> = {
  encode(message: User_UserAttr, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isMuted !== false) {
      writer.uint32(8).bool(message.isMuted);
    }
    if (message.isAdmin !== false) {
      writer.uint32(16).bool(message.isAdmin);
    }
    if (message.isSuperAdmin !== false) {
      writer.uint32(24).bool(message.isSuperAdmin);
    }
    if (message.muteDuration !== "0") {
      writer.uint32(32).int64(message.muteDuration);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_UserAttr {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_UserAttr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isMuted = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isAdmin = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isSuperAdmin = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.muteDuration = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_UserAttr>, I>>(base?: I): User_UserAttr {
    return User_UserAttr.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_UserAttr>, I>>(object: I): User_UserAttr {
    const message = createBaseUser_UserAttr();
    message.isMuted = object.isMuted ?? false;
    message.isAdmin = object.isAdmin ?? false;
    message.isSuperAdmin = object.isSuperAdmin ?? false;
    message.muteDuration = object.muteDuration ?? "0";
    return message;
  },
};

function createBaseUser_UserStats(): User_UserStats {
  return {
    id: "0",
    idStr: "",
    followingCount: "0",
    followerCount: "0",
    recordCount: "0",
    totalDuration: "0",
    dailyFanTicketCount: "0",
    dailyIncome: "0",
    itemCount: "0",
    favoriteItemCount: "0",
    diamondConsumedCount: "0",
    tuwenItemCount: "0",
  };
}

export const User_UserStats: MessageFns<User_UserStats> = {
  encode(message: User_UserStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.idStr !== "") {
      writer.uint32(18).string(message.idStr);
    }
    if (message.followingCount !== "0") {
      writer.uint32(24).int64(message.followingCount);
    }
    if (message.followerCount !== "0") {
      writer.uint32(32).int64(message.followerCount);
    }
    if (message.recordCount !== "0") {
      writer.uint32(40).int64(message.recordCount);
    }
    if (message.totalDuration !== "0") {
      writer.uint32(48).int64(message.totalDuration);
    }
    if (message.dailyFanTicketCount !== "0") {
      writer.uint32(56).int64(message.dailyFanTicketCount);
    }
    if (message.dailyIncome !== "0") {
      writer.uint32(64).int64(message.dailyIncome);
    }
    if (message.itemCount !== "0") {
      writer.uint32(72).int64(message.itemCount);
    }
    if (message.favoriteItemCount !== "0") {
      writer.uint32(80).int64(message.favoriteItemCount);
    }
    if (message.diamondConsumedCount !== "0") {
      writer.uint32(96).int64(message.diamondConsumedCount);
    }
    if (message.tuwenItemCount !== "0") {
      writer.uint32(104).int64(message.tuwenItemCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_UserStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_UserStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.idStr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.followingCount = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.followerCount = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.recordCount = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.totalDuration = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.dailyFanTicketCount = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.dailyIncome = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.itemCount = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.favoriteItemCount = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.diamondConsumedCount = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.tuwenItemCount = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User_UserStats>, I>>(base?: I): User_UserStats {
    return User_UserStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_UserStats>, I>>(object: I): User_UserStats {
    const message = createBaseUser_UserStats();
    message.id = object.id ?? "0";
    message.idStr = object.idStr ?? "";
    message.followingCount = object.followingCount ?? "0";
    message.followerCount = object.followerCount ?? "0";
    message.recordCount = object.recordCount ?? "0";
    message.totalDuration = object.totalDuration ?? "0";
    message.dailyFanTicketCount = object.dailyFanTicketCount ?? "0";
    message.dailyIncome = object.dailyIncome ?? "0";
    message.itemCount = object.itemCount ?? "0";
    message.favoriteItemCount = object.favoriteItemCount ?? "0";
    message.diamondConsumedCount = object.diamondConsumedCount ?? "0";
    message.tuwenItemCount = object.tuwenItemCount ?? "0";
    return message;
  },
};

function createBaseEmote(): Emote {
  return {
    emoteId: "",
    image: undefined,
    auditStatus: 0,
    uuid: "",
    emoteType: 0,
    contentSource: 0,
    emotePrivateType: 0,
    packageId: "",
    auditInfo: undefined,
    rewardCondition: 0,
    emoteUploadInfo: undefined,
    createTime: "0",
    emoteScene: 0,
  };
}

export const Emote: MessageFns<Emote> = {
  encode(message: Emote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.emoteId !== "") {
      writer.uint32(10).string(message.emoteId);
    }
    if (message.image !== undefined) {
      Image.encode(message.image, writer.uint32(18).fork()).join();
    }
    if (message.auditStatus !== 0) {
      writer.uint32(24).int32(message.auditStatus);
    }
    if (message.uuid !== "") {
      writer.uint32(34).string(message.uuid);
    }
    if (message.emoteType !== 0) {
      writer.uint32(40).int32(message.emoteType);
    }
    if (message.contentSource !== 0) {
      writer.uint32(48).int32(message.contentSource);
    }
    if (message.emotePrivateType !== 0) {
      writer.uint32(56).int32(message.emotePrivateType);
    }
    if (message.packageId !== "") {
      writer.uint32(66).string(message.packageId);
    }
    if (message.auditInfo !== undefined) {
      Emote_AuditInfo.encode(message.auditInfo, writer.uint32(74).fork()).join();
    }
    if (message.rewardCondition !== 0) {
      writer.uint32(80).int32(message.rewardCondition);
    }
    if (message.emoteUploadInfo !== undefined) {
      Emote_EmoteUploadInfo.encode(message.emoteUploadInfo, writer.uint32(90).fork()).join();
    }
    if (message.createTime !== "0") {
      writer.uint32(96).int64(message.createTime);
    }
    if (message.emoteScene !== 0) {
      writer.uint32(104).int32(message.emoteScene);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Emote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.emoteId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.image = Image.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.auditStatus = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.emoteType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.contentSource = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.emotePrivateType = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.packageId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.auditInfo = Emote_AuditInfo.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.rewardCondition = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.emoteUploadInfo = Emote_EmoteUploadInfo.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.createTime = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.emoteScene = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Emote>, I>>(base?: I): Emote {
    return Emote.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Emote>, I>>(object: I): Emote {
    const message = createBaseEmote();
    message.emoteId = object.emoteId ?? "";
    message.image = (object.image !== undefined && object.image !== null) ? Image.fromPartial(object.image) : undefined;
    message.auditStatus = object.auditStatus ?? 0;
    message.uuid = object.uuid ?? "";
    message.emoteType = object.emoteType ?? 0;
    message.contentSource = object.contentSource ?? 0;
    message.emotePrivateType = object.emotePrivateType ?? 0;
    message.packageId = object.packageId ?? "";
    message.auditInfo = (object.auditInfo !== undefined && object.auditInfo !== null)
      ? Emote_AuditInfo.fromPartial(object.auditInfo)
      : undefined;
    message.rewardCondition = object.rewardCondition ?? 0;
    message.emoteUploadInfo = (object.emoteUploadInfo !== undefined && object.emoteUploadInfo !== null)
      ? Emote_EmoteUploadInfo.fromPartial(object.emoteUploadInfo)
      : undefined;
    message.createTime = object.createTime ?? "0";
    message.emoteScene = object.emoteScene ?? 0;
    return message;
  },
};

function createBaseEmote_AuditInfo(): Emote_AuditInfo {
  return { violationId: "0", taskType: 0 };
}

export const Emote_AuditInfo: MessageFns<Emote_AuditInfo> = {
  encode(message: Emote_AuditInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.violationId !== "0") {
      writer.uint32(8).int64(message.violationId);
    }
    if (message.taskType !== 0) {
      writer.uint32(16).int32(message.taskType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Emote_AuditInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmote_AuditInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.violationId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.taskType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Emote_AuditInfo>, I>>(base?: I): Emote_AuditInfo {
    return Emote_AuditInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Emote_AuditInfo>, I>>(object: I): Emote_AuditInfo {
    const message = createBaseEmote_AuditInfo();
    message.violationId = object.violationId ?? "0";
    message.taskType = object.taskType ?? 0;
    return message;
  },
};

function createBaseEmote_EmoteUploadInfo(): Emote_EmoteUploadInfo {
  return { userId: "0", emoteUploadSource: 0, userInfo: undefined, userIdStr: "" };
}

export const Emote_EmoteUploadInfo: MessageFns<Emote_EmoteUploadInfo> = {
  encode(message: Emote_EmoteUploadInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.emoteUploadSource !== 0) {
      writer.uint32(16).int32(message.emoteUploadSource);
    }
    if (message.userInfo !== undefined) {
      User.encode(message.userInfo, writer.uint32(26).fork()).join();
    }
    if (message.userIdStr !== "") {
      writer.uint32(34).string(message.userIdStr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Emote_EmoteUploadInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmote_EmoteUploadInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.emoteUploadSource = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userInfo = User.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userIdStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Emote_EmoteUploadInfo>, I>>(base?: I): Emote_EmoteUploadInfo {
    return Emote_EmoteUploadInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Emote_EmoteUploadInfo>, I>>(object: I): Emote_EmoteUploadInfo {
    const message = createBaseEmote_EmoteUploadInfo();
    message.userId = object.userId ?? "0";
    message.emoteUploadSource = object.emoteUploadSource ?? 0;
    message.userInfo = (object.userInfo !== undefined && object.userInfo !== null)
      ? User.fromPartial(object.userInfo)
      : undefined;
    message.userIdStr = object.userIdStr ?? "";
    return message;
  },
};

function createBasePunishEventInfo(): PunishEventInfo {
  return {
    punishType: "",
    punishReason: "",
    punishId: "",
    violationUid: "0",
    punishTypeId: 0,
    duration: "0",
    punishPerceptionCode: "",
    violationUidStr: "",
    showReason: "",
  };
}

export const PunishEventInfo: MessageFns<PunishEventInfo> = {
  encode(message: PunishEventInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.punishType !== "") {
      writer.uint32(10).string(message.punishType);
    }
    if (message.punishReason !== "") {
      writer.uint32(18).string(message.punishReason);
    }
    if (message.punishId !== "") {
      writer.uint32(26).string(message.punishId);
    }
    if (message.violationUid !== "0") {
      writer.uint32(32).int64(message.violationUid);
    }
    if (message.punishTypeId !== 0) {
      writer.uint32(40).int32(message.punishTypeId);
    }
    if (message.duration !== "0") {
      writer.uint32(48).int64(message.duration);
    }
    if (message.punishPerceptionCode !== "") {
      writer.uint32(58).string(message.punishPerceptionCode);
    }
    if (message.violationUidStr !== "") {
      writer.uint32(74).string(message.violationUidStr);
    }
    if (message.showReason !== "") {
      writer.uint32(82).string(message.showReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PunishEventInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePunishEventInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.punishType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.punishReason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.punishId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.violationUid = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.punishTypeId = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.duration = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.punishPerceptionCode = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.violationUidStr = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.showReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<PunishEventInfo>, I>>(base?: I): PunishEventInfo {
    return PunishEventInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PunishEventInfo>, I>>(object: I): PunishEventInfo {
    const message = createBasePunishEventInfo();
    message.punishType = object.punishType ?? "";
    message.punishReason = object.punishReason ?? "";
    message.punishId = object.punishId ?? "";
    message.violationUid = object.violationUid ?? "0";
    message.punishTypeId = object.punishTypeId ?? 0;
    message.duration = object.duration ?? "0";
    message.punishPerceptionCode = object.punishPerceptionCode ?? "";
    message.violationUidStr = object.violationUidStr ?? "";
    message.showReason = object.showReason ?? "";
    return message;
  },
};

function createBaseMsgFilter(): MsgFilter {
  return { isGifter: false, isSubscribedToAnchor: false };
}

export const MsgFilter: MessageFns<MsgFilter> = {
  encode(message: MsgFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isGifter !== false) {
      writer.uint32(8).bool(message.isGifter);
    }
    if (message.isSubscribedToAnchor !== false) {
      writer.uint32(16).bool(message.isSubscribedToAnchor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isGifter = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSubscribedToAnchor = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<MsgFilter>, I>>(base?: I): MsgFilter {
    return MsgFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFilter>, I>>(object: I): MsgFilter {
    const message = createBaseMsgFilter();
    message.isGifter = object.isGifter ?? false;
    message.isSubscribedToAnchor = object.isSubscribedToAnchor ?? false;
    return message;
  },
};

function createBaseUserIdentity(): UserIdentity {
  return {
    isGiftGiverOfAnchor: false,
    isSubscriberOfAnchor: false,
    isMutualFollowingWithAnchor: false,
    isFollowerOfAnchor: false,
    isModeratorOfAnchor: false,
    isAnchor: false,
  };
}

export const UserIdentity: MessageFns<UserIdentity> = {
  encode(message: UserIdentity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isGiftGiverOfAnchor !== false) {
      writer.uint32(8).bool(message.isGiftGiverOfAnchor);
    }
    if (message.isSubscriberOfAnchor !== false) {
      writer.uint32(16).bool(message.isSubscriberOfAnchor);
    }
    if (message.isMutualFollowingWithAnchor !== false) {
      writer.uint32(24).bool(message.isMutualFollowingWithAnchor);
    }
    if (message.isFollowerOfAnchor !== false) {
      writer.uint32(32).bool(message.isFollowerOfAnchor);
    }
    if (message.isModeratorOfAnchor !== false) {
      writer.uint32(40).bool(message.isModeratorOfAnchor);
    }
    if (message.isAnchor !== false) {
      writer.uint32(48).bool(message.isAnchor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserIdentity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserIdentity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isGiftGiverOfAnchor = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSubscriberOfAnchor = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isMutualFollowingWithAnchor = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isFollowerOfAnchor = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isModeratorOfAnchor = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isAnchor = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<UserIdentity>, I>>(base?: I): UserIdentity {
    return UserIdentity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserIdentity>, I>>(object: I): UserIdentity {
    const message = createBaseUserIdentity();
    message.isGiftGiverOfAnchor = object.isGiftGiverOfAnchor ?? false;
    message.isSubscriberOfAnchor = object.isSubscriberOfAnchor ?? false;
    message.isMutualFollowingWithAnchor = object.isMutualFollowingWithAnchor ?? false;
    message.isFollowerOfAnchor = object.isFollowerOfAnchor ?? false;
    message.isModeratorOfAnchor = object.isModeratorOfAnchor ?? false;
    message.isAnchor = object.isAnchor ?? false;
    return message;
  },
};

function createBaseLiveStreamGoal(): LiveStreamGoal {
  return {
    id: "0",
    type: 0,
    status: 0,
    subGoals: [],
    description: "",
    auditStatus: 0,
    cycleType: 0,
    startTime: "0",
    expireTime: "0",
    realFinishTime: "0",
    contributors: [],
    contributorsLength: 0,
    idStr: "",
    auditDescription: "",
    stats: undefined,
    goalExtraInfo: "",
    mode: 0,
    auditInfo: undefined,
    challengeType: "",
    isUneditable: false,
  };
}

export const LiveStreamGoal: MessageFns<LiveStreamGoal> = {
  encode(message: LiveStreamGoal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    for (const v of message.subGoals) {
      LiveStreamGoal_LiveStreamSubGoal.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.auditStatus !== 0) {
      writer.uint32(48).int32(message.auditStatus);
    }
    if (message.cycleType !== 0) {
      writer.uint32(56).int32(message.cycleType);
    }
    if (message.startTime !== "0") {
      writer.uint32(64).int64(message.startTime);
    }
    if (message.expireTime !== "0") {
      writer.uint32(72).int64(message.expireTime);
    }
    if (message.realFinishTime !== "0") {
      writer.uint32(80).int64(message.realFinishTime);
    }
    for (const v of message.contributors) {
      LiveStreamGoal_LiveStreamGoalContributor.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.contributorsLength !== 0) {
      writer.uint32(96).int32(message.contributorsLength);
    }
    if (message.idStr !== "") {
      writer.uint32(106).string(message.idStr);
    }
    if (message.auditDescription !== "") {
      writer.uint32(114).string(message.auditDescription);
    }
    if (message.stats !== undefined) {
      LiveStreamGoal_GoalStats.encode(message.stats, writer.uint32(122).fork()).join();
    }
    if (message.goalExtraInfo !== "") {
      writer.uint32(130).string(message.goalExtraInfo);
    }
    if (message.mode !== 0) {
      writer.uint32(136).int32(message.mode);
    }
    if (message.auditInfo !== undefined) {
      LiveStreamGoal_AuditInfo.encode(message.auditInfo, writer.uint32(146).fork()).join();
    }
    if (message.challengeType !== "") {
      writer.uint32(162).string(message.challengeType);
    }
    if (message.isUneditable !== false) {
      writer.uint32(168).bool(message.isUneditable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveStreamGoal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveStreamGoal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.subGoals.push(LiveStreamGoal_LiveStreamSubGoal.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.auditStatus = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.cycleType = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.startTime = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.expireTime = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.realFinishTime = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.contributors.push(LiveStreamGoal_LiveStreamGoalContributor.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.contributorsLength = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.idStr = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.auditDescription = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.stats = LiveStreamGoal_GoalStats.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.goalExtraInfo = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.mode = reader.int32();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.auditInfo = LiveStreamGoal_AuditInfo.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.challengeType = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.isUneditable = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LiveStreamGoal>, I>>(base?: I): LiveStreamGoal {
    return LiveStreamGoal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LiveStreamGoal>, I>>(object: I): LiveStreamGoal {
    const message = createBaseLiveStreamGoal();
    message.id = object.id ?? "0";
    message.type = object.type ?? 0;
    message.status = object.status ?? 0;
    message.subGoals = object.subGoals?.map((e) => LiveStreamGoal_LiveStreamSubGoal.fromPartial(e)) || [];
    message.description = object.description ?? "";
    message.auditStatus = object.auditStatus ?? 0;
    message.cycleType = object.cycleType ?? 0;
    message.startTime = object.startTime ?? "0";
    message.expireTime = object.expireTime ?? "0";
    message.realFinishTime = object.realFinishTime ?? "0";
    message.contributors = object.contributors?.map((e) => LiveStreamGoal_LiveStreamGoalContributor.fromPartial(e)) ||
      [];
    message.contributorsLength = object.contributorsLength ?? 0;
    message.idStr = object.idStr ?? "";
    message.auditDescription = object.auditDescription ?? "";
    message.stats = (object.stats !== undefined && object.stats !== null)
      ? LiveStreamGoal_GoalStats.fromPartial(object.stats)
      : undefined;
    message.goalExtraInfo = object.goalExtraInfo ?? "";
    message.mode = object.mode ?? 0;
    message.auditInfo = (object.auditInfo !== undefined && object.auditInfo !== null)
      ? LiveStreamGoal_AuditInfo.fromPartial(object.auditInfo)
      : undefined;
    message.challengeType = object.challengeType ?? "";
    message.isUneditable = object.isUneditable ?? false;
    return message;
  },
};

function createBaseLiveStreamGoal_AuditInfo(): LiveStreamGoal_AuditInfo {
  return { violationId: "0", taskType: 0 };
}

export const LiveStreamGoal_AuditInfo: MessageFns<LiveStreamGoal_AuditInfo> = {
  encode(message: LiveStreamGoal_AuditInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.violationId !== "0") {
      writer.uint32(8).int64(message.violationId);
    }
    if (message.taskType !== 0) {
      writer.uint32(16).int32(message.taskType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveStreamGoal_AuditInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveStreamGoal_AuditInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.violationId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.taskType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LiveStreamGoal_AuditInfo>, I>>(base?: I): LiveStreamGoal_AuditInfo {
    return LiveStreamGoal_AuditInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LiveStreamGoal_AuditInfo>, I>>(object: I): LiveStreamGoal_AuditInfo {
    const message = createBaseLiveStreamGoal_AuditInfo();
    message.violationId = object.violationId ?? "0";
    message.taskType = object.taskType ?? 0;
    return message;
  },
};

function createBaseLiveStreamGoal_LiveStreamSubGoal(): LiveStreamGoal_LiveStreamSubGoal {
  return {
    type: 0,
    id: "0",
    progress: "0",
    target: "0",
    gift: undefined,
    idStr: "",
    pinInfo: undefined,
    source: 0,
    recommendedText: "",
    recommendedHeader: "",
  };
}

export const LiveStreamGoal_LiveStreamSubGoal: MessageFns<LiveStreamGoal_LiveStreamSubGoal> = {
  encode(message: LiveStreamGoal_LiveStreamSubGoal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.id !== "0") {
      writer.uint32(16).int64(message.id);
    }
    if (message.progress !== "0") {
      writer.uint32(24).int64(message.progress);
    }
    if (message.target !== "0") {
      writer.uint32(32).int64(message.target);
    }
    if (message.gift !== undefined) {
      LiveStreamGoal_LiveStreamSubGoalGift.encode(message.gift, writer.uint32(42).fork()).join();
    }
    if (message.idStr !== "") {
      writer.uint32(50).string(message.idStr);
    }
    if (message.pinInfo !== undefined) {
      LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo.encode(message.pinInfo, writer.uint32(58).fork()).join();
    }
    if (message.source !== 0) {
      writer.uint32(64).int32(message.source);
    }
    if (message.recommendedText !== "") {
      writer.uint32(74).string(message.recommendedText);
    }
    if (message.recommendedHeader !== "") {
      writer.uint32(82).string(message.recommendedHeader);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveStreamGoal_LiveStreamSubGoal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveStreamGoal_LiveStreamSubGoal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.progress = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.target = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.gift = LiveStreamGoal_LiveStreamSubGoalGift.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.idStr = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.pinInfo = LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.source = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.recommendedText = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.recommendedHeader = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LiveStreamGoal_LiveStreamSubGoal>, I>>(
    base?: I,
  ): LiveStreamGoal_LiveStreamSubGoal {
    return LiveStreamGoal_LiveStreamSubGoal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LiveStreamGoal_LiveStreamSubGoal>, I>>(
    object: I,
  ): LiveStreamGoal_LiveStreamSubGoal {
    const message = createBaseLiveStreamGoal_LiveStreamSubGoal();
    message.type = object.type ?? 0;
    message.id = object.id ?? "0";
    message.progress = object.progress ?? "0";
    message.target = object.target ?? "0";
    message.gift = (object.gift !== undefined && object.gift !== null)
      ? LiveStreamGoal_LiveStreamSubGoalGift.fromPartial(object.gift)
      : undefined;
    message.idStr = object.idStr ?? "";
    message.pinInfo = (object.pinInfo !== undefined && object.pinInfo !== null)
      ? LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo.fromPartial(object.pinInfo)
      : undefined;
    message.source = object.source ?? 0;
    message.recommendedText = object.recommendedText ?? "";
    message.recommendedHeader = object.recommendedHeader ?? "";
    return message;
  },
};

function createBaseLiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo(): LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo {
  return { pinStartTime: "0", pinEndTime: "0", pinReadyTime: "0" };
}

export const LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo: MessageFns<
  LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo
> = {
  encode(
    message: LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.pinStartTime !== "0") {
      writer.uint32(8).int64(message.pinStartTime);
    }
    if (message.pinEndTime !== "0") {
      writer.uint32(16).int64(message.pinEndTime);
    }
    if (message.pinReadyTime !== "0") {
      writer.uint32(24).int64(message.pinReadyTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pinStartTime = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pinEndTime = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pinReadyTime = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo>, I>>(
    base?: I,
  ): LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo {
    return LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo>, I>>(
    object: I,
  ): LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo {
    const message = createBaseLiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo();
    message.pinStartTime = object.pinStartTime ?? "0";
    message.pinEndTime = object.pinEndTime ?? "0";
    message.pinReadyTime = object.pinReadyTime ?? "0";
    return message;
  },
};

function createBaseLiveStreamGoal_LiveStreamSubGoalGift(): LiveStreamGoal_LiveStreamSubGoalGift {
  return { name: "", icon: undefined, diamondCount: "0", type: 0 };
}

export const LiveStreamGoal_LiveStreamSubGoalGift: MessageFns<LiveStreamGoal_LiveStreamSubGoalGift> = {
  encode(message: LiveStreamGoal_LiveStreamSubGoalGift, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.icon !== undefined) {
      Image.encode(message.icon, writer.uint32(18).fork()).join();
    }
    if (message.diamondCount !== "0") {
      writer.uint32(24).int64(message.diamondCount);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveStreamGoal_LiveStreamSubGoalGift {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveStreamGoal_LiveStreamSubGoalGift();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.icon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.diamondCount = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LiveStreamGoal_LiveStreamSubGoalGift>, I>>(
    base?: I,
  ): LiveStreamGoal_LiveStreamSubGoalGift {
    return LiveStreamGoal_LiveStreamSubGoalGift.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LiveStreamGoal_LiveStreamSubGoalGift>, I>>(
    object: I,
  ): LiveStreamGoal_LiveStreamSubGoalGift {
    const message = createBaseLiveStreamGoal_LiveStreamSubGoalGift();
    message.name = object.name ?? "";
    message.icon = (object.icon !== undefined && object.icon !== null) ? Image.fromPartial(object.icon) : undefined;
    message.diamondCount = object.diamondCount ?? "0";
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseLiveStreamGoal_LiveStreamGoalContributor(): LiveStreamGoal_LiveStreamGoalContributor {
  return {
    userId: "0",
    avatar: undefined,
    displayId: "",
    score: "0",
    userIdStr: "",
    inRoom: false,
    isFriend: false,
    followByOwner: false,
    isFistContribute: false,
    subGoalContributions: [],
  };
}

export const LiveStreamGoal_LiveStreamGoalContributor: MessageFns<LiveStreamGoal_LiveStreamGoalContributor> = {
  encode(message: LiveStreamGoal_LiveStreamGoalContributor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.avatar !== undefined) {
      Image.encode(message.avatar, writer.uint32(18).fork()).join();
    }
    if (message.displayId !== "") {
      writer.uint32(26).string(message.displayId);
    }
    if (message.score !== "0") {
      writer.uint32(32).int64(message.score);
    }
    if (message.userIdStr !== "") {
      writer.uint32(42).string(message.userIdStr);
    }
    if (message.inRoom !== false) {
      writer.uint32(48).bool(message.inRoom);
    }
    if (message.isFriend !== false) {
      writer.uint32(56).bool(message.isFriend);
    }
    if (message.followByOwner !== false) {
      writer.uint32(72).bool(message.followByOwner);
    }
    if (message.isFistContribute !== false) {
      writer.uint32(80).bool(message.isFistContribute);
    }
    for (const v of message.subGoalContributions) {
      LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveStreamGoal_LiveStreamGoalContributor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveStreamGoal_LiveStreamGoalContributor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.avatar = Image.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.displayId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.score = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userIdStr = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.inRoom = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isFriend = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.followByOwner = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isFistContribute = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.subGoalContributions.push(
            LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LiveStreamGoal_LiveStreamGoalContributor>, I>>(
    base?: I,
  ): LiveStreamGoal_LiveStreamGoalContributor {
    return LiveStreamGoal_LiveStreamGoalContributor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LiveStreamGoal_LiveStreamGoalContributor>, I>>(
    object: I,
  ): LiveStreamGoal_LiveStreamGoalContributor {
    const message = createBaseLiveStreamGoal_LiveStreamGoalContributor();
    message.userId = object.userId ?? "0";
    message.avatar = (object.avatar !== undefined && object.avatar !== null)
      ? Image.fromPartial(object.avatar)
      : undefined;
    message.displayId = object.displayId ?? "";
    message.score = object.score ?? "0";
    message.userIdStr = object.userIdStr ?? "";
    message.inRoom = object.inRoom ?? false;
    message.isFriend = object.isFriend ?? false;
    message.followByOwner = object.followByOwner ?? false;
    message.isFistContribute = object.isFistContribute ?? false;
    message.subGoalContributions =
      object.subGoalContributions?.map((e) =>
        LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseLiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution(): LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution {
  return { id: "", contributionCount: "0" };
}

export const LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution: MessageFns<
  LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution
> = {
  encode(
    message: LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.contributionCount !== "0") {
      writer.uint32(16).int64(message.contributionCount);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.contributionCount = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution>, I>>(
    base?: I,
  ): LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution {
    return LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution>, I>>(
    object: I,
  ): LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution {
    const message = createBaseLiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution();
    message.id = object.id ?? "";
    message.contributionCount = object.contributionCount ?? "0";
    return message;
  },
};

function createBaseLiveStreamGoal_GoalStats(): LiveStreamGoal_GoalStats {
  return { totalCoins: "0", totalContributor: "0", comparison: undefined, totalNewFans: "0" };
}

export const LiveStreamGoal_GoalStats: MessageFns<LiveStreamGoal_GoalStats> = {
  encode(message: LiveStreamGoal_GoalStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalCoins !== "0") {
      writer.uint32(8).int64(message.totalCoins);
    }
    if (message.totalContributor !== "0") {
      writer.uint32(16).int64(message.totalContributor);
    }
    if (message.comparison !== undefined) {
      LiveStreamGoal_GoalStats_GoalComparison.encode(message.comparison, writer.uint32(26).fork()).join();
    }
    if (message.totalNewFans !== "0") {
      writer.uint32(32).int64(message.totalNewFans);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveStreamGoal_GoalStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveStreamGoal_GoalStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalCoins = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalContributor = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.comparison = LiveStreamGoal_GoalStats_GoalComparison.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalNewFans = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LiveStreamGoal_GoalStats>, I>>(base?: I): LiveStreamGoal_GoalStats {
    return LiveStreamGoal_GoalStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LiveStreamGoal_GoalStats>, I>>(object: I): LiveStreamGoal_GoalStats {
    const message = createBaseLiveStreamGoal_GoalStats();
    message.totalCoins = object.totalCoins ?? "0";
    message.totalContributor = object.totalContributor ?? "0";
    message.comparison = (object.comparison !== undefined && object.comparison !== null)
      ? LiveStreamGoal_GoalStats_GoalComparison.fromPartial(object.comparison)
      : undefined;
    message.totalNewFans = object.totalNewFans ?? "0";
    return message;
  },
};

function createBaseLiveStreamGoal_GoalStats_GoalComparison(): LiveStreamGoal_GoalStats_GoalComparison {
  return { coinsIncr: "0", contributorIncr: "0" };
}

export const LiveStreamGoal_GoalStats_GoalComparison: MessageFns<LiveStreamGoal_GoalStats_GoalComparison> = {
  encode(message: LiveStreamGoal_GoalStats_GoalComparison, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coinsIncr !== "0") {
      writer.uint32(8).int64(message.coinsIncr);
    }
    if (message.contributorIncr !== "0") {
      writer.uint32(16).int64(message.contributorIncr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveStreamGoal_GoalStats_GoalComparison {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveStreamGoal_GoalStats_GoalComparison();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.coinsIncr = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.contributorIncr = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LiveStreamGoal_GoalStats_GoalComparison>, I>>(
    base?: I,
  ): LiveStreamGoal_GoalStats_GoalComparison {
    return LiveStreamGoal_GoalStats_GoalComparison.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LiveStreamGoal_GoalStats_GoalComparison>, I>>(
    object: I,
  ): LiveStreamGoal_GoalStats_GoalComparison {
    const message = createBaseLiveStreamGoal_GoalStats_GoalComparison();
    message.coinsIncr = object.coinsIncr ?? "0";
    message.contributorIncr = object.contributorIncr ?? "0";
    return message;
  },
};

function createBaseLiveStreamGoalIndicator(): LiveStreamGoalIndicator {
  return { key: "", op: 0 };
}

export const LiveStreamGoalIndicator: MessageFns<LiveStreamGoalIndicator> = {
  encode(message: LiveStreamGoalIndicator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.op !== 0) {
      writer.uint32(16).int32(message.op);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveStreamGoalIndicator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveStreamGoalIndicator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.op = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LiveStreamGoalIndicator>, I>>(base?: I): LiveStreamGoalIndicator {
    return LiveStreamGoalIndicator.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LiveStreamGoalIndicator>, I>>(object: I): LiveStreamGoalIndicator {
    const message = createBaseLiveStreamGoalIndicator();
    message.key = object.key ?? "";
    message.op = object.op ?? 0;
    return message;
  },
};

function createBaseRanking(): Ranking {
  return { type: "", label: "", color: undefined, details: [] };
}

export const Ranking: MessageFns<Ranking> = {
  encode(message: Ranking, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.color !== undefined) {
      TikTokColor.encode(message.color, writer.uint32(26).fork()).join();
    }
    for (const v of message.details) {
      ValueLabel.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ranking {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRanking();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.color = TikTokColor.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.details.push(ValueLabel.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Ranking>, I>>(base?: I): Ranking {
    return Ranking.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Ranking>, I>>(object: I): Ranking {
    const message = createBaseRanking();
    message.type = object.type ?? "";
    message.label = object.label ?? "";
    message.color = (object.color !== undefined && object.color !== null)
      ? TikTokColor.fromPartial(object.color)
      : undefined;
    message.details = object.details?.map((e) => ValueLabel.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTikTokColor(): TikTokColor {
  return { color: "", id: "0", data1: 0 };
}

export const TikTokColor: MessageFns<TikTokColor> = {
  encode(message: TikTokColor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.color !== "") {
      writer.uint32(10).string(message.color);
    }
    if (message.id !== "0") {
      writer.uint32(32).uint64(message.id);
    }
    if (message.data1 !== 0) {
      writer.uint32(48).uint32(message.data1);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TikTokColor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTikTokColor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.color = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.id = reader.uint64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.data1 = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<TikTokColor>, I>>(base?: I): TikTokColor {
    return TikTokColor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TikTokColor>, I>>(object: I): TikTokColor {
    const message = createBaseTikTokColor();
    message.color = object.color ?? "";
    message.id = object.id ?? "0";
    message.data1 = object.data1 ?? 0;
    return message;
  },
};

function createBaseValueLabel(): ValueLabel {
  return { data: 0, label: "", label2: "", label3: "" };
}

export const ValueLabel: MessageFns<ValueLabel> = {
  encode(message: ValueLabel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== 0) {
      writer.uint32(8).uint32(message.data);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.label2 !== "") {
      writer.uint32(26).string(message.label2);
    }
    if (message.label3 !== "") {
      writer.uint32(90).string(message.label3);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValueLabel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValueLabel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.data = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.label2 = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.label3 = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ValueLabel>, I>>(base?: I): ValueLabel {
    return ValueLabel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValueLabel>, I>>(object: I): ValueLabel {
    const message = createBaseValueLabel();
    message.data = object.data ?? 0;
    message.label = object.label ?? "";
    message.label2 = object.label2 ?? "";
    message.label3 = object.label3 ?? "";
    return message;
  },
};

function createBaseTimeStampContainer(): TimeStampContainer {
  return { timestamp1: "0", timestamp2: "0", timestamp3: "0" };
}

export const TimeStampContainer: MessageFns<TimeStampContainer> = {
  encode(message: TimeStampContainer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp1 !== "0") {
      writer.uint32(8).uint64(message.timestamp1);
    }
    if (message.timestamp2 !== "0") {
      writer.uint32(16).uint64(message.timestamp2);
    }
    if (message.timestamp3 !== "0") {
      writer.uint32(24).uint64(message.timestamp3);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeStampContainer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeStampContainer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestamp1 = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp2 = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.timestamp3 = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<TimeStampContainer>, I>>(base?: I): TimeStampContainer {
    return TimeStampContainer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimeStampContainer>, I>>(object: I): TimeStampContainer {
    const message = createBaseTimeStampContainer();
    message.timestamp1 = object.timestamp1 ?? "0";
    message.timestamp2 = object.timestamp2 ?? "0";
    message.timestamp3 = object.timestamp3 ?? "0";
    return message;
  },
};

function createBasePollStartContent(): PollStartContent {
  return { StartTime: "0", EndTime: "0", OptionList: [], Title: "", Operator: undefined };
}

export const PollStartContent: MessageFns<PollStartContent> = {
  encode(message: PollStartContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.StartTime !== "0") {
      writer.uint32(8).int64(message.StartTime);
    }
    if (message.EndTime !== "0") {
      writer.uint32(16).int64(message.EndTime);
    }
    for (const v of message.OptionList) {
      PollOptionInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.Title !== "") {
      writer.uint32(34).string(message.Title);
    }
    if (message.Operator !== undefined) {
      User.encode(message.Operator, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PollStartContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePollStartContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.StartTime = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.EndTime = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.OptionList.push(PollOptionInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.Title = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.Operator = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<PollStartContent>, I>>(base?: I): PollStartContent {
    return PollStartContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PollStartContent>, I>>(object: I): PollStartContent {
    const message = createBasePollStartContent();
    message.StartTime = object.StartTime ?? "0";
    message.EndTime = object.EndTime ?? "0";
    message.OptionList = object.OptionList?.map((e) => PollOptionInfo.fromPartial(e)) || [];
    message.Title = object.Title ?? "";
    message.Operator = (object.Operator !== undefined && object.Operator !== null)
      ? User.fromPartial(object.Operator)
      : undefined;
    return message;
  },
};

function createBasePollEndContent(): PollEndContent {
  return { EndType: 0, OptionList: [], Operator: undefined };
}

export const PollEndContent: MessageFns<PollEndContent> = {
  encode(message: PollEndContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.EndType !== 0) {
      writer.uint32(8).int32(message.EndType);
    }
    for (const v of message.OptionList) {
      PollOptionInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.Operator !== undefined) {
      User.encode(message.Operator, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PollEndContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePollEndContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.EndType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.OptionList.push(PollOptionInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.Operator = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<PollEndContent>, I>>(base?: I): PollEndContent {
    return PollEndContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PollEndContent>, I>>(object: I): PollEndContent {
    const message = createBasePollEndContent();
    message.EndType = object.EndType ?? 0;
    message.OptionList = object.OptionList?.map((e) => PollOptionInfo.fromPartial(e)) || [];
    message.Operator = (object.Operator !== undefined && object.Operator !== null)
      ? User.fromPartial(object.Operator)
      : undefined;
    return message;
  },
};

function createBasePollOptionInfo(): PollOptionInfo {
  return { Votes: 0, DisplayContent: "", OptionIdx: 0, VoteUserList: [] };
}

export const PollOptionInfo: MessageFns<PollOptionInfo> = {
  encode(message: PollOptionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Votes !== 0) {
      writer.uint32(8).int32(message.Votes);
    }
    if (message.DisplayContent !== "") {
      writer.uint32(18).string(message.DisplayContent);
    }
    if (message.OptionIdx !== 0) {
      writer.uint32(24).int32(message.OptionIdx);
    }
    for (const v of message.VoteUserList) {
      VoteUser.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PollOptionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePollOptionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.Votes = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.DisplayContent = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.OptionIdx = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.VoteUserList.push(VoteUser.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<PollOptionInfo>, I>>(base?: I): PollOptionInfo {
    return PollOptionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PollOptionInfo>, I>>(object: I): PollOptionInfo {
    const message = createBasePollOptionInfo();
    message.Votes = object.Votes ?? 0;
    message.DisplayContent = object.DisplayContent ?? "";
    message.OptionIdx = object.OptionIdx ?? 0;
    message.VoteUserList = object.VoteUserList?.map((e) => VoteUser.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVoteUser(): VoteUser {
  return { UserId: "0", NickName: "", AvatarThumb: undefined };
}

export const VoteUser: MessageFns<VoteUser> = {
  encode(message: VoteUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.UserId !== "0") {
      writer.uint32(8).int64(message.UserId);
    }
    if (message.NickName !== "") {
      writer.uint32(18).string(message.NickName);
    }
    if (message.AvatarThumb !== undefined) {
      Image.encode(message.AvatarThumb, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VoteUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVoteUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.UserId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.NickName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.AvatarThumb = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<VoteUser>, I>>(base?: I): VoteUser {
    return VoteUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VoteUser>, I>>(object: I): VoteUser {
    const message = createBaseVoteUser();
    message.UserId = object.UserId ?? "0";
    message.NickName = object.NickName ?? "";
    message.AvatarThumb = (object.AvatarThumb !== undefined && object.AvatarThumb !== null)
      ? Image.fromPartial(object.AvatarThumb)
      : undefined;
    return message;
  },
};

function createBasePollUpdateVotesContent(): PollUpdateVotesContent {
  return { OptionList: [] };
}

export const PollUpdateVotesContent: MessageFns<PollUpdateVotesContent> = {
  encode(message: PollUpdateVotesContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.OptionList) {
      PollOptionInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PollUpdateVotesContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePollUpdateVotesContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.OptionList.push(PollOptionInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<PollUpdateVotesContent>, I>>(base?: I): PollUpdateVotesContent {
    return PollUpdateVotesContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PollUpdateVotesContent>, I>>(object: I): PollUpdateVotesContent {
    const message = createBasePollUpdateVotesContent();
    message.OptionList = object.OptionList?.map((e) => PollOptionInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserFanTicket(): UserFanTicket {
  return { UserId: "0", FanTicket: "0", MatchTotalScore: "0", MatchRank: 0 };
}

export const UserFanTicket: MessageFns<UserFanTicket> = {
  encode(message: UserFanTicket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.UserId !== "0") {
      writer.uint32(8).int64(message.UserId);
    }
    if (message.FanTicket !== "0") {
      writer.uint32(16).int64(message.FanTicket);
    }
    if (message.MatchTotalScore !== "0") {
      writer.uint32(24).int64(message.MatchTotalScore);
    }
    if (message.MatchRank !== 0) {
      writer.uint32(32).int32(message.MatchRank);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserFanTicket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserFanTicket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.UserId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.FanTicket = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.MatchTotalScore = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.MatchRank = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<UserFanTicket>, I>>(base?: I): UserFanTicket {
    return UserFanTicket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserFanTicket>, I>>(object: I): UserFanTicket {
    const message = createBaseUserFanTicket();
    message.UserId = object.UserId ?? "0";
    message.FanTicket = object.FanTicket ?? "0";
    message.MatchTotalScore = object.MatchTotalScore ?? "0";
    message.MatchRank = object.MatchRank ?? 0;
    return message;
  },
};

function createBaseFanTicketRoomNoticeContent(): FanTicketRoomNoticeContent {
  return {
    UserFanTicketList: [],
    TotalLinkMicFanTicket: "0",
    MatchId: "0",
    EventTime: "0",
    FanTicketIconUrl: "",
    playId: "0",
    playScene: 0,
  };
}

export const FanTicketRoomNoticeContent: MessageFns<FanTicketRoomNoticeContent> = {
  encode(message: FanTicketRoomNoticeContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.UserFanTicketList) {
      UserFanTicket.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.TotalLinkMicFanTicket !== "0") {
      writer.uint32(16).int64(message.TotalLinkMicFanTicket);
    }
    if (message.MatchId !== "0") {
      writer.uint32(24).int64(message.MatchId);
    }
    if (message.EventTime !== "0") {
      writer.uint32(32).int64(message.EventTime);
    }
    if (message.FanTicketIconUrl !== "") {
      writer.uint32(42).string(message.FanTicketIconUrl);
    }
    if (message.playId !== "0") {
      writer.uint32(48).int64(message.playId);
    }
    if (message.playScene !== 0) {
      writer.uint32(56).int32(message.playScene);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FanTicketRoomNoticeContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFanTicketRoomNoticeContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.UserFanTicketList.push(UserFanTicket.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.TotalLinkMicFanTicket = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.MatchId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.EventTime = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.FanTicketIconUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.playId = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.playScene = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<FanTicketRoomNoticeContent>, I>>(base?: I): FanTicketRoomNoticeContent {
    return FanTicketRoomNoticeContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FanTicketRoomNoticeContent>, I>>(object: I): FanTicketRoomNoticeContent {
    const message = createBaseFanTicketRoomNoticeContent();
    message.UserFanTicketList = object.UserFanTicketList?.map((e) => UserFanTicket.fromPartial(e)) || [];
    message.TotalLinkMicFanTicket = object.TotalLinkMicFanTicket ?? "0";
    message.MatchId = object.MatchId ?? "0";
    message.EventTime = object.EventTime ?? "0";
    message.FanTicketIconUrl = object.FanTicketIconUrl ?? "";
    message.playId = object.playId ?? "0";
    message.playScene = object.playScene ?? 0;
    return message;
  },
};

function createBaseLinkerAcceptNoticeContent(): LinkerAcceptNoticeContent {
  return { fromUserId: "0", fromRoomId: "0", toUserId: "0" };
}

export const LinkerAcceptNoticeContent: MessageFns<LinkerAcceptNoticeContent> = {
  encode(message: LinkerAcceptNoticeContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUserId !== "0") {
      writer.uint32(8).int64(message.fromUserId);
    }
    if (message.fromRoomId !== "0") {
      writer.uint32(16).int64(message.fromRoomId);
    }
    if (message.toUserId !== "0") {
      writer.uint32(24).int64(message.toUserId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerAcceptNoticeContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerAcceptNoticeContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromUserId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fromRoomId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.toUserId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerAcceptNoticeContent>, I>>(base?: I): LinkerAcceptNoticeContent {
    return LinkerAcceptNoticeContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerAcceptNoticeContent>, I>>(object: I): LinkerAcceptNoticeContent {
    const message = createBaseLinkerAcceptNoticeContent();
    message.fromUserId = object.fromUserId ?? "0";
    message.fromRoomId = object.fromRoomId ?? "0";
    message.toUserId = object.toUserId ?? "0";
    return message;
  },
};

function createBaseLinkerCancelContent(): LinkerCancelContent {
  return { fromUserId: "0", toUserId: "0", cancelType: "0", actionId: "0" };
}

export const LinkerCancelContent: MessageFns<LinkerCancelContent> = {
  encode(message: LinkerCancelContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUserId !== "0") {
      writer.uint32(8).int64(message.fromUserId);
    }
    if (message.toUserId !== "0") {
      writer.uint32(16).int64(message.toUserId);
    }
    if (message.cancelType !== "0") {
      writer.uint32(24).int64(message.cancelType);
    }
    if (message.actionId !== "0") {
      writer.uint32(32).int64(message.actionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerCancelContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerCancelContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromUserId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.toUserId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.cancelType = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.actionId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerCancelContent>, I>>(base?: I): LinkerCancelContent {
    return LinkerCancelContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerCancelContent>, I>>(object: I): LinkerCancelContent {
    const message = createBaseLinkerCancelContent();
    message.fromUserId = object.fromUserId ?? "0";
    message.toUserId = object.toUserId ?? "0";
    message.cancelType = object.cancelType ?? "0";
    message.actionId = object.actionId ?? "0";
    return message;
  },
};

function createBaseListUser(): ListUser {
  return {
    user: undefined,
    linkmicId: "0",
    linkmicIdStr: "",
    linkStatus: 0,
    linkType: 0,
    userPosition: 0,
    silenceStatus: 0,
    modifyTime: "0",
    linkerId: "0",
    roleType: 0,
  };
}

export const ListUser: MessageFns<ListUser> = {
  encode(message: ListUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.linkmicId !== "0") {
      writer.uint32(16).int64(message.linkmicId);
    }
    if (message.linkmicIdStr !== "") {
      writer.uint32(26).string(message.linkmicIdStr);
    }
    if (message.linkStatus !== 0) {
      writer.uint32(32).int32(message.linkStatus);
    }
    if (message.linkType !== 0) {
      writer.uint32(40).int32(message.linkType);
    }
    if (message.userPosition !== 0) {
      writer.uint32(48).int32(message.userPosition);
    }
    if (message.silenceStatus !== 0) {
      writer.uint32(56).int32(message.silenceStatus);
    }
    if (message.modifyTime !== "0") {
      writer.uint32(64).int64(message.modifyTime);
    }
    if (message.linkerId !== "0") {
      writer.uint32(72).int64(message.linkerId);
    }
    if (message.roleType !== 0) {
      writer.uint32(80).int32(message.roleType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.linkmicId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.linkmicIdStr = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.linkStatus = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.linkType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.userPosition = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.silenceStatus = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.modifyTime = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.linkerId = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.roleType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ListUser>, I>>(base?: I): ListUser {
    return ListUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUser>, I>>(object: I): ListUser {
    const message = createBaseListUser();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.linkmicId = object.linkmicId ?? "0";
    message.linkmicIdStr = object.linkmicIdStr ?? "";
    message.linkStatus = object.linkStatus ?? 0;
    message.linkType = object.linkType ?? 0;
    message.userPosition = object.userPosition ?? 0;
    message.silenceStatus = object.silenceStatus ?? 0;
    message.modifyTime = object.modifyTime ?? "0";
    message.linkerId = object.linkerId ?? "0";
    message.roleType = object.roleType ?? 0;
    return message;
  },
};

function createBaseLinkerCloseContent(): LinkerCloseContent {
  return {};
}

export const LinkerCloseContent: MessageFns<LinkerCloseContent> = {
  encode(_: LinkerCloseContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerCloseContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerCloseContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerCloseContent>, I>>(base?: I): LinkerCloseContent {
    return LinkerCloseContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerCloseContent>, I>>(_: I): LinkerCloseContent {
    const message = createBaseLinkerCloseContent();
    return message;
  },
};

function createBaseLinkerCreateContent(): LinkerCreateContent {
  return { ownerId: "0", ownerRoomId: "0", linkType: "0" };
}

export const LinkerCreateContent: MessageFns<LinkerCreateContent> = {
  encode(message: LinkerCreateContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ownerId !== "0") {
      writer.uint32(8).int64(message.ownerId);
    }
    if (message.ownerRoomId !== "0") {
      writer.uint32(16).int64(message.ownerRoomId);
    }
    if (message.linkType !== "0") {
      writer.uint32(24).int64(message.linkType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerCreateContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerCreateContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.ownerId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ownerRoomId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.linkType = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerCreateContent>, I>>(base?: I): LinkerCreateContent {
    return LinkerCreateContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerCreateContent>, I>>(object: I): LinkerCreateContent {
    const message = createBaseLinkerCreateContent();
    message.ownerId = object.ownerId ?? "0";
    message.ownerRoomId = object.ownerRoomId ?? "0";
    message.linkType = object.linkType ?? "0";
    return message;
  },
};

function createBaseLinkerEnterContent(): LinkerEnterContent {
  return { linkedUsersList: [], anchorMultiLiveEnum: 0, anchorSettingInfo: undefined };
}

export const LinkerEnterContent: MessageFns<LinkerEnterContent> = {
  encode(message: LinkerEnterContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.linkedUsersList) {
      ListUser.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.anchorMultiLiveEnum !== 0) {
      writer.uint32(16).int32(message.anchorMultiLiveEnum);
    }
    if (message.anchorSettingInfo !== undefined) {
      MultiLiveAnchorPanelSettings.encode(message.anchorSettingInfo, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerEnterContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerEnterContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.linkedUsersList.push(ListUser.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.anchorMultiLiveEnum = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.anchorSettingInfo = MultiLiveAnchorPanelSettings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerEnterContent>, I>>(base?: I): LinkerEnterContent {
    return LinkerEnterContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerEnterContent>, I>>(object: I): LinkerEnterContent {
    const message = createBaseLinkerEnterContent();
    message.linkedUsersList = object.linkedUsersList?.map((e) => ListUser.fromPartial(e)) || [];
    message.anchorMultiLiveEnum = object.anchorMultiLiveEnum ?? 0;
    message.anchorSettingInfo = (object.anchorSettingInfo !== undefined && object.anchorSettingInfo !== null)
      ? MultiLiveAnchorPanelSettings.fromPartial(object.anchorSettingInfo)
      : undefined;
    return message;
  },
};

function createBaseLinkerInviteContent(): LinkerInviteContent {
  return {
    fromUserId: "0",
    fromRoomId: "0",
    toRtcExtInfo: "",
    rtcJoinChannel: false,
    vendor: "0",
    secFromUserId: "",
    toLinkmicIdStr: "",
    fromUser: undefined,
    requiredMicIdx: "0",
    rtcExtInfoMap: {},
    multiLiveLayoutEnable: 0,
    multiLiveSetting: undefined,
    fromLinkmicIdStr: "",
    fromTopHostInfo: undefined,
    actionId: "0",
    linkedUsers: [],
    dialogInfo: undefined,
    punishEventInfo: undefined,
    fromRoomAgeRestricted: 0,
    abTestSetting: [],
    linkerInviteMsgExtra: undefined,
  };
}

export const LinkerInviteContent: MessageFns<LinkerInviteContent> = {
  encode(message: LinkerInviteContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUserId !== "0") {
      writer.uint32(8).int64(message.fromUserId);
    }
    if (message.fromRoomId !== "0") {
      writer.uint32(16).int64(message.fromRoomId);
    }
    if (message.toRtcExtInfo !== "") {
      writer.uint32(26).string(message.toRtcExtInfo);
    }
    if (message.rtcJoinChannel !== false) {
      writer.uint32(32).bool(message.rtcJoinChannel);
    }
    if (message.vendor !== "0") {
      writer.uint32(40).int64(message.vendor);
    }
    if (message.secFromUserId !== "") {
      writer.uint32(50).string(message.secFromUserId);
    }
    if (message.toLinkmicIdStr !== "") {
      writer.uint32(58).string(message.toLinkmicIdStr);
    }
    if (message.fromUser !== undefined) {
      User.encode(message.fromUser, writer.uint32(66).fork()).join();
    }
    if (message.requiredMicIdx !== "0") {
      writer.uint32(72).int64(message.requiredMicIdx);
    }
    Object.entries(message.rtcExtInfoMap).forEach(([key, value]) => {
      LinkerInviteContent_RtcExtInfoMapEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    if (message.multiLiveLayoutEnable !== 0) {
      writer.uint32(88).int32(message.multiLiveLayoutEnable);
    }
    if (message.multiLiveSetting !== undefined) {
      MultiLiveAnchorPanelSettings.encode(message.multiLiveSetting, writer.uint32(98).fork()).join();
    }
    if (message.fromLinkmicIdStr !== "") {
      writer.uint32(106).string(message.fromLinkmicIdStr);
    }
    if (message.fromTopHostInfo !== undefined) {
      LinkerInviteContent_InviteTopHostInfo.encode(message.fromTopHostInfo, writer.uint32(130).fork()).join();
    }
    if (message.actionId !== "0") {
      writer.uint32(136).int64(message.actionId);
    }
    for (const v of message.linkedUsers) {
      LinkerInviteContent_LinkmicUserInfo.encode(v!, writer.uint32(146).fork()).join();
    }
    if (message.dialogInfo !== undefined) {
      LinkerInviteContent_PerceptionDialogInfo.encode(message.dialogInfo, writer.uint32(154).fork()).join();
    }
    if (message.punishEventInfo !== undefined) {
      PunishEventInfo.encode(message.punishEventInfo, writer.uint32(162).fork()).join();
    }
    if (message.fromRoomAgeRestricted !== 0) {
      writer.uint32(168).int32(message.fromRoomAgeRestricted);
    }
    for (const v of message.abTestSetting) {
      LinkerInviteContent_CohostABTestSetting.encode(v!, writer.uint32(186).fork()).join();
    }
    if (message.linkerInviteMsgExtra !== undefined) {
      LinkerInviteContent_LinkerInviteMessageExtra.encode(message.linkerInviteMsgExtra, writer.uint32(810).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerInviteContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromUserId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fromRoomId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toRtcExtInfo = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rtcJoinChannel = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.vendor = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.secFromUserId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.toLinkmicIdStr = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.fromUser = User.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.requiredMicIdx = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = LinkerInviteContent_RtcExtInfoMapEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.rtcExtInfoMap[entry10.key] = entry10.value;
          }
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.multiLiveLayoutEnable = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.multiLiveSetting = MultiLiveAnchorPanelSettings.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.fromLinkmicIdStr = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.fromTopHostInfo = LinkerInviteContent_InviteTopHostInfo.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.actionId = reader.int64().toString();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.linkedUsers.push(LinkerInviteContent_LinkmicUserInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.dialogInfo = LinkerInviteContent_PerceptionDialogInfo.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.punishEventInfo = PunishEventInfo.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.fromRoomAgeRestricted = reader.int32();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.abTestSetting.push(LinkerInviteContent_CohostABTestSetting.decode(reader, reader.uint32()));
          continue;
        }
        case 101: {
          if (tag !== 810) {
            break;
          }

          message.linkerInviteMsgExtra = LinkerInviteContent_LinkerInviteMessageExtra.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerInviteContent>, I>>(base?: I): LinkerInviteContent {
    return LinkerInviteContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerInviteContent>, I>>(object: I): LinkerInviteContent {
    const message = createBaseLinkerInviteContent();
    message.fromUserId = object.fromUserId ?? "0";
    message.fromRoomId = object.fromRoomId ?? "0";
    message.toRtcExtInfo = object.toRtcExtInfo ?? "";
    message.rtcJoinChannel = object.rtcJoinChannel ?? false;
    message.vendor = object.vendor ?? "0";
    message.secFromUserId = object.secFromUserId ?? "";
    message.toLinkmicIdStr = object.toLinkmicIdStr ?? "";
    message.fromUser = (object.fromUser !== undefined && object.fromUser !== null)
      ? User.fromPartial(object.fromUser)
      : undefined;
    message.requiredMicIdx = object.requiredMicIdx ?? "0";
    message.rtcExtInfoMap = Object.entries(object.rtcExtInfoMap ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.multiLiveLayoutEnable = object.multiLiveLayoutEnable ?? 0;
    message.multiLiveSetting = (object.multiLiveSetting !== undefined && object.multiLiveSetting !== null)
      ? MultiLiveAnchorPanelSettings.fromPartial(object.multiLiveSetting)
      : undefined;
    message.fromLinkmicIdStr = object.fromLinkmicIdStr ?? "";
    message.fromTopHostInfo = (object.fromTopHostInfo !== undefined && object.fromTopHostInfo !== null)
      ? LinkerInviteContent_InviteTopHostInfo.fromPartial(object.fromTopHostInfo)
      : undefined;
    message.actionId = object.actionId ?? "0";
    message.linkedUsers = object.linkedUsers?.map((e) => LinkerInviteContent_LinkmicUserInfo.fromPartial(e)) || [];
    message.dialogInfo = (object.dialogInfo !== undefined && object.dialogInfo !== null)
      ? LinkerInviteContent_PerceptionDialogInfo.fromPartial(object.dialogInfo)
      : undefined;
    message.punishEventInfo = (object.punishEventInfo !== undefined && object.punishEventInfo !== null)
      ? PunishEventInfo.fromPartial(object.punishEventInfo)
      : undefined;
    message.fromRoomAgeRestricted = object.fromRoomAgeRestricted ?? 0;
    message.abTestSetting = object.abTestSetting?.map((e) => LinkerInviteContent_CohostABTestSetting.fromPartial(e)) ||
      [];
    message.linkerInviteMsgExtra = (object.linkerInviteMsgExtra !== undefined && object.linkerInviteMsgExtra !== null)
      ? LinkerInviteContent_LinkerInviteMessageExtra.fromPartial(object.linkerInviteMsgExtra)
      : undefined;
    return message;
  },
};

function createBaseLinkerInviteContent_RtcExtInfoMapEntry(): LinkerInviteContent_RtcExtInfoMapEntry {
  return { key: "0", value: "" };
}

export const LinkerInviteContent_RtcExtInfoMapEntry: MessageFns<LinkerInviteContent_RtcExtInfoMapEntry> = {
  encode(message: LinkerInviteContent_RtcExtInfoMapEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerInviteContent_RtcExtInfoMapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_RtcExtInfoMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerInviteContent_RtcExtInfoMapEntry>, I>>(
    base?: I,
  ): LinkerInviteContent_RtcExtInfoMapEntry {
    return LinkerInviteContent_RtcExtInfoMapEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerInviteContent_RtcExtInfoMapEntry>, I>>(
    object: I,
  ): LinkerInviteContent_RtcExtInfoMapEntry {
    const message = createBaseLinkerInviteContent_RtcExtInfoMapEntry();
    message.key = object.key ?? "0";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseLinkerInviteContent_InviteTopHostInfo(): LinkerInviteContent_InviteTopHostInfo {
  return { rankType: "", topIndex: "0" };
}

export const LinkerInviteContent_InviteTopHostInfo: MessageFns<LinkerInviteContent_InviteTopHostInfo> = {
  encode(message: LinkerInviteContent_InviteTopHostInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rankType !== "") {
      writer.uint32(10).string(message.rankType);
    }
    if (message.topIndex !== "0") {
      writer.uint32(16).int64(message.topIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerInviteContent_InviteTopHostInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_InviteTopHostInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rankType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topIndex = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerInviteContent_InviteTopHostInfo>, I>>(
    base?: I,
  ): LinkerInviteContent_InviteTopHostInfo {
    return LinkerInviteContent_InviteTopHostInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerInviteContent_InviteTopHostInfo>, I>>(
    object: I,
  ): LinkerInviteContent_InviteTopHostInfo {
    const message = createBaseLinkerInviteContent_InviteTopHostInfo();
    message.rankType = object.rankType ?? "";
    message.topIndex = object.topIndex ?? "0";
    return message;
  },
};

function createBaseLinkerInviteContent_LinkmicUserInfo(): LinkerInviteContent_LinkmicUserInfo {
  return { userId: "0", linkmicIdStr: "", roomId: "0", linkedTime: "0" };
}

export const LinkerInviteContent_LinkmicUserInfo: MessageFns<LinkerInviteContent_LinkmicUserInfo> = {
  encode(message: LinkerInviteContent_LinkmicUserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.linkmicIdStr !== "") {
      writer.uint32(18).string(message.linkmicIdStr);
    }
    if (message.roomId !== "0") {
      writer.uint32(24).int64(message.roomId);
    }
    if (message.linkedTime !== "0") {
      writer.uint32(32).int64(message.linkedTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerInviteContent_LinkmicUserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_LinkmicUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.linkmicIdStr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.roomId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.linkedTime = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerInviteContent_LinkmicUserInfo>, I>>(
    base?: I,
  ): LinkerInviteContent_LinkmicUserInfo {
    return LinkerInviteContent_LinkmicUserInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerInviteContent_LinkmicUserInfo>, I>>(
    object: I,
  ): LinkerInviteContent_LinkmicUserInfo {
    const message = createBaseLinkerInviteContent_LinkmicUserInfo();
    message.userId = object.userId ?? "0";
    message.linkmicIdStr = object.linkmicIdStr ?? "";
    message.roomId = object.roomId ?? "0";
    message.linkedTime = object.linkedTime ?? "0";
    return message;
  },
};

function createBaseLinkerInviteContent_PerceptionDialogInfo(): LinkerInviteContent_PerceptionDialogInfo {
  return {
    iconType: 0,
    title: undefined,
    subTitle: undefined,
    adviceActionText: undefined,
    defaultActionText: undefined,
    violationDetailUrl: "",
    scene: 0,
    targetUserId: "0",
    targetRoomId: "0",
    countDownTime: "0",
    showFeedback: false,
    feedbackOptions: [],
    policyTip: "0",
    appealPopup: 0,
  };
}

export const LinkerInviteContent_PerceptionDialogInfo: MessageFns<LinkerInviteContent_PerceptionDialogInfo> = {
  encode(message: LinkerInviteContent_PerceptionDialogInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iconType !== 0) {
      writer.uint32(8).int32(message.iconType);
    }
    if (message.title !== undefined) {
      Text.encode(message.title, writer.uint32(18).fork()).join();
    }
    if (message.subTitle !== undefined) {
      Text.encode(message.subTitle, writer.uint32(26).fork()).join();
    }
    if (message.adviceActionText !== undefined) {
      Text.encode(message.adviceActionText, writer.uint32(34).fork()).join();
    }
    if (message.defaultActionText !== undefined) {
      Text.encode(message.defaultActionText, writer.uint32(42).fork()).join();
    }
    if (message.violationDetailUrl !== "") {
      writer.uint32(50).string(message.violationDetailUrl);
    }
    if (message.scene !== 0) {
      writer.uint32(56).int32(message.scene);
    }
    if (message.targetUserId !== "0") {
      writer.uint32(64).int64(message.targetUserId);
    }
    if (message.targetRoomId !== "0") {
      writer.uint32(72).int64(message.targetRoomId);
    }
    if (message.countDownTime !== "0") {
      writer.uint32(80).int64(message.countDownTime);
    }
    if (message.showFeedback !== false) {
      writer.uint32(88).bool(message.showFeedback);
    }
    for (const v of message.feedbackOptions) {
      LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.policyTip !== "0") {
      writer.uint32(104).int64(message.policyTip);
    }
    if (message.appealPopup !== 0) {
      writer.uint32(112).int32(message.appealPopup);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerInviteContent_PerceptionDialogInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_PerceptionDialogInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.iconType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = Text.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subTitle = Text.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.adviceActionText = Text.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.defaultActionText = Text.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.violationDetailUrl = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.scene = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.targetUserId = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.targetRoomId = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.countDownTime = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.showFeedback = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.feedbackOptions.push(
            LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.policyTip = reader.int64().toString();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.appealPopup = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerInviteContent_PerceptionDialogInfo>, I>>(
    base?: I,
  ): LinkerInviteContent_PerceptionDialogInfo {
    return LinkerInviteContent_PerceptionDialogInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerInviteContent_PerceptionDialogInfo>, I>>(
    object: I,
  ): LinkerInviteContent_PerceptionDialogInfo {
    const message = createBaseLinkerInviteContent_PerceptionDialogInfo();
    message.iconType = object.iconType ?? 0;
    message.title = (object.title !== undefined && object.title !== null) ? Text.fromPartial(object.title) : undefined;
    message.subTitle = (object.subTitle !== undefined && object.subTitle !== null)
      ? Text.fromPartial(object.subTitle)
      : undefined;
    message.adviceActionText = (object.adviceActionText !== undefined && object.adviceActionText !== null)
      ? Text.fromPartial(object.adviceActionText)
      : undefined;
    message.defaultActionText = (object.defaultActionText !== undefined && object.defaultActionText !== null)
      ? Text.fromPartial(object.defaultActionText)
      : undefined;
    message.violationDetailUrl = object.violationDetailUrl ?? "";
    message.scene = object.scene ?? 0;
    message.targetUserId = object.targetUserId ?? "0";
    message.targetRoomId = object.targetRoomId ?? "0";
    message.countDownTime = object.countDownTime ?? "0";
    message.showFeedback = object.showFeedback ?? false;
    message.feedbackOptions =
      object.feedbackOptions?.map((e) =>
        LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption.fromPartial(e)
      ) || [];
    message.policyTip = object.policyTip ?? "0";
    message.appealPopup = object.appealPopup ?? 0;
    return message;
  },
};

function createBaseLinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption(): LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption {
  return { id: "0", contentKey: "" };
}

export const LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption: MessageFns<
  LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption
> = {
  encode(
    message: LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.contentKey !== "") {
      writer.uint32(18).string(message.contentKey);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contentKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption>, I>>(
    base?: I,
  ): LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption {
    return LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption>, I>>(
    object: I,
  ): LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption {
    const message = createBaseLinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption();
    message.id = object.id ?? "0";
    message.contentKey = object.contentKey ?? "";
    return message;
  },
};

function createBaseLinkerInviteContent_CohostABTestSetting(): LinkerInviteContent_CohostABTestSetting {
  return { key: "0", value: undefined };
}

export const LinkerInviteContent_CohostABTestSetting: MessageFns<LinkerInviteContent_CohostABTestSetting> = {
  encode(message: LinkerInviteContent_CohostABTestSetting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== undefined) {
      LinkerInviteContent_CohostABTestSetting_CohostABTestList.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerInviteContent_CohostABTestSetting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_CohostABTestSetting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = LinkerInviteContent_CohostABTestSetting_CohostABTestList.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerInviteContent_CohostABTestSetting>, I>>(
    base?: I,
  ): LinkerInviteContent_CohostABTestSetting {
    return LinkerInviteContent_CohostABTestSetting.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerInviteContent_CohostABTestSetting>, I>>(
    object: I,
  ): LinkerInviteContent_CohostABTestSetting {
    const message = createBaseLinkerInviteContent_CohostABTestSetting();
    message.key = object.key ?? "0";
    message.value = (object.value !== undefined && object.value !== null)
      ? LinkerInviteContent_CohostABTestSetting_CohostABTestList.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseLinkerInviteContent_CohostABTestSetting_CohostABTestList(): LinkerInviteContent_CohostABTestSetting_CohostABTestList {
  return { abTestList: [] };
}

export const LinkerInviteContent_CohostABTestSetting_CohostABTestList: MessageFns<
  LinkerInviteContent_CohostABTestSetting_CohostABTestList
> = {
  encode(
    message: LinkerInviteContent_CohostABTestSetting_CohostABTestList,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.abTestList) {
      LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerInviteContent_CohostABTestSetting_CohostABTestList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_CohostABTestSetting_CohostABTestList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.abTestList.push(
            LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerInviteContent_CohostABTestSetting_CohostABTestList>, I>>(
    base?: I,
  ): LinkerInviteContent_CohostABTestSetting_CohostABTestList {
    return LinkerInviteContent_CohostABTestSetting_CohostABTestList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerInviteContent_CohostABTestSetting_CohostABTestList>, I>>(
    object: I,
  ): LinkerInviteContent_CohostABTestSetting_CohostABTestList {
    const message = createBaseLinkerInviteContent_CohostABTestSetting_CohostABTestList();
    message.abTestList =
      object.abTestList?.map((e) =>
        LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseLinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest(): LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest {
  return { abTestType: 0, group: "0" };
}

export const LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest: MessageFns<
  LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest
> = {
  encode(
    message: LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.abTestType !== 0) {
      writer.uint32(8).int32(message.abTestType);
    }
    if (message.group !== "0") {
      writer.uint32(16).int64(message.group);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.abTestType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.group = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest>, I>>(
    base?: I,
  ): LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest {
    return LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest>, I>>(
    object: I,
  ): LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest {
    const message = createBaseLinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest();
    message.abTestType = object.abTestType ?? 0;
    message.group = object.group ?? "0";
    return message;
  },
};

function createBaseLinkerInviteContent_LinkerInviteMessageExtra(): LinkerInviteContent_LinkerInviteMessageExtra {
  return {
    matchType: 0,
    inviteType: 0,
    subType: 0,
    theme: "",
    duration: 0,
    layout: 0,
    tips: "",
    inviterRivalExtra: undefined,
    otherRivalExtra: [],
    topicInfo: undefined,
    algoRequestId: "",
  };
}

export const LinkerInviteContent_LinkerInviteMessageExtra: MessageFns<LinkerInviteContent_LinkerInviteMessageExtra> = {
  encode(
    message: LinkerInviteContent_LinkerInviteMessageExtra,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.matchType !== 0) {
      writer.uint32(8).int32(message.matchType);
    }
    if (message.inviteType !== 0) {
      writer.uint32(16).int32(message.inviteType);
    }
    if (message.subType !== 0) {
      writer.uint32(24).int32(message.subType);
    }
    if (message.theme !== "") {
      writer.uint32(34).string(message.theme);
    }
    if (message.duration !== 0) {
      writer.uint32(40).int32(message.duration);
    }
    if (message.layout !== 0) {
      writer.uint32(48).int32(message.layout);
    }
    if (message.tips !== "") {
      writer.uint32(58).string(message.tips);
    }
    if (message.inviterRivalExtra !== undefined) {
      LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra.encode(
        message.inviterRivalExtra,
        writer.uint32(66).fork(),
      ).join();
    }
    for (const v of message.otherRivalExtra) {
      LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.topicInfo !== undefined) {
      CohostTopic.encode(message.topicInfo, writer.uint32(82).fork()).join();
    }
    if (message.algoRequestId !== "") {
      writer.uint32(90).string(message.algoRequestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerInviteContent_LinkerInviteMessageExtra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.matchType = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.inviteType = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.subType = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.theme = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.duration = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.layout = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tips = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.inviterRivalExtra = LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.otherRivalExtra.push(
            LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.topicInfo = CohostTopic.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.algoRequestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerInviteContent_LinkerInviteMessageExtra>, I>>(
    base?: I,
  ): LinkerInviteContent_LinkerInviteMessageExtra {
    return LinkerInviteContent_LinkerInviteMessageExtra.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerInviteContent_LinkerInviteMessageExtra>, I>>(
    object: I,
  ): LinkerInviteContent_LinkerInviteMessageExtra {
    const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra();
    message.matchType = object.matchType ?? 0;
    message.inviteType = object.inviteType ?? 0;
    message.subType = object.subType ?? 0;
    message.theme = object.theme ?? "";
    message.duration = object.duration ?? 0;
    message.layout = object.layout ?? 0;
    message.tips = object.tips ?? "";
    message.inviterRivalExtra = (object.inviterRivalExtra !== undefined && object.inviterRivalExtra !== null)
      ? LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra.fromPartial(object.inviterRivalExtra)
      : undefined;
    message.otherRivalExtra =
      object.otherRivalExtra?.map((e) =>
        LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra.fromPartial(e)
      ) || [];
    message.topicInfo = (object.topicInfo !== undefined && object.topicInfo !== null)
      ? CohostTopic.fromPartial(object.topicInfo)
      : undefined;
    message.algoRequestId = object.algoRequestId ?? "";
    return message;
  },
};

function createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra(): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra {
  return {
    textType: 0,
    text: "",
    label: "",
    userCount: 0,
    avatarThumb: undefined,
    displayId: "",
    authenticationInfo: undefined,
    nickname: "",
    followStatus: "0",
    mHashtag: undefined,
    userId: "0",
    isBestTeammate: false,
    optPairInfo: undefined,
    followerCount: "0",
  };
}

export const LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra: MessageFns<
  LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra
> = {
  encode(
    message: LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.textType !== 0) {
      writer.uint32(8).int32(message.textType);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.userCount !== 0) {
      writer.uint32(32).int32(message.userCount);
    }
    if (message.avatarThumb !== undefined) {
      Image.encode(message.avatarThumb, writer.uint32(42).fork()).join();
    }
    if (message.displayId !== "") {
      writer.uint32(50).string(message.displayId);
    }
    if (message.authenticationInfo !== undefined) {
      LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo.encode(
        message.authenticationInfo,
        writer.uint32(58).fork(),
      ).join();
    }
    if (message.nickname !== "") {
      writer.uint32(66).string(message.nickname);
    }
    if (message.followStatus !== "0") {
      writer.uint32(72).int64(message.followStatus);
    }
    if (message.mHashtag !== undefined) {
      LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag.encode(
        message.mHashtag,
        writer.uint32(82).fork(),
      ).join();
    }
    if (message.userId !== "0") {
      writer.uint32(96).int64(message.userId);
    }
    if (message.isBestTeammate !== false) {
      writer.uint32(104).bool(message.isBestTeammate);
    }
    if (message.optPairInfo !== undefined) {
      LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo.encode(
        message.optPairInfo,
        writer.uint32(114).fork(),
      ).join();
    }
    if (message.followerCount !== "0") {
      writer.uint32(120).int64(message.followerCount);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.textType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.userCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.avatarThumb = Image.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.displayId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.authenticationInfo = LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo
            .decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.followStatus = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.mHashtag = LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isBestTeammate = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.optPairInfo = LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.followerCount = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra>, I>>(
    base?: I,
  ): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra {
    return LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra>, I>>(
    object: I,
  ): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra {
    const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra();
    message.textType = object.textType ?? 0;
    message.text = object.text ?? "";
    message.label = object.label ?? "";
    message.userCount = object.userCount ?? 0;
    message.avatarThumb = (object.avatarThumb !== undefined && object.avatarThumb !== null)
      ? Image.fromPartial(object.avatarThumb)
      : undefined;
    message.displayId = object.displayId ?? "";
    message.authenticationInfo = (object.authenticationInfo !== undefined && object.authenticationInfo !== null)
      ? LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo.fromPartial(
        object.authenticationInfo,
      )
      : undefined;
    message.nickname = object.nickname ?? "";
    message.followStatus = object.followStatus ?? "0";
    message.mHashtag = (object.mHashtag !== undefined && object.mHashtag !== null)
      ? LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag.fromPartial(object.mHashtag)
      : undefined;
    message.userId = object.userId ?? "0";
    message.isBestTeammate = object.isBestTeammate ?? false;
    message.optPairInfo = (object.optPairInfo !== undefined && object.optPairInfo !== null)
      ? LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo.fromPartial(object.optPairInfo)
      : undefined;
    message.followerCount = object.followerCount ?? "0";
    return message;
  },
};

function createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo(): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo {
  return { customVerify: "", enterpriseVerifyReason: "", authenticationBadge: undefined };
}

export const LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo: MessageFns<
  LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo
> = {
  encode(
    message: LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.customVerify !== "") {
      writer.uint32(10).string(message.customVerify);
    }
    if (message.enterpriseVerifyReason !== "") {
      writer.uint32(18).string(message.enterpriseVerifyReason);
    }
    if (message.authenticationBadge !== undefined) {
      Image.encode(message.authenticationBadge, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.customVerify = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.enterpriseVerifyReason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authenticationBadge = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<
    I extends Exact<DeepPartial<LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo>, I>,
  >(base?: I): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo {
    return LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo.fromPartial(
      base ?? ({} as any),
    );
  },
  fromPartial<
    I extends Exact<DeepPartial<LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo>, I>,
  >(object: I): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo {
    const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo();
    message.customVerify = object.customVerify ?? "";
    message.enterpriseVerifyReason = object.enterpriseVerifyReason ?? "";
    message.authenticationBadge = (object.authenticationBadge !== undefined && object.authenticationBadge !== null)
      ? Image.fromPartial(object.authenticationBadge)
      : undefined;
    return message;
  },
};

function createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag(): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag {
  return { id: "0", title: "", image: undefined, namespace: 0 };
}

export const LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag: MessageFns<
  LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag
> = {
  encode(
    message: LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.image !== undefined) {
      Image.encode(message.image, writer.uint32(26).fork()).join();
    }
    if (message.namespace !== 0) {
      writer.uint32(32).int32(message.namespace);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.image = Image.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.namespace = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag>, I>>(
    base?: I,
  ): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag {
    return LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag>, I>>(
    object: I,
  ): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag {
    const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag();
    message.id = object.id ?? "0";
    message.title = object.title ?? "";
    message.image = (object.image !== undefined && object.image !== null) ? Image.fromPartial(object.image) : undefined;
    message.namespace = object.namespace ?? 0;
    return message;
  },
};

function createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo(): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo {
  return { mappingId: "0", displayUserList: [], buttonNoticeType: 0, expectedTimeSec: "0", optPairType: "0" };
}

export const LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo: MessageFns<
  LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo
> = {
  encode(
    message: LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.mappingId !== "0") {
      writer.uint32(8).int64(message.mappingId);
    }
    for (const v of message.displayUserList) {
      LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser.encode(
        v!,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.buttonNoticeType !== 0) {
      writer.uint32(24).int32(message.buttonNoticeType);
    }
    if (message.expectedTimeSec !== "0") {
      writer.uint32(32).int64(message.expectedTimeSec);
    }
    if (message.optPairType !== "0") {
      writer.uint32(40).int64(message.optPairType);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.mappingId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayUserList.push(
            LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser.decode(
              reader,
              reader.uint32(),
            ),
          );
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.buttonNoticeType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.expectedTimeSec = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.optPairType = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo>, I>>(
    base?: I,
  ): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo {
    return LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<
    I extends Exact<DeepPartial<LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo>, I>,
  >(object: I): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo {
    const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo();
    message.mappingId = object.mappingId ?? "0";
    message.displayUserList =
      object.displayUserList?.map((e) =>
        LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser.fromPartial(e)
      ) || [];
    message.buttonNoticeType = object.buttonNoticeType ?? 0;
    message.expectedTimeSec = object.expectedTimeSec ?? "0";
    message.optPairType = object.optPairType ?? "0";
    return message;
  },
};

function createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser(): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser {
  return { user: undefined, roomId: "0" };
}

export const LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser: MessageFns<
  LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser
> = {
  encode(
    message: LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.roomId !== "0") {
      writer.uint32(16).int64(message.roomId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.roomId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<
    I extends Exact<
      DeepPartial<LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser>,
      I
    >,
  >(base?: I): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser {
    return LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser.fromPartial(
      base ?? ({} as any),
    );
  },
  fromPartial<
    I extends Exact<
      DeepPartial<LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser>,
      I
    >,
  >(object: I): LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser {
    const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.roomId = object.roomId ?? "0";
    return message;
  },
};

function createBaseCohostTopic(): CohostTopic {
  return { id: "0", titleKey: "", titleText: "", liked: false, totalHeat: "0", totalRivals: "0", rivalsAvatar: [] };
}

export const CohostTopic: MessageFns<CohostTopic> = {
  encode(message: CohostTopic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.titleKey !== "") {
      writer.uint32(18).string(message.titleKey);
    }
    if (message.titleText !== "") {
      writer.uint32(26).string(message.titleText);
    }
    if (message.liked !== false) {
      writer.uint32(168).bool(message.liked);
    }
    if (message.totalHeat !== "0") {
      writer.uint32(176).int64(message.totalHeat);
    }
    if (message.totalRivals !== "0") {
      writer.uint32(184).int64(message.totalRivals);
    }
    for (const v of message.rivalsAvatar) {
      Image.encode(v!, writer.uint32(194).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CohostTopic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCohostTopic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.titleKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.titleText = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.liked = reader.bool();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.totalHeat = reader.int64().toString();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.totalRivals = reader.int64().toString();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.rivalsAvatar.push(Image.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<CohostTopic>, I>>(base?: I): CohostTopic {
    return CohostTopic.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CohostTopic>, I>>(object: I): CohostTopic {
    const message = createBaseCohostTopic();
    message.id = object.id ?? "0";
    message.titleKey = object.titleKey ?? "";
    message.titleText = object.titleText ?? "";
    message.liked = object.liked ?? false;
    message.totalHeat = object.totalHeat ?? "0";
    message.totalRivals = object.totalRivals ?? "0";
    message.rivalsAvatar = object.rivalsAvatar?.map((e) => Image.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLinkerKickOutContent(): LinkerKickOutContent {
  return { fromUserId: "0", kickoutReason: 0 };
}

export const LinkerKickOutContent: MessageFns<LinkerKickOutContent> = {
  encode(message: LinkerKickOutContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUserId !== "0") {
      writer.uint32(8).int64(message.fromUserId);
    }
    if (message.kickoutReason !== 0) {
      writer.uint32(16).int32(message.kickoutReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerKickOutContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerKickOutContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromUserId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.kickoutReason = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerKickOutContent>, I>>(base?: I): LinkerKickOutContent {
    return LinkerKickOutContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerKickOutContent>, I>>(object: I): LinkerKickOutContent {
    const message = createBaseLinkerKickOutContent();
    message.fromUserId = object.fromUserId ?? "0";
    message.kickoutReason = object.kickoutReason ?? 0;
    return message;
  },
};

function createBaseLinkerLeaveContent(): LinkerLeaveContent {
  return { userId: "0", linkmicIdStr: "", sendLeaveUid: "0", leaveReason: "0" };
}

export const LinkerLeaveContent: MessageFns<LinkerLeaveContent> = {
  encode(message: LinkerLeaveContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.linkmicIdStr !== "") {
      writer.uint32(18).string(message.linkmicIdStr);
    }
    if (message.sendLeaveUid !== "0") {
      writer.uint32(24).int64(message.sendLeaveUid);
    }
    if (message.leaveReason !== "0") {
      writer.uint32(32).int64(message.leaveReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerLeaveContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerLeaveContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.linkmicIdStr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sendLeaveUid = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.leaveReason = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerLeaveContent>, I>>(base?: I): LinkerLeaveContent {
    return LinkerLeaveContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerLeaveContent>, I>>(object: I): LinkerLeaveContent {
    const message = createBaseLinkerLeaveContent();
    message.userId = object.userId ?? "0";
    message.linkmicIdStr = object.linkmicIdStr ?? "";
    message.sendLeaveUid = object.sendLeaveUid ?? "0";
    message.leaveReason = object.leaveReason ?? "0";
    return message;
  },
};

function createBaseLinkerLinkedListChangeContent(): LinkerLinkedListChangeContent {
  return {};
}

export const LinkerLinkedListChangeContent: MessageFns<LinkerLinkedListChangeContent> = {
  encode(_: LinkerLinkedListChangeContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerLinkedListChangeContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerLinkedListChangeContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerLinkedListChangeContent>, I>>(base?: I): LinkerLinkedListChangeContent {
    return LinkerLinkedListChangeContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerLinkedListChangeContent>, I>>(_: I): LinkerLinkedListChangeContent {
    const message = createBaseLinkerLinkedListChangeContent();
    return message;
  },
};

function createBaseCohostListChangeContent(): CohostListChangeContent {
  return {};
}

export const CohostListChangeContent: MessageFns<CohostListChangeContent> = {
  encode(_: CohostListChangeContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CohostListChangeContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCohostListChangeContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<CohostListChangeContent>, I>>(base?: I): CohostListChangeContent {
    return CohostListChangeContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CohostListChangeContent>, I>>(_: I): CohostListChangeContent {
    const message = createBaseCohostListChangeContent();
    return message;
  },
};

function createBaseLinkerListChangeContent(): LinkerListChangeContent {
  return { linkedUsers: [], appliedUsers: [], connectingUsers: [] };
}

export const LinkerListChangeContent: MessageFns<LinkerListChangeContent> = {
  encode(message: LinkerListChangeContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.linkedUsers) {
      ListUser.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.appliedUsers) {
      ListUser.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.connectingUsers) {
      ListUser.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerListChangeContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerListChangeContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.linkedUsers.push(ListUser.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appliedUsers.push(ListUser.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.connectingUsers.push(ListUser.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerListChangeContent>, I>>(base?: I): LinkerListChangeContent {
    return LinkerListChangeContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerListChangeContent>, I>>(object: I): LinkerListChangeContent {
    const message = createBaseLinkerListChangeContent();
    message.linkedUsers = object.linkedUsers?.map((e) => ListUser.fromPartial(e)) || [];
    message.appliedUsers = object.appliedUsers?.map((e) => ListUser.fromPartial(e)) || [];
    message.connectingUsers = object.connectingUsers?.map((e) => ListUser.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLinkerMediaChangeContent(): LinkerMediaChangeContent {
  return { op: 0, toUserId: "0", anchorId: "0", roomId: "0", changeScene: 0, operatorInfo: undefined };
}

export const LinkerMediaChangeContent: MessageFns<LinkerMediaChangeContent> = {
  encode(message: LinkerMediaChangeContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    if (message.toUserId !== "0") {
      writer.uint32(16).int64(message.toUserId);
    }
    if (message.anchorId !== "0") {
      writer.uint32(24).int64(message.anchorId);
    }
    if (message.roomId !== "0") {
      writer.uint32(32).int64(message.roomId);
    }
    if (message.changeScene !== 0) {
      writer.uint32(40).int32(message.changeScene);
    }
    if (message.operatorInfo !== undefined) {
      LinkerMediaChangeContent_LinkerMediaChangeOperator.encode(message.operatorInfo, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerMediaChangeContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerMediaChangeContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.op = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.toUserId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.anchorId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.roomId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.changeScene = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.operatorInfo = LinkerMediaChangeContent_LinkerMediaChangeOperator.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerMediaChangeContent>, I>>(base?: I): LinkerMediaChangeContent {
    return LinkerMediaChangeContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerMediaChangeContent>, I>>(object: I): LinkerMediaChangeContent {
    const message = createBaseLinkerMediaChangeContent();
    message.op = object.op ?? 0;
    message.toUserId = object.toUserId ?? "0";
    message.anchorId = object.anchorId ?? "0";
    message.roomId = object.roomId ?? "0";
    message.changeScene = object.changeScene ?? 0;
    message.operatorInfo = (object.operatorInfo !== undefined && object.operatorInfo !== null)
      ? LinkerMediaChangeContent_LinkerMediaChangeOperator.fromPartial(object.operatorInfo)
      : undefined;
    return message;
  },
};

function createBaseLinkerMediaChangeContent_LinkerMediaChangeOperator(): LinkerMediaChangeContent_LinkerMediaChangeOperator {
  return { userId: "0", operatorType: 0, nickName: "", displayId: "" };
}

export const LinkerMediaChangeContent_LinkerMediaChangeOperator: MessageFns<
  LinkerMediaChangeContent_LinkerMediaChangeOperator
> = {
  encode(
    message: LinkerMediaChangeContent_LinkerMediaChangeOperator,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.operatorType !== 0) {
      writer.uint32(16).int32(message.operatorType);
    }
    if (message.nickName !== "") {
      writer.uint32(26).string(message.nickName);
    }
    if (message.displayId !== "") {
      writer.uint32(34).string(message.displayId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerMediaChangeContent_LinkerMediaChangeOperator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerMediaChangeContent_LinkerMediaChangeOperator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.operatorType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nickName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.displayId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerMediaChangeContent_LinkerMediaChangeOperator>, I>>(
    base?: I,
  ): LinkerMediaChangeContent_LinkerMediaChangeOperator {
    return LinkerMediaChangeContent_LinkerMediaChangeOperator.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerMediaChangeContent_LinkerMediaChangeOperator>, I>>(
    object: I,
  ): LinkerMediaChangeContent_LinkerMediaChangeOperator {
    const message = createBaseLinkerMediaChangeContent_LinkerMediaChangeOperator();
    message.userId = object.userId ?? "0";
    message.operatorType = object.operatorType ?? 0;
    message.nickName = object.nickName ?? "";
    message.displayId = object.displayId ?? "";
    return message;
  },
};

function createBaseLinkerMicIdxUpdateContent(): LinkerMicIdxUpdateContent {
  return {};
}

export const LinkerMicIdxUpdateContent: MessageFns<LinkerMicIdxUpdateContent> = {
  encode(_: LinkerMicIdxUpdateContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerMicIdxUpdateContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerMicIdxUpdateContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerMicIdxUpdateContent>, I>>(base?: I): LinkerMicIdxUpdateContent {
    return LinkerMicIdxUpdateContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerMicIdxUpdateContent>, I>>(_: I): LinkerMicIdxUpdateContent {
    const message = createBaseLinkerMicIdxUpdateContent();
    return message;
  },
};

function createBaseLinkerMuteContent(): LinkerMuteContent {
  return { userId: "0", status: 0 };
}

export const LinkerMuteContent: MessageFns<LinkerMuteContent> = {
  encode(message: LinkerMuteContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerMuteContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerMuteContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerMuteContent>, I>>(base?: I): LinkerMuteContent {
    return LinkerMuteContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerMuteContent>, I>>(object: I): LinkerMuteContent {
    const message = createBaseLinkerMuteContent();
    message.userId = object.userId ?? "0";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseLinkerRandomMatchContent(): LinkerRandomMatchContent {
  return { user: undefined, roomId: "0", inviteType: "0", matchId: "", innerChannelId: "0" };
}

export const LinkerRandomMatchContent: MessageFns<LinkerRandomMatchContent> = {
  encode(message: LinkerRandomMatchContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.roomId !== "0") {
      writer.uint32(16).int64(message.roomId);
    }
    if (message.inviteType !== "0") {
      writer.uint32(24).int64(message.inviteType);
    }
    if (message.matchId !== "") {
      writer.uint32(34).string(message.matchId);
    }
    if (message.innerChannelId !== "0") {
      writer.uint32(40).int64(message.innerChannelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerRandomMatchContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerRandomMatchContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.roomId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.inviteType = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.matchId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.innerChannelId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerRandomMatchContent>, I>>(base?: I): LinkerRandomMatchContent {
    return LinkerRandomMatchContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerRandomMatchContent>, I>>(object: I): LinkerRandomMatchContent {
    const message = createBaseLinkerRandomMatchContent();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.roomId = object.roomId ?? "0";
    message.inviteType = object.inviteType ?? "0";
    message.matchId = object.matchId ?? "";
    message.innerChannelId = object.innerChannelId ?? "0";
    return message;
  },
};

function createBaseLinkerReplyContent(): LinkerReplyContent {
  return {
    fromUserId: "0",
    fromRoomId: "0",
    fromUserLinkmicInfo: undefined,
    toUserId: "0",
    toUserLinkmicInfo: undefined,
    linkType: "0",
    replyStatus: "0",
    linkerSetting: undefined,
    fromUser: undefined,
    toUser: undefined,
  };
}

export const LinkerReplyContent: MessageFns<LinkerReplyContent> = {
  encode(message: LinkerReplyContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUserId !== "0") {
      writer.uint32(8).int64(message.fromUserId);
    }
    if (message.fromRoomId !== "0") {
      writer.uint32(16).int64(message.fromRoomId);
    }
    if (message.fromUserLinkmicInfo !== undefined) {
      LinkerReplyContent_LinkmicInfo.encode(message.fromUserLinkmicInfo, writer.uint32(26).fork()).join();
    }
    if (message.toUserId !== "0") {
      writer.uint32(32).int64(message.toUserId);
    }
    if (message.toUserLinkmicInfo !== undefined) {
      LinkerReplyContent_LinkmicInfo.encode(message.toUserLinkmicInfo, writer.uint32(42).fork()).join();
    }
    if (message.linkType !== "0") {
      writer.uint32(48).int64(message.linkType);
    }
    if (message.replyStatus !== "0") {
      writer.uint32(56).int64(message.replyStatus);
    }
    if (message.linkerSetting !== undefined) {
      LinkerSetting.encode(message.linkerSetting, writer.uint32(66).fork()).join();
    }
    if (message.fromUser !== undefined) {
      User.encode(message.fromUser, writer.uint32(74).fork()).join();
    }
    if (message.toUser !== undefined) {
      User.encode(message.toUser, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerReplyContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerReplyContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromUserId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fromRoomId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fromUserLinkmicInfo = LinkerReplyContent_LinkmicInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.toUserId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.toUserLinkmicInfo = LinkerReplyContent_LinkmicInfo.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.linkType = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.replyStatus = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.linkerSetting = LinkerSetting.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.fromUser = User.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.toUser = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerReplyContent>, I>>(base?: I): LinkerReplyContent {
    return LinkerReplyContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerReplyContent>, I>>(object: I): LinkerReplyContent {
    const message = createBaseLinkerReplyContent();
    message.fromUserId = object.fromUserId ?? "0";
    message.fromRoomId = object.fromRoomId ?? "0";
    message.fromUserLinkmicInfo = (object.fromUserLinkmicInfo !== undefined && object.fromUserLinkmicInfo !== null)
      ? LinkerReplyContent_LinkmicInfo.fromPartial(object.fromUserLinkmicInfo)
      : undefined;
    message.toUserId = object.toUserId ?? "0";
    message.toUserLinkmicInfo = (object.toUserLinkmicInfo !== undefined && object.toUserLinkmicInfo !== null)
      ? LinkerReplyContent_LinkmicInfo.fromPartial(object.toUserLinkmicInfo)
      : undefined;
    message.linkType = object.linkType ?? "0";
    message.replyStatus = object.replyStatus ?? "0";
    message.linkerSetting = (object.linkerSetting !== undefined && object.linkerSetting !== null)
      ? LinkerSetting.fromPartial(object.linkerSetting)
      : undefined;
    message.fromUser = (object.fromUser !== undefined && object.fromUser !== null)
      ? User.fromPartial(object.fromUser)
      : undefined;
    message.toUser = (object.toUser !== undefined && object.toUser !== null)
      ? User.fromPartial(object.toUser)
      : undefined;
    return message;
  },
};

function createBaseLinkerReplyContent_LinkmicInfo(): LinkerReplyContent_LinkmicInfo {
  return {
    accessKey: "",
    linkMicId: "0",
    joinable: false,
    confluenceType: 0,
    rtcExtInfo: "",
    rtcAppId: "",
    rtcAppSign: "",
    linkmicIdStr: "",
    vendor: "0",
  };
}

export const LinkerReplyContent_LinkmicInfo: MessageFns<LinkerReplyContent_LinkmicInfo> = {
  encode(message: LinkerReplyContent_LinkmicInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessKey !== "") {
      writer.uint32(10).string(message.accessKey);
    }
    if (message.linkMicId !== "0") {
      writer.uint32(16).int64(message.linkMicId);
    }
    if (message.joinable !== false) {
      writer.uint32(24).bool(message.joinable);
    }
    if (message.confluenceType !== 0) {
      writer.uint32(32).int32(message.confluenceType);
    }
    if (message.rtcExtInfo !== "") {
      writer.uint32(42).string(message.rtcExtInfo);
    }
    if (message.rtcAppId !== "") {
      writer.uint32(50).string(message.rtcAppId);
    }
    if (message.rtcAppSign !== "") {
      writer.uint32(58).string(message.rtcAppSign);
    }
    if (message.linkmicIdStr !== "") {
      writer.uint32(66).string(message.linkmicIdStr);
    }
    if (message.vendor !== "0") {
      writer.uint32(72).int64(message.vendor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerReplyContent_LinkmicInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerReplyContent_LinkmicInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.linkMicId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.joinable = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.confluenceType = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rtcExtInfo = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rtcAppId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rtcAppSign = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.linkmicIdStr = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.vendor = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerReplyContent_LinkmicInfo>, I>>(base?: I): LinkerReplyContent_LinkmicInfo {
    return LinkerReplyContent_LinkmicInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerReplyContent_LinkmicInfo>, I>>(
    object: I,
  ): LinkerReplyContent_LinkmicInfo {
    const message = createBaseLinkerReplyContent_LinkmicInfo();
    message.accessKey = object.accessKey ?? "";
    message.linkMicId = object.linkMicId ?? "0";
    message.joinable = object.joinable ?? false;
    message.confluenceType = object.confluenceType ?? 0;
    message.rtcExtInfo = object.rtcExtInfo ?? "";
    message.rtcAppId = object.rtcAppId ?? "";
    message.rtcAppSign = object.rtcAppSign ?? "";
    message.linkmicIdStr = object.linkmicIdStr ?? "";
    message.vendor = object.vendor ?? "0";
    return message;
  },
};

function createBaseLinkerSetting(): LinkerSetting {
  return { MaxMemberLimit: "0", LinkType: "0", Scene: 0, OwnerUserId: "0", OwnerRoomId: "0", Vendor: "0" };
}

export const LinkerSetting: MessageFns<LinkerSetting> = {
  encode(message: LinkerSetting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.MaxMemberLimit !== "0") {
      writer.uint32(8).int64(message.MaxMemberLimit);
    }
    if (message.LinkType !== "0") {
      writer.uint32(16).int64(message.LinkType);
    }
    if (message.Scene !== 0) {
      writer.uint32(24).int32(message.Scene);
    }
    if (message.OwnerUserId !== "0") {
      writer.uint32(32).int64(message.OwnerUserId);
    }
    if (message.OwnerRoomId !== "0") {
      writer.uint32(40).int64(message.OwnerRoomId);
    }
    if (message.Vendor !== "0") {
      writer.uint32(48).int64(message.Vendor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerSetting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerSetting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.MaxMemberLimit = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.LinkType = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.Scene = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.OwnerUserId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.OwnerRoomId = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.Vendor = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerSetting>, I>>(base?: I): LinkerSetting {
    return LinkerSetting.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerSetting>, I>>(object: I): LinkerSetting {
    const message = createBaseLinkerSetting();
    message.MaxMemberLimit = object.MaxMemberLimit ?? "0";
    message.LinkType = object.LinkType ?? "0";
    message.Scene = object.Scene ?? 0;
    message.OwnerUserId = object.OwnerUserId ?? "0";
    message.OwnerRoomId = object.OwnerRoomId ?? "0";
    message.Vendor = object.Vendor ?? "0";
    return message;
  },
};

function createBaseLinkerSysKickOutContent(): LinkerSysKickOutContent {
  return { userId: "0", linkmicIdStr: "" };
}

export const LinkerSysKickOutContent: MessageFns<LinkerSysKickOutContent> = {
  encode(message: LinkerSysKickOutContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.linkmicIdStr !== "") {
      writer.uint32(18).string(message.linkmicIdStr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerSysKickOutContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerSysKickOutContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.linkmicIdStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerSysKickOutContent>, I>>(base?: I): LinkerSysKickOutContent {
    return LinkerSysKickOutContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerSysKickOutContent>, I>>(object: I): LinkerSysKickOutContent {
    const message = createBaseLinkerSysKickOutContent();
    message.userId = object.userId ?? "0";
    message.linkmicIdStr = object.linkmicIdStr ?? "";
    return message;
  },
};

function createBaseLinkmicUserToastContent(): LinkmicUserToastContent {
  return { userId: "0", roomId: "0", displayText: undefined, leavedUserId: "0" };
}

export const LinkmicUserToastContent: MessageFns<LinkmicUserToastContent> = {
  encode(message: LinkmicUserToastContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.roomId !== "0") {
      writer.uint32(16).int64(message.roomId);
    }
    if (message.displayText !== undefined) {
      Text.encode(message.displayText, writer.uint32(26).fork()).join();
    }
    if (message.leavedUserId !== "0") {
      writer.uint32(32).int64(message.leavedUserId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkmicUserToastContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkmicUserToastContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.roomId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.displayText = Text.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.leavedUserId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkmicUserToastContent>, I>>(base?: I): LinkmicUserToastContent {
    return LinkmicUserToastContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkmicUserToastContent>, I>>(object: I): LinkmicUserToastContent {
    const message = createBaseLinkmicUserToastContent();
    message.userId = object.userId ?? "0";
    message.roomId = object.roomId ?? "0";
    message.displayText = (object.displayText !== undefined && object.displayText !== null)
      ? Text.fromPartial(object.displayText)
      : undefined;
    message.leavedUserId = object.leavedUserId ?? "0";
    return message;
  },
};

function createBaseLinkerUpdateUserContent(): LinkerUpdateUserContent {
  return { fromUserId: "0", toUserId: "0", updateInfo: {} };
}

export const LinkerUpdateUserContent: MessageFns<LinkerUpdateUserContent> = {
  encode(message: LinkerUpdateUserContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUserId !== "0") {
      writer.uint32(8).int64(message.fromUserId);
    }
    if (message.toUserId !== "0") {
      writer.uint32(16).int64(message.toUserId);
    }
    Object.entries(message.updateInfo).forEach(([key, value]) => {
      LinkerUpdateUserContent_UpdateInfoEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerUpdateUserContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerUpdateUserContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromUserId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.toUserId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = LinkerUpdateUserContent_UpdateInfoEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.updateInfo[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerUpdateUserContent>, I>>(base?: I): LinkerUpdateUserContent {
    return LinkerUpdateUserContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerUpdateUserContent>, I>>(object: I): LinkerUpdateUserContent {
    const message = createBaseLinkerUpdateUserContent();
    message.fromUserId = object.fromUserId ?? "0";
    message.toUserId = object.toUserId ?? "0";
    message.updateInfo = Object.entries(object.updateInfo ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseLinkerUpdateUserContent_UpdateInfoEntry(): LinkerUpdateUserContent_UpdateInfoEntry {
  return { key: "", value: "" };
}

export const LinkerUpdateUserContent_UpdateInfoEntry: MessageFns<LinkerUpdateUserContent_UpdateInfoEntry> = {
  encode(message: LinkerUpdateUserContent_UpdateInfoEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerUpdateUserContent_UpdateInfoEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerUpdateUserContent_UpdateInfoEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerUpdateUserContent_UpdateInfoEntry>, I>>(
    base?: I,
  ): LinkerUpdateUserContent_UpdateInfoEntry {
    return LinkerUpdateUserContent_UpdateInfoEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerUpdateUserContent_UpdateInfoEntry>, I>>(
    object: I,
  ): LinkerUpdateUserContent_UpdateInfoEntry {
    const message = createBaseLinkerUpdateUserContent_UpdateInfoEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseLinkerUpdateUserSettingContent(): LinkerUpdateUserSettingContent {
  return { multiLiveAnchorPanelSettings: undefined };
}

export const LinkerUpdateUserSettingContent: MessageFns<LinkerUpdateUserSettingContent> = {
  encode(message: LinkerUpdateUserSettingContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.multiLiveAnchorPanelSettings !== undefined) {
      MultiLiveAnchorPanelSettings.encode(message.multiLiveAnchorPanelSettings, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerUpdateUserSettingContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerUpdateUserSettingContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.multiLiveAnchorPanelSettings = MultiLiveAnchorPanelSettings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerUpdateUserSettingContent>, I>>(base?: I): LinkerUpdateUserSettingContent {
    return LinkerUpdateUserSettingContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerUpdateUserSettingContent>, I>>(
    object: I,
  ): LinkerUpdateUserSettingContent {
    const message = createBaseLinkerUpdateUserSettingContent();
    message.multiLiveAnchorPanelSettings =
      (object.multiLiveAnchorPanelSettings !== undefined && object.multiLiveAnchorPanelSettings !== null)
        ? MultiLiveAnchorPanelSettings.fromPartial(object.multiLiveAnchorPanelSettings)
        : undefined;
    return message;
  },
};

function createBaseLinkerWaitingListChangeContent(): LinkerWaitingListChangeContent {
  return {};
}

export const LinkerWaitingListChangeContent: MessageFns<LinkerWaitingListChangeContent> = {
  encode(_: LinkerWaitingListChangeContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkerWaitingListChangeContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkerWaitingListChangeContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkerWaitingListChangeContent>, I>>(base?: I): LinkerWaitingListChangeContent {
    return LinkerWaitingListChangeContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkerWaitingListChangeContent>, I>>(_: I): LinkerWaitingListChangeContent {
    const message = createBaseLinkerWaitingListChangeContent();
    return message;
  },
};

function createBaseMultiLiveAnchorPanelSettings(): MultiLiveAnchorPanelSettings {
  return {
    userId: "0",
    layout: "0",
    fixMicNum: "0",
    allowRequestFromUser: "0",
    allowRequestFromFollowerOnly: "0",
    applierSortSetting: 0,
    applierSortGiftScoreThreshold: "0",
    allowRequestFromFriends: 0,
    allowRequestFromFollowers: 0,
    allowRequestFromOthers: 0,
    enableShowMultiGuestLayout: 0,
  };
}

export const MultiLiveAnchorPanelSettings: MessageFns<MultiLiveAnchorPanelSettings> = {
  encode(message: MultiLiveAnchorPanelSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.layout !== "0") {
      writer.uint32(16).int64(message.layout);
    }
    if (message.fixMicNum !== "0") {
      writer.uint32(24).int64(message.fixMicNum);
    }
    if (message.allowRequestFromUser !== "0") {
      writer.uint32(32).int64(message.allowRequestFromUser);
    }
    if (message.allowRequestFromFollowerOnly !== "0") {
      writer.uint32(40).int64(message.allowRequestFromFollowerOnly);
    }
    if (message.applierSortSetting !== 0) {
      writer.uint32(56).int32(message.applierSortSetting);
    }
    if (message.applierSortGiftScoreThreshold !== "0") {
      writer.uint32(64).int64(message.applierSortGiftScoreThreshold);
    }
    if (message.allowRequestFromFriends !== 0) {
      writer.uint32(72).int32(message.allowRequestFromFriends);
    }
    if (message.allowRequestFromFollowers !== 0) {
      writer.uint32(80).int32(message.allowRequestFromFollowers);
    }
    if (message.allowRequestFromOthers !== 0) {
      writer.uint32(88).int32(message.allowRequestFromOthers);
    }
    if (message.enableShowMultiGuestLayout !== 0) {
      writer.uint32(96).int32(message.enableShowMultiGuestLayout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiLiveAnchorPanelSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiLiveAnchorPanelSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.layout = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fixMicNum = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.allowRequestFromUser = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.allowRequestFromFollowerOnly = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.applierSortSetting = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.applierSortGiftScoreThreshold = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.allowRequestFromFriends = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.allowRequestFromFollowers = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.allowRequestFromOthers = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.enableShowMultiGuestLayout = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<MultiLiveAnchorPanelSettings>, I>>(base?: I): MultiLiveAnchorPanelSettings {
    return MultiLiveAnchorPanelSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiLiveAnchorPanelSettings>, I>>(object: I): MultiLiveAnchorPanelSettings {
    const message = createBaseMultiLiveAnchorPanelSettings();
    message.userId = object.userId ?? "0";
    message.layout = object.layout ?? "0";
    message.fixMicNum = object.fixMicNum ?? "0";
    message.allowRequestFromUser = object.allowRequestFromUser ?? "0";
    message.allowRequestFromFollowerOnly = object.allowRequestFromFollowerOnly ?? "0";
    message.applierSortSetting = object.applierSortSetting ?? 0;
    message.applierSortGiftScoreThreshold = object.applierSortGiftScoreThreshold ?? "0";
    message.allowRequestFromFriends = object.allowRequestFromFriends ?? 0;
    message.allowRequestFromFollowers = object.allowRequestFromFollowers ?? 0;
    message.allowRequestFromOthers = object.allowRequestFromOthers ?? 0;
    message.enableShowMultiGuestLayout = object.enableShowMultiGuestLayout ?? 0;
    return message;
  },
};

function createBasePlayer(): Player {
  return { roomId: "0", userId: "0" };
}

export const Player: MessageFns<Player> = {
  encode(message: Player, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== "0") {
      writer.uint32(8).int64(message.roomId);
    }
    if (message.userId !== "0") {
      writer.uint32(16).int64(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Player {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.roomId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Player>, I>>(base?: I): Player {
    return Player.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Player>, I>>(object: I): Player {
    const message = createBasePlayer();
    message.roomId = object.roomId ?? "0";
    message.userId = object.userId ?? "0";
    return message;
  },
};

function createBaseAllListUser(): AllListUser {
  return { linkedList: [], appliedList: [], invitedList: [], readyList: [] };
}

export const AllListUser: MessageFns<AllListUser> = {
  encode(message: AllListUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.linkedList) {
      LinkLayerListUser.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.appliedList) {
      LinkLayerListUser.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.invitedList) {
      LinkLayerListUser.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.readyList) {
      LinkLayerListUser.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllListUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllListUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.linkedList.push(LinkLayerListUser.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.appliedList.push(LinkLayerListUser.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.invitedList.push(LinkLayerListUser.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.readyList.push(LinkLayerListUser.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<AllListUser>, I>>(base?: I): AllListUser {
    return AllListUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllListUser>, I>>(object: I): AllListUser {
    const message = createBaseAllListUser();
    message.linkedList = object.linkedList?.map((e) => LinkLayerListUser.fromPartial(e)) || [];
    message.appliedList = object.appliedList?.map((e) => LinkLayerListUser.fromPartial(e)) || [];
    message.invitedList = object.invitedList?.map((e) => LinkLayerListUser.fromPartial(e)) || [];
    message.readyList = object.readyList?.map((e) => LinkLayerListUser.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLinkLayerListUser(): LinkLayerListUser {
  return { user: undefined, linkmicId: "0", pos: undefined, linkedTimeNano: "0", appVersion: "", magicNumber1: "0" };
}

export const LinkLayerListUser: MessageFns<LinkLayerListUser> = {
  encode(message: LinkLayerListUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.linkmicId !== "0") {
      writer.uint32(16).int64(message.linkmicId);
    }
    if (message.pos !== undefined) {
      Position.encode(message.pos, writer.uint32(26).fork()).join();
    }
    if (message.linkedTimeNano !== "0") {
      writer.uint32(32).int64(message.linkedTimeNano);
    }
    if (message.appVersion !== "") {
      writer.uint32(42).string(message.appVersion);
    }
    if (message.magicNumber1 !== "0") {
      writer.uint32(56).int64(message.magicNumber1);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkLayerListUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkLayerListUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.linkmicId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pos = Position.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.linkedTimeNano = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.appVersion = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.magicNumber1 = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkLayerListUser>, I>>(base?: I): LinkLayerListUser {
    return LinkLayerListUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkLayerListUser>, I>>(object: I): LinkLayerListUser {
    const message = createBaseLinkLayerListUser();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.linkmicId = object.linkmicId ?? "0";
    message.pos = (object.pos !== undefined && object.pos !== null) ? Position.fromPartial(object.pos) : undefined;
    message.linkedTimeNano = object.linkedTimeNano ?? "0";
    message.appVersion = object.appVersion ?? "";
    message.magicNumber1 = object.magicNumber1 ?? "0";
    return message;
  },
};

function createBasePosition(): Position {
  return { type: 0, link: undefined };
}

export const Position: MessageFns<Position> = {
  encode(message: Position, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.link !== undefined) {
      LinkPosition.encode(message.link, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Position {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.link = LinkPosition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Position>, I>>(base?: I): Position {
    return Position.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Position>, I>>(object: I): Position {
    const message = createBasePosition();
    message.type = object.type ?? 0;
    message.link = (object.link !== undefined && object.link !== null)
      ? LinkPosition.fromPartial(object.link)
      : undefined;
    return message;
  },
};

function createBaseLinkPosition(): LinkPosition {
  return { position: 0, opt: 0 };
}

export const LinkPosition: MessageFns<LinkPosition> = {
  encode(message: LinkPosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== 0) {
      writer.uint32(8).int32(message.position);
    }
    if (message.opt !== 0) {
      writer.uint32(16).int32(message.opt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkPosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.position = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.opt = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LinkPosition>, I>>(base?: I): LinkPosition {
    return LinkPosition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkPosition>, I>>(object: I): LinkPosition {
    const message = createBaseLinkPosition();
    message.position = object.position ?? 0;
    message.opt = object.opt ?? 0;
    return message;
  },
};

function createBaseGroupPlayer(): GroupPlayer {
  return { channelId: "0", user: undefined };
}

export const GroupPlayer: MessageFns<GroupPlayer> = {
  encode(message: GroupPlayer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== "0") {
      writer.uint32(8).int64(message.channelId);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupPlayer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupPlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.channelId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<GroupPlayer>, I>>(base?: I): GroupPlayer {
    return GroupPlayer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupPlayer>, I>>(object: I): GroupPlayer {
    const message = createBaseGroupPlayer();
    message.channelId = object.channelId ?? "0";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseDSLConfig(): DSLConfig {
  return { sceneVersion: 0, layoutId: "" };
}

export const DSLConfig: MessageFns<DSLConfig> = {
  encode(message: DSLConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sceneVersion !== 0) {
      writer.uint32(8).int32(message.sceneVersion);
    }
    if (message.layoutId !== "") {
      writer.uint32(18).string(message.layoutId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DSLConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDSLConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sceneVersion = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.layoutId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<DSLConfig>, I>>(base?: I): DSLConfig {
    return DSLConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DSLConfig>, I>>(object: I): DSLConfig {
    const message = createBaseDSLConfig();
    message.sceneVersion = object.sceneVersion ?? 0;
    message.layoutId = object.layoutId ?? "";
    return message;
  },
};

function createBaseGroupChannelAllUser(): GroupChannelAllUser {
  return { groupChannelId: "0", userList: [], contentVersion: "0" };
}

export const GroupChannelAllUser: MessageFns<GroupChannelAllUser> = {
  encode(message: GroupChannelAllUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupChannelId !== "0") {
      writer.uint32(8).int64(message.groupChannelId);
    }
    for (const v of message.userList) {
      GroupChannelUser.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.contentVersion !== "0") {
      writer.uint32(24).int64(message.contentVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupChannelAllUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupChannelAllUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.groupChannelId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userList.push(GroupChannelUser.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.contentVersion = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<GroupChannelAllUser>, I>>(base?: I): GroupChannelAllUser {
    return GroupChannelAllUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupChannelAllUser>, I>>(object: I): GroupChannelAllUser {
    const message = createBaseGroupChannelAllUser();
    message.groupChannelId = object.groupChannelId ?? "0";
    message.userList = object.userList?.map((e) => GroupChannelUser.fromPartial(e)) || [];
    message.contentVersion = object.contentVersion ?? "0";
    return message;
  },
};

function createBaseGroupChannelUser(): GroupChannelUser {
  return {
    channelId: "0",
    status: 0,
    type: 0,
    allUser: undefined,
    joinTime: "0",
    linkedTime: "0",
    ownerUser: undefined,
    groupLinkmicId: "",
  };
}

export const GroupChannelUser: MessageFns<GroupChannelUser> = {
  encode(message: GroupChannelUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== "0") {
      writer.uint32(8).int64(message.channelId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.allUser !== undefined) {
      AllListUser.encode(message.allUser, writer.uint32(34).fork()).join();
    }
    if (message.joinTime !== "0") {
      writer.uint32(40).int64(message.joinTime);
    }
    if (message.linkedTime !== "0") {
      writer.uint32(48).int64(message.linkedTime);
    }
    if (message.ownerUser !== undefined) {
      GroupPlayer.encode(message.ownerUser, writer.uint32(58).fork()).join();
    }
    if (message.groupLinkmicId !== "") {
      writer.uint32(66).string(message.groupLinkmicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupChannelUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupChannelUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.channelId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.allUser = AllListUser.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.joinTime = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.linkedTime = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.ownerUser = GroupPlayer.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.groupLinkmicId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<GroupChannelUser>, I>>(base?: I): GroupChannelUser {
    return GroupChannelUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupChannelUser>, I>>(object: I): GroupChannelUser {
    const message = createBaseGroupChannelUser();
    message.channelId = object.channelId ?? "0";
    message.status = object.status ?? 0;
    message.type = object.type ?? 0;
    message.allUser = (object.allUser !== undefined && object.allUser !== null)
      ? AllListUser.fromPartial(object.allUser)
      : undefined;
    message.joinTime = object.joinTime ?? "0";
    message.linkedTime = object.linkedTime ?? "0";
    message.ownerUser = (object.ownerUser !== undefined && object.ownerUser !== null)
      ? GroupPlayer.fromPartial(object.ownerUser)
      : undefined;
    message.groupLinkmicId = object.groupLinkmicId ?? "";
    return message;
  },
};

function createBaseRTCExtraInfo(): RTCExtraInfo {
  return {
    liveRtcEngineConfig: undefined,
    liveRtcVideoParamList: [],
    rtcBitrateMap: undefined,
    rtcFps: 0,
    rtcMixBase: undefined,
    byteRtcExtInfo: undefined,
    rtcInfoExtra: undefined,
    rtcBusinessId: "",
    rtcOther: undefined,
    interactClientType: 0,
  };
}

export const RTCExtraInfo: MessageFns<RTCExtraInfo> = {
  encode(message: RTCExtraInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.liveRtcEngineConfig !== undefined) {
      RTCExtraInfo_RTCEngineConfig.encode(message.liveRtcEngineConfig, writer.uint32(10).fork()).join();
    }
    for (const v of message.liveRtcVideoParamList) {
      RTCExtraInfo_RTCLiveVideoParam.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.rtcBitrateMap !== undefined) {
      RTCExtraInfo_RTCBitrateMap.encode(message.rtcBitrateMap, writer.uint32(26).fork()).join();
    }
    if (message.rtcFps !== 0) {
      writer.uint32(32).int32(message.rtcFps);
    }
    if (message.rtcMixBase !== undefined) {
      RTCExtraInfo_RTCMixBase.encode(message.rtcMixBase, writer.uint32(42).fork()).join();
    }
    if (message.byteRtcExtInfo !== undefined) {
      RTCExtraInfo_ByteRTCExtInfo.encode(message.byteRtcExtInfo, writer.uint32(50).fork()).join();
    }
    if (message.rtcInfoExtra !== undefined) {
      RTCExtraInfo_RTCInfoExtra.encode(message.rtcInfoExtra, writer.uint32(58).fork()).join();
    }
    if (message.rtcBusinessId !== "") {
      writer.uint32(66).string(message.rtcBusinessId);
    }
    if (message.rtcOther !== undefined) {
      RTCExtraInfo_RTCOther.encode(message.rtcOther, writer.uint32(74).fork()).join();
    }
    if (message.interactClientType !== 0) {
      writer.uint32(80).int32(message.interactClientType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RTCExtraInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRTCExtraInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.liveRtcEngineConfig = RTCExtraInfo_RTCEngineConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.liveRtcVideoParamList.push(RTCExtraInfo_RTCLiveVideoParam.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rtcBitrateMap = RTCExtraInfo_RTCBitrateMap.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rtcFps = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rtcMixBase = RTCExtraInfo_RTCMixBase.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.byteRtcExtInfo = RTCExtraInfo_ByteRTCExtInfo.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rtcInfoExtra = RTCExtraInfo_RTCInfoExtra.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.rtcBusinessId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.rtcOther = RTCExtraInfo_RTCOther.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.interactClientType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<RTCExtraInfo>, I>>(base?: I): RTCExtraInfo {
    return RTCExtraInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RTCExtraInfo>, I>>(object: I): RTCExtraInfo {
    const message = createBaseRTCExtraInfo();
    message.liveRtcEngineConfig = (object.liveRtcEngineConfig !== undefined && object.liveRtcEngineConfig !== null)
      ? RTCExtraInfo_RTCEngineConfig.fromPartial(object.liveRtcEngineConfig)
      : undefined;
    message.liveRtcVideoParamList =
      object.liveRtcVideoParamList?.map((e) => RTCExtraInfo_RTCLiveVideoParam.fromPartial(e)) || [];
    message.rtcBitrateMap = (object.rtcBitrateMap !== undefined && object.rtcBitrateMap !== null)
      ? RTCExtraInfo_RTCBitrateMap.fromPartial(object.rtcBitrateMap)
      : undefined;
    message.rtcFps = object.rtcFps ?? 0;
    message.rtcMixBase = (object.rtcMixBase !== undefined && object.rtcMixBase !== null)
      ? RTCExtraInfo_RTCMixBase.fromPartial(object.rtcMixBase)
      : undefined;
    message.byteRtcExtInfo = (object.byteRtcExtInfo !== undefined && object.byteRtcExtInfo !== null)
      ? RTCExtraInfo_ByteRTCExtInfo.fromPartial(object.byteRtcExtInfo)
      : undefined;
    message.rtcInfoExtra = (object.rtcInfoExtra !== undefined && object.rtcInfoExtra !== null)
      ? RTCExtraInfo_RTCInfoExtra.fromPartial(object.rtcInfoExtra)
      : undefined;
    message.rtcBusinessId = object.rtcBusinessId ?? "";
    message.rtcOther = (object.rtcOther !== undefined && object.rtcOther !== null)
      ? RTCExtraInfo_RTCOther.fromPartial(object.rtcOther)
      : undefined;
    message.interactClientType = object.interactClientType ?? 0;
    return message;
  },
};

function createBaseRTCExtraInfo_RTCMixBase(): RTCExtraInfo_RTCMixBase {
  return { bitrate: 0 };
}

export const RTCExtraInfo_RTCMixBase: MessageFns<RTCExtraInfo_RTCMixBase> = {
  encode(message: RTCExtraInfo_RTCMixBase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bitrate !== 0) {
      writer.uint32(8).int32(message.bitrate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RTCExtraInfo_RTCMixBase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRTCExtraInfo_RTCMixBase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.bitrate = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<RTCExtraInfo_RTCMixBase>, I>>(base?: I): RTCExtraInfo_RTCMixBase {
    return RTCExtraInfo_RTCMixBase.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RTCExtraInfo_RTCMixBase>, I>>(object: I): RTCExtraInfo_RTCMixBase {
    const message = createBaseRTCExtraInfo_RTCMixBase();
    message.bitrate = object.bitrate ?? 0;
    return message;
  },
};

function createBaseRTCExtraInfo_ByteRTCExtInfo(): RTCExtraInfo_ByteRTCExtInfo {
  return { defaultSignaling: 0 };
}

export const RTCExtraInfo_ByteRTCExtInfo: MessageFns<RTCExtraInfo_ByteRTCExtInfo> = {
  encode(message: RTCExtraInfo_ByteRTCExtInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.defaultSignaling !== 0) {
      writer.uint32(8).int32(message.defaultSignaling);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RTCExtraInfo_ByteRTCExtInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRTCExtraInfo_ByteRTCExtInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.defaultSignaling = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<RTCExtraInfo_ByteRTCExtInfo>, I>>(base?: I): RTCExtraInfo_ByteRTCExtInfo {
    return RTCExtraInfo_ByteRTCExtInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RTCExtraInfo_ByteRTCExtInfo>, I>>(object: I): RTCExtraInfo_ByteRTCExtInfo {
    const message = createBaseRTCExtraInfo_ByteRTCExtInfo();
    message.defaultSignaling = object.defaultSignaling ?? 0;
    return message;
  },
};

function createBaseRTCExtraInfo_RTCInfoExtra(): RTCExtraInfo_RTCInfoExtra {
  return { version: "" };
}

export const RTCExtraInfo_RTCInfoExtra: MessageFns<RTCExtraInfo_RTCInfoExtra> = {
  encode(message: RTCExtraInfo_RTCInfoExtra, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RTCExtraInfo_RTCInfoExtra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRTCExtraInfo_RTCInfoExtra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<RTCExtraInfo_RTCInfoExtra>, I>>(base?: I): RTCExtraInfo_RTCInfoExtra {
    return RTCExtraInfo_RTCInfoExtra.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RTCExtraInfo_RTCInfoExtra>, I>>(object: I): RTCExtraInfo_RTCInfoExtra {
    const message = createBaseRTCExtraInfo_RTCInfoExtra();
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseRTCExtraInfo_RTCOther(): RTCExtraInfo_RTCOther {
  return { transCodingSecond: 0 };
}

export const RTCExtraInfo_RTCOther: MessageFns<RTCExtraInfo_RTCOther> = {
  encode(message: RTCExtraInfo_RTCOther, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transCodingSecond !== 0) {
      writer.uint32(8).int32(message.transCodingSecond);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RTCExtraInfo_RTCOther {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRTCExtraInfo_RTCOther();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.transCodingSecond = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<RTCExtraInfo_RTCOther>, I>>(base?: I): RTCExtraInfo_RTCOther {
    return RTCExtraInfo_RTCOther.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RTCExtraInfo_RTCOther>, I>>(object: I): RTCExtraInfo_RTCOther {
    const message = createBaseRTCExtraInfo_RTCOther();
    message.transCodingSecond = object.transCodingSecond ?? 0;
    return message;
  },
};

function createBaseRTCExtraInfo_RTCEngineConfig(): RTCExtraInfo_RTCEngineConfig {
  return { rtcAppId: "", rtcUserId: "", rtcToken: "", rtcChannelId: "0" };
}

export const RTCExtraInfo_RTCEngineConfig: MessageFns<RTCExtraInfo_RTCEngineConfig> = {
  encode(message: RTCExtraInfo_RTCEngineConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rtcAppId !== "") {
      writer.uint32(10).string(message.rtcAppId);
    }
    if (message.rtcUserId !== "") {
      writer.uint32(18).string(message.rtcUserId);
    }
    if (message.rtcToken !== "") {
      writer.uint32(26).string(message.rtcToken);
    }
    if (message.rtcChannelId !== "0") {
      writer.uint32(32).int64(message.rtcChannelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RTCExtraInfo_RTCEngineConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRTCExtraInfo_RTCEngineConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rtcAppId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rtcUserId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rtcToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rtcChannelId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<RTCExtraInfo_RTCEngineConfig>, I>>(base?: I): RTCExtraInfo_RTCEngineConfig {
    return RTCExtraInfo_RTCEngineConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RTCExtraInfo_RTCEngineConfig>, I>>(object: I): RTCExtraInfo_RTCEngineConfig {
    const message = createBaseRTCExtraInfo_RTCEngineConfig();
    message.rtcAppId = object.rtcAppId ?? "";
    message.rtcUserId = object.rtcUserId ?? "";
    message.rtcToken = object.rtcToken ?? "";
    message.rtcChannelId = object.rtcChannelId ?? "0";
    return message;
  },
};

function createBaseRTCExtraInfo_RTCLiveVideoParam(): RTCExtraInfo_RTCLiveVideoParam {
  return { strategyId: 0, params: undefined };
}

export const RTCExtraInfo_RTCLiveVideoParam: MessageFns<RTCExtraInfo_RTCLiveVideoParam> = {
  encode(message: RTCExtraInfo_RTCLiveVideoParam, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.strategyId !== 0) {
      writer.uint32(8).int32(message.strategyId);
    }
    if (message.params !== undefined) {
      RTCExtraInfo_RTCVideoParam.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RTCExtraInfo_RTCLiveVideoParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRTCExtraInfo_RTCLiveVideoParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.strategyId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = RTCExtraInfo_RTCVideoParam.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<RTCExtraInfo_RTCLiveVideoParam>, I>>(base?: I): RTCExtraInfo_RTCLiveVideoParam {
    return RTCExtraInfo_RTCLiveVideoParam.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RTCExtraInfo_RTCLiveVideoParam>, I>>(
    object: I,
  ): RTCExtraInfo_RTCLiveVideoParam {
    const message = createBaseRTCExtraInfo_RTCLiveVideoParam();
    message.strategyId = object.strategyId ?? 0;
    message.params = (object.params !== undefined && object.params !== null)
      ? RTCExtraInfo_RTCVideoParam.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseRTCExtraInfo_RTCVideoParam(): RTCExtraInfo_RTCVideoParam {
  return { width: 0, height: 0, fps: 0, bitrateKbps: 0 };
}

export const RTCExtraInfo_RTCVideoParam: MessageFns<RTCExtraInfo_RTCVideoParam> = {
  encode(message: RTCExtraInfo_RTCVideoParam, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.width !== 0) {
      writer.uint32(8).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(16).int32(message.height);
    }
    if (message.fps !== 0) {
      writer.uint32(24).int32(message.fps);
    }
    if (message.bitrateKbps !== 0) {
      writer.uint32(32).int32(message.bitrateKbps);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RTCExtraInfo_RTCVideoParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRTCExtraInfo_RTCVideoParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fps = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.bitrateKbps = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<RTCExtraInfo_RTCVideoParam>, I>>(base?: I): RTCExtraInfo_RTCVideoParam {
    return RTCExtraInfo_RTCVideoParam.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RTCExtraInfo_RTCVideoParam>, I>>(object: I): RTCExtraInfo_RTCVideoParam {
    const message = createBaseRTCExtraInfo_RTCVideoParam();
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.fps = object.fps ?? 0;
    message.bitrateKbps = object.bitrateKbps ?? 0;
    return message;
  },
};

function createBaseRTCExtraInfo_RTCBitrateMap(): RTCExtraInfo_RTCBitrateMap {
  return { xx1: 0, xx2: 0, xx3: 0, xx4: 0 };
}

export const RTCExtraInfo_RTCBitrateMap: MessageFns<RTCExtraInfo_RTCBitrateMap> = {
  encode(message: RTCExtraInfo_RTCBitrateMap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.xx1 !== 0) {
      writer.uint32(8).int32(message.xx1);
    }
    if (message.xx2 !== 0) {
      writer.uint32(16).int32(message.xx2);
    }
    if (message.xx3 !== 0) {
      writer.uint32(24).int32(message.xx3);
    }
    if (message.xx4 !== 0) {
      writer.uint32(32).int32(message.xx4);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RTCExtraInfo_RTCBitrateMap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRTCExtraInfo_RTCBitrateMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.xx1 = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.xx2 = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.xx3 = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.xx4 = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<RTCExtraInfo_RTCBitrateMap>, I>>(base?: I): RTCExtraInfo_RTCBitrateMap {
    return RTCExtraInfo_RTCBitrateMap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RTCExtraInfo_RTCBitrateMap>, I>>(object: I): RTCExtraInfo_RTCBitrateMap {
    const message = createBaseRTCExtraInfo_RTCBitrateMap();
    message.xx1 = object.xx1 ?? 0;
    message.xx2 = object.xx2 ?? 0;
    message.xx3 = object.xx3 ?? 0;
    message.xx4 = object.xx4 ?? 0;
    return message;
  },
};

function createBaseCreateChannelContent(): CreateChannelContent {
  return { owner: undefined, ownerLinkMicId: "" };
}

export const CreateChannelContent: MessageFns<CreateChannelContent> = {
  encode(message: CreateChannelContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== undefined) {
      Player.encode(message.owner, writer.uint32(10).fork()).join();
    }
    if (message.ownerLinkMicId !== "") {
      writer.uint32(18).string(message.ownerLinkMicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateChannelContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateChannelContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = Player.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerLinkMicId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<CreateChannelContent>, I>>(base?: I): CreateChannelContent {
    return CreateChannelContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateChannelContent>, I>>(object: I): CreateChannelContent {
    const message = createBaseCreateChannelContent();
    message.owner = (object.owner !== undefined && object.owner !== null)
      ? Player.fromPartial(object.owner)
      : undefined;
    message.ownerLinkMicId = object.ownerLinkMicId ?? "";
    return message;
  },
};

function createBaseListChangeContent(): ListChangeContent {
  return { listChangeType: 0, userList: undefined, linkedUserUiPositions: [], contentPos: [] };
}

export const ListChangeContent: MessageFns<ListChangeContent> = {
  encode(message: ListChangeContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.listChangeType !== 0) {
      writer.uint32(8).int32(message.listChangeType);
    }
    if (message.userList !== undefined) {
      AllListUser.encode(message.userList, writer.uint32(18).fork()).join();
    }
    for (const v of message.linkedUserUiPositions) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.contentPos) {
      ContentPosition.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListChangeContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChangeContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.listChangeType = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userList = AllListUser.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.linkedUserUiPositions.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contentPos.push(ContentPosition.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ListChangeContent>, I>>(base?: I): ListChangeContent {
    return ListChangeContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListChangeContent>, I>>(object: I): ListChangeContent {
    const message = createBaseListChangeContent();
    message.listChangeType = object.listChangeType ?? 0;
    message.userList = (object.userList !== undefined && object.userList !== null)
      ? AllListUser.fromPartial(object.userList)
      : undefined;
    message.linkedUserUiPositions = object.linkedUserUiPositions?.map((e) => e) || [];
    message.contentPos = object.contentPos?.map((e) => ContentPosition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseContentPosition(): ContentPosition {
  return { contentID: "", contentType: 0, pos: undefined, contentLinkmicID: "", startTimeNano: "0" };
}

export const ContentPosition: MessageFns<ContentPosition> = {
  encode(message: ContentPosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contentID !== "") {
      writer.uint32(10).string(message.contentID);
    }
    if (message.contentType !== 0) {
      writer.uint32(16).int32(message.contentType);
    }
    if (message.pos !== undefined) {
      MicPositionData.encode(message.pos, writer.uint32(26).fork()).join();
    }
    if (message.contentLinkmicID !== "") {
      writer.uint32(34).string(message.contentLinkmicID);
    }
    if (message.startTimeNano !== "0") {
      writer.uint32(40).int64(message.startTimeNano);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContentPosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContentPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contentID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.contentType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pos = MicPositionData.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contentLinkmicID = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.startTimeNano = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ContentPosition>, I>>(base?: I): ContentPosition {
    return ContentPosition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContentPosition>, I>>(object: I): ContentPosition {
    const message = createBaseContentPosition();
    message.contentID = object.contentID ?? "";
    message.contentType = object.contentType ?? 0;
    message.pos = (object.pos !== undefined && object.pos !== null)
      ? MicPositionData.fromPartial(object.pos)
      : undefined;
    message.contentLinkmicID = object.contentLinkmicID ?? "";
    message.startTimeNano = object.startTimeNano ?? "0";
    return message;
  },
};

function createBaseMicPositionData(): MicPositionData {
  return { type: 0, linkPosition: undefined };
}

export const MicPositionData: MessageFns<MicPositionData> = {
  encode(message: MicPositionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.linkPosition !== undefined) {
      LinkPosition.encode(message.linkPosition, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MicPositionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMicPositionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.linkPosition = LinkPosition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<MicPositionData>, I>>(base?: I): MicPositionData {
    return MicPositionData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MicPositionData>, I>>(object: I): MicPositionData {
    const message = createBaseMicPositionData();
    message.type = object.type ?? 0;
    message.linkPosition = (object.linkPosition !== undefined && object.linkPosition !== null)
      ? LinkPosition.fromPartial(object.linkPosition)
      : undefined;
    return message;
  },
};

function createBaseMultiLiveContent(): MultiLiveContent {
  return {
    applyBizContent: undefined,
    inviteBizContent: undefined,
    replyBizContent: undefined,
    permitBizContent: undefined,
    joinDirectBizContent: undefined,
    kickOutBizContent: undefined,
  };
}

export const MultiLiveContent: MessageFns<MultiLiveContent> = {
  encode(message: MultiLiveContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.applyBizContent !== undefined) {
      MultiLiveContent_ApplyBizContent.encode(message.applyBizContent, writer.uint32(10).fork()).join();
    }
    if (message.inviteBizContent !== undefined) {
      MultiLiveContent_InviteBizContent.encode(message.inviteBizContent, writer.uint32(18).fork()).join();
    }
    if (message.replyBizContent !== undefined) {
      MultiLiveContent_ReplyBizContent.encode(message.replyBizContent, writer.uint32(26).fork()).join();
    }
    if (message.permitBizContent !== undefined) {
      MultiLiveContent_PermitBizContent.encode(message.permitBizContent, writer.uint32(34).fork()).join();
    }
    if (message.joinDirectBizContent !== undefined) {
      MultiLiveContent_JoinDirectBizContent.encode(message.joinDirectBizContent, writer.uint32(42).fork()).join();
    }
    if (message.kickOutBizContent !== undefined) {
      MultiLiveContent_KickOutBizContent.encode(message.kickOutBizContent, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiLiveContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiLiveContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.applyBizContent = MultiLiveContent_ApplyBizContent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inviteBizContent = MultiLiveContent_InviteBizContent.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.replyBizContent = MultiLiveContent_ReplyBizContent.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.permitBizContent = MultiLiveContent_PermitBizContent.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.joinDirectBizContent = MultiLiveContent_JoinDirectBizContent.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.kickOutBizContent = MultiLiveContent_KickOutBizContent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<MultiLiveContent>, I>>(base?: I): MultiLiveContent {
    return MultiLiveContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiLiveContent>, I>>(object: I): MultiLiveContent {
    const message = createBaseMultiLiveContent();
    message.applyBizContent = (object.applyBizContent !== undefined && object.applyBizContent !== null)
      ? MultiLiveContent_ApplyBizContent.fromPartial(object.applyBizContent)
      : undefined;
    message.inviteBizContent = (object.inviteBizContent !== undefined && object.inviteBizContent !== null)
      ? MultiLiveContent_InviteBizContent.fromPartial(object.inviteBizContent)
      : undefined;
    message.replyBizContent = (object.replyBizContent !== undefined && object.replyBizContent !== null)
      ? MultiLiveContent_ReplyBizContent.fromPartial(object.replyBizContent)
      : undefined;
    message.permitBizContent = (object.permitBizContent !== undefined && object.permitBizContent !== null)
      ? MultiLiveContent_PermitBizContent.fromPartial(object.permitBizContent)
      : undefined;
    message.joinDirectBizContent = (object.joinDirectBizContent !== undefined && object.joinDirectBizContent !== null)
      ? MultiLiveContent_JoinDirectBizContent.fromPartial(object.joinDirectBizContent)
      : undefined;
    message.kickOutBizContent = (object.kickOutBizContent !== undefined && object.kickOutBizContent !== null)
      ? MultiLiveContent_KickOutBizContent.fromPartial(object.kickOutBizContent)
      : undefined;
    return message;
  },
};

function createBaseMultiLiveContent_ApplyBizContent(): MultiLiveContent_ApplyBizContent {
  return { user: undefined };
}

export const MultiLiveContent_ApplyBizContent: MessageFns<MultiLiveContent_ApplyBizContent> = {
  encode(message: MultiLiveContent_ApplyBizContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiLiveContent_ApplyBizContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiLiveContent_ApplyBizContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<MultiLiveContent_ApplyBizContent>, I>>(
    base?: I,
  ): MultiLiveContent_ApplyBizContent {
    return MultiLiveContent_ApplyBizContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiLiveContent_ApplyBizContent>, I>>(
    object: I,
  ): MultiLiveContent_ApplyBizContent {
    const message = createBaseMultiLiveContent_ApplyBizContent();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseMultiLiveContent_JoinDirectBizContent(): MultiLiveContent_JoinDirectBizContent {
  return { replyImMsgId: "0", outsideRoomInviteSource: 0 };
}

export const MultiLiveContent_JoinDirectBizContent: MessageFns<MultiLiveContent_JoinDirectBizContent> = {
  encode(message: MultiLiveContent_JoinDirectBizContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.replyImMsgId !== "0") {
      writer.uint32(8).int64(message.replyImMsgId);
    }
    if (message.outsideRoomInviteSource !== 0) {
      writer.uint32(16).int32(message.outsideRoomInviteSource);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiLiveContent_JoinDirectBizContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiLiveContent_JoinDirectBizContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.replyImMsgId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.outsideRoomInviteSource = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<MultiLiveContent_JoinDirectBizContent>, I>>(
    base?: I,
  ): MultiLiveContent_JoinDirectBizContent {
    return MultiLiveContent_JoinDirectBizContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiLiveContent_JoinDirectBizContent>, I>>(
    object: I,
  ): MultiLiveContent_JoinDirectBizContent {
    const message = createBaseMultiLiveContent_JoinDirectBizContent();
    message.replyImMsgId = object.replyImMsgId ?? "0";
    message.outsideRoomInviteSource = object.outsideRoomInviteSource ?? 0;
    return message;
  },
};

function createBaseMultiLiveContent_InviteBizContent(): MultiLiveContent_InviteBizContent {
  return {
    anchorSettingInfo: undefined,
    inviteSource: 0,
    operatorUserInfo: undefined,
    operatorLinkAdminType: 0,
    inviteeUserInfo: undefined,
    shareRevenueSetting: 0,
  };
}

export const MultiLiveContent_InviteBizContent: MessageFns<MultiLiveContent_InviteBizContent> = {
  encode(message: MultiLiveContent_InviteBizContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.anchorSettingInfo !== undefined) {
      MultiLiveAnchorPanelSettings.encode(message.anchorSettingInfo, writer.uint32(10).fork()).join();
    }
    if (message.inviteSource !== 0) {
      writer.uint32(16).int32(message.inviteSource);
    }
    if (message.operatorUserInfo !== undefined) {
      User.encode(message.operatorUserInfo, writer.uint32(26).fork()).join();
    }
    if (message.operatorLinkAdminType !== 0) {
      writer.uint32(32).int32(message.operatorLinkAdminType);
    }
    if (message.inviteeUserInfo !== undefined) {
      User.encode(message.inviteeUserInfo, writer.uint32(42).fork()).join();
    }
    if (message.shareRevenueSetting !== 0) {
      writer.uint32(48).int32(message.shareRevenueSetting);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiLiveContent_InviteBizContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiLiveContent_InviteBizContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.anchorSettingInfo = MultiLiveAnchorPanelSettings.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.inviteSource = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.operatorUserInfo = User.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.operatorLinkAdminType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.inviteeUserInfo = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.shareRevenueSetting = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<MultiLiveContent_InviteBizContent>, I>>(
    base?: I,
  ): MultiLiveContent_InviteBizContent {
    return MultiLiveContent_InviteBizContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiLiveContent_InviteBizContent>, I>>(
    object: I,
  ): MultiLiveContent_InviteBizContent {
    const message = createBaseMultiLiveContent_InviteBizContent();
    message.anchorSettingInfo = (object.anchorSettingInfo !== undefined && object.anchorSettingInfo !== null)
      ? MultiLiveAnchorPanelSettings.fromPartial(object.anchorSettingInfo)
      : undefined;
    message.inviteSource = object.inviteSource ?? 0;
    message.operatorUserInfo = (object.operatorUserInfo !== undefined && object.operatorUserInfo !== null)
      ? User.fromPartial(object.operatorUserInfo)
      : undefined;
    message.operatorLinkAdminType = object.operatorLinkAdminType ?? 0;
    message.inviteeUserInfo = (object.inviteeUserInfo !== undefined && object.inviteeUserInfo !== null)
      ? User.fromPartial(object.inviteeUserInfo)
      : undefined;
    message.shareRevenueSetting = object.shareRevenueSetting ?? 0;
    return message;
  },
};

function createBaseMultiLiveContent_ReplyBizContent(): MultiLiveContent_ReplyBizContent {
  return { linkType: 0, isTurnOffInvitation: 0, replyUserInfo: undefined };
}

export const MultiLiveContent_ReplyBizContent: MessageFns<MultiLiveContent_ReplyBizContent> = {
  encode(message: MultiLiveContent_ReplyBizContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.linkType !== 0) {
      writer.uint32(8).int32(message.linkType);
    }
    if (message.isTurnOffInvitation !== 0) {
      writer.uint32(16).int32(message.isTurnOffInvitation);
    }
    if (message.replyUserInfo !== undefined) {
      User.encode(message.replyUserInfo, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiLiveContent_ReplyBizContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiLiveContent_ReplyBizContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.linkType = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isTurnOffInvitation = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.replyUserInfo = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<MultiLiveContent_ReplyBizContent>, I>>(
    base?: I,
  ): MultiLiveContent_ReplyBizContent {
    return MultiLiveContent_ReplyBizContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiLiveContent_ReplyBizContent>, I>>(
    object: I,
  ): MultiLiveContent_ReplyBizContent {
    const message = createBaseMultiLiveContent_ReplyBizContent();
    message.linkType = object.linkType ?? 0;
    message.isTurnOffInvitation = object.isTurnOffInvitation ?? 0;
    message.replyUserInfo = (object.replyUserInfo !== undefined && object.replyUserInfo !== null)
      ? User.fromPartial(object.replyUserInfo)
      : undefined;
    return message;
  },
};

function createBaseMultiLiveContent_PermitBizContent(): MultiLiveContent_PermitBizContent {
  return {
    anchorSettingInfo: undefined,
    expireTimestamp: "0",
    operatorUserInfo: undefined,
    operatorLinkAdminType: 0,
    linkUserType: 0,
  };
}

export const MultiLiveContent_PermitBizContent: MessageFns<MultiLiveContent_PermitBizContent> = {
  encode(message: MultiLiveContent_PermitBizContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.anchorSettingInfo !== undefined) {
      MultiLiveAnchorPanelSettings.encode(message.anchorSettingInfo, writer.uint32(10).fork()).join();
    }
    if (message.expireTimestamp !== "0") {
      writer.uint32(16).int64(message.expireTimestamp);
    }
    if (message.operatorUserInfo !== undefined) {
      User.encode(message.operatorUserInfo, writer.uint32(26).fork()).join();
    }
    if (message.operatorLinkAdminType !== 0) {
      writer.uint32(32).int32(message.operatorLinkAdminType);
    }
    if (message.linkUserType !== 0) {
      writer.uint32(40).int32(message.linkUserType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiLiveContent_PermitBizContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiLiveContent_PermitBizContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.anchorSettingInfo = MultiLiveAnchorPanelSettings.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expireTimestamp = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.operatorUserInfo = User.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.operatorLinkAdminType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.linkUserType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<MultiLiveContent_PermitBizContent>, I>>(
    base?: I,
  ): MultiLiveContent_PermitBizContent {
    return MultiLiveContent_PermitBizContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiLiveContent_PermitBizContent>, I>>(
    object: I,
  ): MultiLiveContent_PermitBizContent {
    const message = createBaseMultiLiveContent_PermitBizContent();
    message.anchorSettingInfo = (object.anchorSettingInfo !== undefined && object.anchorSettingInfo !== null)
      ? MultiLiveAnchorPanelSettings.fromPartial(object.anchorSettingInfo)
      : undefined;
    message.expireTimestamp = object.expireTimestamp ?? "0";
    message.operatorUserInfo = (object.operatorUserInfo !== undefined && object.operatorUserInfo !== null)
      ? User.fromPartial(object.operatorUserInfo)
      : undefined;
    message.operatorLinkAdminType = object.operatorLinkAdminType ?? 0;
    message.linkUserType = object.linkUserType ?? 0;
    return message;
  },
};

function createBaseMultiLiveContent_KickOutBizContent(): MultiLiveContent_KickOutBizContent {
  return { operatorUserInfo: undefined, operatorLinkAdminType: 0, kickPlayerUserInfo: undefined };
}

export const MultiLiveContent_KickOutBizContent: MessageFns<MultiLiveContent_KickOutBizContent> = {
  encode(message: MultiLiveContent_KickOutBizContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operatorUserInfo !== undefined) {
      User.encode(message.operatorUserInfo, writer.uint32(10).fork()).join();
    }
    if (message.operatorLinkAdminType !== 0) {
      writer.uint32(16).int32(message.operatorLinkAdminType);
    }
    if (message.kickPlayerUserInfo !== undefined) {
      User.encode(message.kickPlayerUserInfo, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiLiveContent_KickOutBizContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiLiveContent_KickOutBizContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operatorUserInfo = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.operatorLinkAdminType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.kickPlayerUserInfo = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<MultiLiveContent_KickOutBizContent>, I>>(
    base?: I,
  ): MultiLiveContent_KickOutBizContent {
    return MultiLiveContent_KickOutBizContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiLiveContent_KickOutBizContent>, I>>(
    object: I,
  ): MultiLiveContent_KickOutBizContent {
    const message = createBaseMultiLiveContent_KickOutBizContent();
    message.operatorUserInfo = (object.operatorUserInfo !== undefined && object.operatorUserInfo !== null)
      ? User.fromPartial(object.operatorUserInfo)
      : undefined;
    message.operatorLinkAdminType = object.operatorLinkAdminType ?? 0;
    message.kickPlayerUserInfo = (object.kickPlayerUserInfo !== undefined && object.kickPlayerUserInfo !== null)
      ? User.fromPartial(object.kickPlayerUserInfo)
      : undefined;
    return message;
  },
};

function createBaseInviteContent(): InviteContent {
  return {
    invitor: undefined,
    inviteeRtcExtInfo: undefined,
    invitorLinkMicId: "",
    inviteeLinkMicId: "",
    isOwner: false,
    pos: undefined,
    dsl: undefined,
    invitee: undefined,
    operator: undefined,
  };
}

export const InviteContent: MessageFns<InviteContent> = {
  encode(message: InviteContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.invitor !== undefined) {
      Player.encode(message.invitor, writer.uint32(10).fork()).join();
    }
    if (message.inviteeRtcExtInfo !== undefined) {
      RTCExtraInfo.encode(message.inviteeRtcExtInfo, writer.uint32(18).fork()).join();
    }
    if (message.invitorLinkMicId !== "") {
      writer.uint32(26).string(message.invitorLinkMicId);
    }
    if (message.inviteeLinkMicId !== "") {
      writer.uint32(34).string(message.inviteeLinkMicId);
    }
    if (message.isOwner !== false) {
      writer.uint32(40).bool(message.isOwner);
    }
    if (message.pos !== undefined) {
      Position.encode(message.pos, writer.uint32(50).fork()).join();
    }
    if (message.dsl !== undefined) {
      DSLConfig.encode(message.dsl, writer.uint32(58).fork()).join();
    }
    if (message.invitee !== undefined) {
      User.encode(message.invitee, writer.uint32(66).fork()).join();
    }
    if (message.operator !== undefined) {
      User.encode(message.operator, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InviteContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInviteContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.invitor = Player.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inviteeRtcExtInfo = RTCExtraInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.invitorLinkMicId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.inviteeLinkMicId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isOwner = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.pos = Position.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.dsl = DSLConfig.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.invitee = User.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.operator = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<InviteContent>, I>>(base?: I): InviteContent {
    return InviteContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InviteContent>, I>>(object: I): InviteContent {
    const message = createBaseInviteContent();
    message.invitor = (object.invitor !== undefined && object.invitor !== null)
      ? Player.fromPartial(object.invitor)
      : undefined;
    message.inviteeRtcExtInfo = (object.inviteeRtcExtInfo !== undefined && object.inviteeRtcExtInfo !== null)
      ? RTCExtraInfo.fromPartial(object.inviteeRtcExtInfo)
      : undefined;
    message.invitorLinkMicId = object.invitorLinkMicId ?? "";
    message.inviteeLinkMicId = object.inviteeLinkMicId ?? "";
    message.isOwner = object.isOwner ?? false;
    message.pos = (object.pos !== undefined && object.pos !== null) ? Position.fromPartial(object.pos) : undefined;
    message.dsl = (object.dsl !== undefined && object.dsl !== null) ? DSLConfig.fromPartial(object.dsl) : undefined;
    message.invitee = (object.invitee !== undefined && object.invitee !== null)
      ? User.fromPartial(object.invitee)
      : undefined;
    message.operator = (object.operator !== undefined && object.operator !== null)
      ? User.fromPartial(object.operator)
      : undefined;
    return message;
  },
};

function createBaseApplyContent(): ApplyContent {
  return { applier: undefined, applierLinkMicId: "" };
}

export const ApplyContent: MessageFns<ApplyContent> = {
  encode(message: ApplyContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.applier !== undefined) {
      Player.encode(message.applier, writer.uint32(10).fork()).join();
    }
    if (message.applierLinkMicId !== "") {
      writer.uint32(18).string(message.applierLinkMicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplyContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplyContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.applier = Player.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.applierLinkMicId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ApplyContent>, I>>(base?: I): ApplyContent {
    return ApplyContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplyContent>, I>>(object: I): ApplyContent {
    const message = createBaseApplyContent();
    message.applier = (object.applier !== undefined && object.applier !== null)
      ? Player.fromPartial(object.applier)
      : undefined;
    message.applierLinkMicId = object.applierLinkMicId ?? "";
    return message;
  },
};

function createBasePermitApplyContent(): PermitApplyContent {
  return {
    permiter: undefined,
    permiterLinkMicId: "",
    applierPos: undefined,
    replyStatus: 0,
    dsl: undefined,
    applier: undefined,
    operator: undefined,
    applierLinkMicId: "",
  };
}

export const PermitApplyContent: MessageFns<PermitApplyContent> = {
  encode(message: PermitApplyContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.permiter !== undefined) {
      Player.encode(message.permiter, writer.uint32(10).fork()).join();
    }
    if (message.permiterLinkMicId !== "") {
      writer.uint32(18).string(message.permiterLinkMicId);
    }
    if (message.applierPos !== undefined) {
      Position.encode(message.applierPos, writer.uint32(26).fork()).join();
    }
    if (message.replyStatus !== 0) {
      writer.uint32(32).int32(message.replyStatus);
    }
    if (message.dsl !== undefined) {
      DSLConfig.encode(message.dsl, writer.uint32(42).fork()).join();
    }
    if (message.applier !== undefined) {
      User.encode(message.applier, writer.uint32(50).fork()).join();
    }
    if (message.operator !== undefined) {
      User.encode(message.operator, writer.uint32(58).fork()).join();
    }
    if (message.applierLinkMicId !== "") {
      writer.uint32(66).string(message.applierLinkMicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PermitApplyContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermitApplyContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.permiter = Player.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.permiterLinkMicId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.applierPos = Position.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.replyStatus = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dsl = DSLConfig.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.applier = User.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.operator = User.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.applierLinkMicId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<PermitApplyContent>, I>>(base?: I): PermitApplyContent {
    return PermitApplyContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PermitApplyContent>, I>>(object: I): PermitApplyContent {
    const message = createBasePermitApplyContent();
    message.permiter = (object.permiter !== undefined && object.permiter !== null)
      ? Player.fromPartial(object.permiter)
      : undefined;
    message.permiterLinkMicId = object.permiterLinkMicId ?? "";
    message.applierPos = (object.applierPos !== undefined && object.applierPos !== null)
      ? Position.fromPartial(object.applierPos)
      : undefined;
    message.replyStatus = object.replyStatus ?? 0;
    message.dsl = (object.dsl !== undefined && object.dsl !== null) ? DSLConfig.fromPartial(object.dsl) : undefined;
    message.applier = (object.applier !== undefined && object.applier !== null)
      ? User.fromPartial(object.applier)
      : undefined;
    message.operator = (object.operator !== undefined && object.operator !== null)
      ? User.fromPartial(object.operator)
      : undefined;
    message.applierLinkMicId = object.applierLinkMicId ?? "";
    return message;
  },
};

function createBaseReplyInviteContent(): ReplyInviteContent {
  return {
    invitee: undefined,
    replyStatus: 0,
    inviteeLinkMicId: "",
    inviteePos: undefined,
    inviteOperatorUser: undefined,
    linkedUserUiPositions: [],
    uiPos: [],
  };
}

export const ReplyInviteContent: MessageFns<ReplyInviteContent> = {
  encode(message: ReplyInviteContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.invitee !== undefined) {
      Player.encode(message.invitee, writer.uint32(10).fork()).join();
    }
    if (message.replyStatus !== 0) {
      writer.uint32(16).int32(message.replyStatus);
    }
    if (message.inviteeLinkMicId !== "") {
      writer.uint32(26).string(message.inviteeLinkMicId);
    }
    if (message.inviteePos !== undefined) {
      Position.encode(message.inviteePos, writer.uint32(34).fork()).join();
    }
    if (message.inviteOperatorUser !== undefined) {
      Player.encode(message.inviteOperatorUser, writer.uint32(42).fork()).join();
    }
    for (const v of message.linkedUserUiPositions) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.uiPos) {
      PosIdentity.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplyInviteContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplyInviteContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.invitee = Player.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.replyStatus = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inviteeLinkMicId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.inviteePos = Position.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.inviteOperatorUser = Player.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.linkedUserUiPositions.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.uiPos.push(PosIdentity.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ReplyInviteContent>, I>>(base?: I): ReplyInviteContent {
    return ReplyInviteContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReplyInviteContent>, I>>(object: I): ReplyInviteContent {
    const message = createBaseReplyInviteContent();
    message.invitee = (object.invitee !== undefined && object.invitee !== null)
      ? Player.fromPartial(object.invitee)
      : undefined;
    message.replyStatus = object.replyStatus ?? 0;
    message.inviteeLinkMicId = object.inviteeLinkMicId ?? "";
    message.inviteePos = (object.inviteePos !== undefined && object.inviteePos !== null)
      ? Position.fromPartial(object.inviteePos)
      : undefined;
    message.inviteOperatorUser = (object.inviteOperatorUser !== undefined && object.inviteOperatorUser !== null)
      ? Player.fromPartial(object.inviteOperatorUser)
      : undefined;
    message.linkedUserUiPositions = object.linkedUserUiPositions?.map((e) => e) || [];
    message.uiPos = object.uiPos?.map((e) => PosIdentity.fromPartial(e)) || [];
    return message;
  },
};

function createBaseKickOutContent(): KickOutContent {
  return { offliner: undefined, kickoutReason: 0, linkedUserUiPositions: [], uiPos: [] };
}

export const KickOutContent: MessageFns<KickOutContent> = {
  encode(message: KickOutContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offliner !== undefined) {
      Player.encode(message.offliner, writer.uint32(10).fork()).join();
    }
    if (message.kickoutReason !== 0) {
      writer.uint32(16).int32(message.kickoutReason);
    }
    for (const v of message.linkedUserUiPositions) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.uiPos) {
      PosIdentity.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KickOutContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKickOutContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.offliner = Player.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.kickoutReason = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.linkedUserUiPositions.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.uiPos.push(PosIdentity.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<KickOutContent>, I>>(base?: I): KickOutContent {
    return KickOutContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KickOutContent>, I>>(object: I): KickOutContent {
    const message = createBaseKickOutContent();
    message.offliner = (object.offliner !== undefined && object.offliner !== null)
      ? Player.fromPartial(object.offliner)
      : undefined;
    message.kickoutReason = object.kickoutReason ?? 0;
    message.linkedUserUiPositions = object.linkedUserUiPositions?.map((e) => e) || [];
    message.uiPos = object.uiPos?.map((e) => PosIdentity.fromPartial(e)) || [];
    return message;
  },
};

function createBasePosIdentity(): PosIdentity {
  return { type: 0, value: "" };
}

export const PosIdentity: MessageFns<PosIdentity> = {
  encode(message: PosIdentity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PosIdentity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePosIdentity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<PosIdentity>, I>>(base?: I): PosIdentity {
    return PosIdentity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PosIdentity>, I>>(object: I): PosIdentity {
    const message = createBasePosIdentity();
    message.type = object.type ?? 0;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCancelApplyContent(): CancelApplyContent {
  return { applier: undefined, applierLinkMicId: "" };
}

export const CancelApplyContent: MessageFns<CancelApplyContent> = {
  encode(message: CancelApplyContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.applier !== undefined) {
      Player.encode(message.applier, writer.uint32(10).fork()).join();
    }
    if (message.applierLinkMicId !== "") {
      writer.uint32(18).string(message.applierLinkMicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelApplyContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelApplyContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.applier = Player.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.applierLinkMicId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<CancelApplyContent>, I>>(base?: I): CancelApplyContent {
    return CancelApplyContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelApplyContent>, I>>(object: I): CancelApplyContent {
    const message = createBaseCancelApplyContent();
    message.applier = (object.applier !== undefined && object.applier !== null)
      ? Player.fromPartial(object.applier)
      : undefined;
    message.applierLinkMicId = object.applierLinkMicId ?? "";
    return message;
  },
};

function createBaseCancelInviteContent(): CancelInviteContent {
  return { invitor: undefined, invitorLinkMicId: "", inviteeLinkMicId: "", inviteSeqId: "0", invitee: undefined };
}

export const CancelInviteContent: MessageFns<CancelInviteContent> = {
  encode(message: CancelInviteContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.invitor !== undefined) {
      Player.encode(message.invitor, writer.uint32(10).fork()).join();
    }
    if (message.invitorLinkMicId !== "") {
      writer.uint32(18).string(message.invitorLinkMicId);
    }
    if (message.inviteeLinkMicId !== "") {
      writer.uint32(26).string(message.inviteeLinkMicId);
    }
    if (message.inviteSeqId !== "0") {
      writer.uint32(32).int64(message.inviteSeqId);
    }
    if (message.invitee !== undefined) {
      Player.encode(message.invitee, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelInviteContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelInviteContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.invitor = Player.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.invitorLinkMicId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inviteeLinkMicId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.inviteSeqId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.invitee = Player.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<CancelInviteContent>, I>>(base?: I): CancelInviteContent {
    return CancelInviteContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelInviteContent>, I>>(object: I): CancelInviteContent {
    const message = createBaseCancelInviteContent();
    message.invitor = (object.invitor !== undefined && object.invitor !== null)
      ? Player.fromPartial(object.invitor)
      : undefined;
    message.invitorLinkMicId = object.invitorLinkMicId ?? "";
    message.inviteeLinkMicId = object.inviteeLinkMicId ?? "";
    message.inviteSeqId = object.inviteSeqId ?? "0";
    message.invitee = (object.invitee !== undefined && object.invitee !== null)
      ? Player.fromPartial(object.invitee)
      : undefined;
    return message;
  },
};

function createBaseLeaveContent(): LeaveContent {
  return { leaver: undefined, leaveReason: "0", linkedUserUiPositions: [], uiPos: [] };
}

export const LeaveContent: MessageFns<LeaveContent> = {
  encode(message: LeaveContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leaver !== undefined) {
      Player.encode(message.leaver, writer.uint32(10).fork()).join();
    }
    if (message.leaveReason !== "0") {
      writer.uint32(16).int64(message.leaveReason);
    }
    for (const v of message.linkedUserUiPositions) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.uiPos) {
      PosIdentity.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeaveContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaveContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leaver = Player.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.leaveReason = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.linkedUserUiPositions.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.uiPos.push(PosIdentity.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LeaveContent>, I>>(base?: I): LeaveContent {
    return LeaveContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LeaveContent>, I>>(object: I): LeaveContent {
    const message = createBaseLeaveContent();
    message.leaver = (object.leaver !== undefined && object.leaver !== null)
      ? Player.fromPartial(object.leaver)
      : undefined;
    message.leaveReason = object.leaveReason ?? "0";
    message.linkedUserUiPositions = object.linkedUserUiPositions?.map((e) => e) || [];
    message.uiPos = object.uiPos?.map((e) => PosIdentity.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFinishChannelContent(): FinishChannelContent {
  return { owner: undefined, finishReason: "0" };
}

export const FinishChannelContent: MessageFns<FinishChannelContent> = {
  encode(message: FinishChannelContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== undefined) {
      Player.encode(message.owner, writer.uint32(10).fork()).join();
    }
    if (message.finishReason !== "0") {
      writer.uint32(16).int64(message.finishReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinishChannelContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishChannelContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = Player.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.finishReason = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<FinishChannelContent>, I>>(base?: I): FinishChannelContent {
    return FinishChannelContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FinishChannelContent>, I>>(object: I): FinishChannelContent {
    const message = createBaseFinishChannelContent();
    message.owner = (object.owner !== undefined && object.owner !== null)
      ? Player.fromPartial(object.owner)
      : undefined;
    message.finishReason = object.finishReason ?? "0";
    return message;
  },
};

function createBaseJoinDirectContent(): JoinDirectContent {
  return { joiner: undefined, allUsers: undefined };
}

export const JoinDirectContent: MessageFns<JoinDirectContent> = {
  encode(message: JoinDirectContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.joiner !== undefined) {
      LinkLayerListUser.encode(message.joiner, writer.uint32(10).fork()).join();
    }
    if (message.allUsers !== undefined) {
      AllListUser.encode(message.allUsers, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoinDirectContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinDirectContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.joiner = LinkLayerListUser.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allUsers = AllListUser.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<JoinDirectContent>, I>>(base?: I): JoinDirectContent {
    return JoinDirectContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JoinDirectContent>, I>>(object: I): JoinDirectContent {
    const message = createBaseJoinDirectContent();
    message.joiner = (object.joiner !== undefined && object.joiner !== null)
      ? LinkLayerListUser.fromPartial(object.joiner)
      : undefined;
    message.allUsers = (object.allUsers !== undefined && object.allUsers !== null)
      ? AllListUser.fromPartial(object.allUsers)
      : undefined;
    return message;
  },
};

function createBaseLeaveJoinGroupContent(): LeaveJoinGroupContent {
  return { operator: undefined, groupChannelId: "0", leaveSource: "", linkedUserUiPositions: [] };
}

export const LeaveJoinGroupContent: MessageFns<LeaveJoinGroupContent> = {
  encode(message: LeaveJoinGroupContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operator !== undefined) {
      GroupPlayer.encode(message.operator, writer.uint32(10).fork()).join();
    }
    if (message.groupChannelId !== "0") {
      writer.uint32(16).int64(message.groupChannelId);
    }
    if (message.leaveSource !== "") {
      writer.uint32(26).string(message.leaveSource);
    }
    for (const v of message.linkedUserUiPositions) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeaveJoinGroupContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaveJoinGroupContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operator = GroupPlayer.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.groupChannelId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.leaveSource = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.linkedUserUiPositions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LeaveJoinGroupContent>, I>>(base?: I): LeaveJoinGroupContent {
    return LeaveJoinGroupContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LeaveJoinGroupContent>, I>>(object: I): LeaveJoinGroupContent {
    const message = createBaseLeaveJoinGroupContent();
    message.operator = (object.operator !== undefined && object.operator !== null)
      ? GroupPlayer.fromPartial(object.operator)
      : undefined;
    message.groupChannelId = object.groupChannelId ?? "0";
    message.leaveSource = object.leaveSource ?? "";
    message.linkedUserUiPositions = object.linkedUserUiPositions?.map((e) => e) || [];
    return message;
  },
};

function createBasePermitJoinGroupContent(): PermitJoinGroupContent {
  return {
    approver: undefined,
    agreeStatus: 0,
    type: 0,
    groupExtInfoList: [],
    groupUser: undefined,
    migrationDetails: undefined,
    linkedUserUiPositions: [],
  };
}

export const PermitJoinGroupContent: MessageFns<PermitJoinGroupContent> = {
  encode(message: PermitJoinGroupContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.approver !== undefined) {
      GroupPlayer.encode(message.approver, writer.uint32(10).fork()).join();
    }
    if (message.agreeStatus !== 0) {
      writer.uint32(16).int32(message.agreeStatus);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    for (const v of message.groupExtInfoList) {
      RTCExtraInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.groupUser !== undefined) {
      GroupChannelAllUser.encode(message.groupUser, writer.uint32(42).fork()).join();
    }
    if (message.migrationDetails !== undefined) {
      MigrationDetails.encode(message.migrationDetails, writer.uint32(50).fork()).join();
    }
    for (const v of message.linkedUserUiPositions) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PermitJoinGroupContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermitJoinGroupContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.approver = GroupPlayer.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.agreeStatus = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.groupExtInfoList.push(RTCExtraInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.groupUser = GroupChannelAllUser.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.migrationDetails = MigrationDetails.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.linkedUserUiPositions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<PermitJoinGroupContent>, I>>(base?: I): PermitJoinGroupContent {
    return PermitJoinGroupContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PermitJoinGroupContent>, I>>(object: I): PermitJoinGroupContent {
    const message = createBasePermitJoinGroupContent();
    message.approver = (object.approver !== undefined && object.approver !== null)
      ? GroupPlayer.fromPartial(object.approver)
      : undefined;
    message.agreeStatus = object.agreeStatus ?? 0;
    message.type = object.type ?? 0;
    message.groupExtInfoList = object.groupExtInfoList?.map((e) => RTCExtraInfo.fromPartial(e)) || [];
    message.groupUser = (object.groupUser !== undefined && object.groupUser !== null)
      ? GroupChannelAllUser.fromPartial(object.groupUser)
      : undefined;
    message.migrationDetails = (object.migrationDetails !== undefined && object.migrationDetails !== null)
      ? MigrationDetails.fromPartial(object.migrationDetails)
      : undefined;
    message.linkedUserUiPositions = object.linkedUserUiPositions?.map((e) => e) || [];
    return message;
  },
};

function createBaseMigrationDetails(): MigrationDetails {
  return { isMigrate: false, sourceGroupChannelId: "0", targetGroupChannelId: "0" };
}

export const MigrationDetails: MessageFns<MigrationDetails> = {
  encode(message: MigrationDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isMigrate !== false) {
      writer.uint32(8).bool(message.isMigrate);
    }
    if (message.sourceGroupChannelId !== "0") {
      writer.uint32(16).int64(message.sourceGroupChannelId);
    }
    if (message.targetGroupChannelId !== "0") {
      writer.uint32(24).int64(message.targetGroupChannelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MigrationDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigrationDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isMigrate = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sourceGroupChannelId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.targetGroupChannelId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<MigrationDetails>, I>>(base?: I): MigrationDetails {
    return MigrationDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MigrationDetails>, I>>(object: I): MigrationDetails {
    const message = createBaseMigrationDetails();
    message.isMigrate = object.isMigrate ?? false;
    message.sourceGroupChannelId = object.sourceGroupChannelId ?? "0";
    message.targetGroupChannelId = object.targetGroupChannelId ?? "0";
    return message;
  },
};

function createBaseCancelJoinGroupContent(): CancelJoinGroupContent {
  return { leaverList: [], operator: undefined, type: 0, groupUser: undefined };
}

export const CancelJoinGroupContent: MessageFns<CancelJoinGroupContent> = {
  encode(message: CancelJoinGroupContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.leaverList) {
      GroupPlayer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.operator !== undefined) {
      GroupPlayer.encode(message.operator, writer.uint32(18).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.groupUser !== undefined) {
      GroupChannelAllUser.encode(message.groupUser, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelJoinGroupContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelJoinGroupContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leaverList.push(GroupPlayer.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.operator = GroupPlayer.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.groupUser = GroupChannelAllUser.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<CancelJoinGroupContent>, I>>(base?: I): CancelJoinGroupContent {
    return CancelJoinGroupContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelJoinGroupContent>, I>>(object: I): CancelJoinGroupContent {
    const message = createBaseCancelJoinGroupContent();
    message.leaverList = object.leaverList?.map((e) => GroupPlayer.fromPartial(e)) || [];
    message.operator = (object.operator !== undefined && object.operator !== null)
      ? GroupPlayer.fromPartial(object.operator)
      : undefined;
    message.type = object.type ?? 0;
    message.groupUser = (object.groupUser !== undefined && object.groupUser !== null)
      ? GroupChannelAllUser.fromPartial(object.groupUser)
      : undefined;
    return message;
  },
};

function createBaseP2PGroupChangeContent(): P2PGroupChangeContent {
  return { groupExtInfoList: [], groupUser: undefined, migrationDetails: undefined, contentPos: [] };
}

export const P2PGroupChangeContent: MessageFns<P2PGroupChangeContent> = {
  encode(message: P2PGroupChangeContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.groupExtInfoList) {
      RTCExtraInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.groupUser !== undefined) {
      GroupChannelAllUser.encode(message.groupUser, writer.uint32(18).fork()).join();
    }
    if (message.migrationDetails !== undefined) {
      MigrationDetails.encode(message.migrationDetails, writer.uint32(26).fork()).join();
    }
    for (const v of message.contentPos) {
      ContentPosition.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): P2PGroupChangeContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseP2PGroupChangeContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupExtInfoList.push(RTCExtraInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupUser = GroupChannelAllUser.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.migrationDetails = MigrationDetails.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contentPos.push(ContentPosition.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<P2PGroupChangeContent>, I>>(base?: I): P2PGroupChangeContent {
    return P2PGroupChangeContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<P2PGroupChangeContent>, I>>(object: I): P2PGroupChangeContent {
    const message = createBaseP2PGroupChangeContent();
    message.groupExtInfoList = object.groupExtInfoList?.map((e) => RTCExtraInfo.fromPartial(e)) || [];
    message.groupUser = (object.groupUser !== undefined && object.groupUser !== null)
      ? GroupChannelAllUser.fromPartial(object.groupUser)
      : undefined;
    message.migrationDetails = (object.migrationDetails !== undefined && object.migrationDetails !== null)
      ? MigrationDetails.fromPartial(object.migrationDetails)
      : undefined;
    message.contentPos = object.contentPos?.map((e) => ContentPosition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGroupChangeContent(): GroupChangeContent {
  return { groupUser: undefined, linkedUserUiPositions: [] };
}

export const GroupChangeContent: MessageFns<GroupChangeContent> = {
  encode(message: GroupChangeContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupUser !== undefined) {
      GroupChannelAllUser.encode(message.groupUser, writer.uint32(10).fork()).join();
    }
    for (const v of message.linkedUserUiPositions) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupChangeContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupChangeContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupUser = GroupChannelAllUser.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.linkedUserUiPositions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<GroupChangeContent>, I>>(base?: I): GroupChangeContent {
    return GroupChangeContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupChangeContent>, I>>(object: I): GroupChangeContent {
    const message = createBaseGroupChangeContent();
    message.groupUser = (object.groupUser !== undefined && object.groupUser !== null)
      ? GroupChannelAllUser.fromPartial(object.groupUser)
      : undefined;
    message.linkedUserUiPositions = object.linkedUserUiPositions?.map((e) => e) || [];
    return message;
  },
};

function createBaseBusinessContent(): BusinessContent {
  return { overLength: "0", multiLiveContent: undefined, cohostContent: undefined };
}

export const BusinessContent: MessageFns<BusinessContent> = {
  encode(message: BusinessContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.overLength !== "0") {
      writer.uint32(8).int64(message.overLength);
    }
    if (message.multiLiveContent !== undefined) {
      MultiLiveContent.encode(message.multiLiveContent, writer.uint32(802).fork()).join();
    }
    if (message.cohostContent !== undefined) {
      BusinessContent_CohostContent.encode(message.cohostContent, writer.uint32(1602).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.overLength = reader.int64().toString();
          continue;
        }
        case 100: {
          if (tag !== 802) {
            break;
          }

          message.multiLiveContent = MultiLiveContent.decode(reader, reader.uint32());
          continue;
        }
        case 200: {
          if (tag !== 1602) {
            break;
          }

          message.cohostContent = BusinessContent_CohostContent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BusinessContent>, I>>(base?: I): BusinessContent {
    return BusinessContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessContent>, I>>(object: I): BusinessContent {
    const message = createBaseBusinessContent();
    message.overLength = object.overLength ?? "0";
    message.multiLiveContent = (object.multiLiveContent !== undefined && object.multiLiveContent !== null)
      ? MultiLiveContent.fromPartial(object.multiLiveContent)
      : undefined;
    message.cohostContent = (object.cohostContent !== undefined && object.cohostContent !== null)
      ? BusinessContent_CohostContent.fromPartial(object.cohostContent)
      : undefined;
    return message;
  },
};

function createBaseBusinessContent_CohostContent(): BusinessContent_CohostContent {
  return { joinGroupBizContent: undefined, permitJoinGroupBizContent: undefined, listChangeBizContent: undefined };
}

export const BusinessContent_CohostContent: MessageFns<BusinessContent_CohostContent> = {
  encode(message: BusinessContent_CohostContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.joinGroupBizContent !== undefined) {
      BusinessContent_JoinGroupBizContent.encode(message.joinGroupBizContent, writer.uint32(10).fork()).join();
    }
    if (message.permitJoinGroupBizContent !== undefined) {
      BusinessContent_PermitJoinGroupBizContent.encode(message.permitJoinGroupBizContent, writer.uint32(18).fork())
        .join();
    }
    if (message.listChangeBizContent !== undefined) {
      BusinessContent_ListChangeBizContent.encode(message.listChangeBizContent, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_CohostContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_CohostContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.joinGroupBizContent = BusinessContent_JoinGroupBizContent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.permitJoinGroupBizContent = BusinessContent_PermitJoinGroupBizContent.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.listChangeBizContent = BusinessContent_ListChangeBizContent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BusinessContent_CohostContent>, I>>(base?: I): BusinessContent_CohostContent {
    return BusinessContent_CohostContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessContent_CohostContent>, I>>(
    object: I,
  ): BusinessContent_CohostContent {
    const message = createBaseBusinessContent_CohostContent();
    message.joinGroupBizContent = (object.joinGroupBizContent !== undefined && object.joinGroupBizContent !== null)
      ? BusinessContent_JoinGroupBizContent.fromPartial(object.joinGroupBizContent)
      : undefined;
    message.permitJoinGroupBizContent =
      (object.permitJoinGroupBizContent !== undefined && object.permitJoinGroupBizContent !== null)
        ? BusinessContent_PermitJoinGroupBizContent.fromPartial(object.permitJoinGroupBizContent)
        : undefined;
    message.listChangeBizContent = (object.listChangeBizContent !== undefined && object.listChangeBizContent !== null)
      ? BusinessContent_ListChangeBizContent.fromPartial(object.listChangeBizContent)
      : undefined;
    return message;
  },
};

function createBaseBusinessContent_PermitJoinGroupBizContent(): BusinessContent_PermitJoinGroupBizContent {
  return { replyStatus: 0, sourceType: 0 };
}

export const BusinessContent_PermitJoinGroupBizContent: MessageFns<BusinessContent_PermitJoinGroupBizContent> = {
  encode(message: BusinessContent_PermitJoinGroupBizContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.replyStatus !== 0) {
      writer.uint32(8).int32(message.replyStatus);
    }
    if (message.sourceType !== 0) {
      writer.uint32(16).int32(message.sourceType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_PermitJoinGroupBizContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_PermitJoinGroupBizContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.replyStatus = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sourceType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BusinessContent_PermitJoinGroupBizContent>, I>>(
    base?: I,
  ): BusinessContent_PermitJoinGroupBizContent {
    return BusinessContent_PermitJoinGroupBizContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessContent_PermitJoinGroupBizContent>, I>>(
    object: I,
  ): BusinessContent_PermitJoinGroupBizContent {
    const message = createBaseBusinessContent_PermitJoinGroupBizContent();
    message.replyStatus = object.replyStatus ?? 0;
    message.sourceType = object.sourceType ?? 0;
    return message;
  },
};

function createBaseBusinessContent_ListChangeBizContent(): BusinessContent_ListChangeBizContent {
  return { userInfos: {}, waitingUsers: [] };
}

export const BusinessContent_ListChangeBizContent: MessageFns<BusinessContent_ListChangeBizContent> = {
  encode(message: BusinessContent_ListChangeBizContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.userInfos).forEach(([key, value]) => {
      BusinessContent_ListChangeBizContent_UserInfosEntry.encode({ key: key as any, value }, writer.uint32(10).fork())
        .join();
    });
    for (const v of message.waitingUsers) {
      BusinessContent_ListChangeBizContent_VirtualWaitingUser.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_ListChangeBizContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_ListChangeBizContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = BusinessContent_ListChangeBizContent_UserInfosEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.userInfos[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.waitingUsers.push(
            BusinessContent_ListChangeBizContent_VirtualWaitingUser.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BusinessContent_ListChangeBizContent>, I>>(
    base?: I,
  ): BusinessContent_ListChangeBizContent {
    return BusinessContent_ListChangeBizContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessContent_ListChangeBizContent>, I>>(
    object: I,
  ): BusinessContent_ListChangeBizContent {
    const message = createBaseBusinessContent_ListChangeBizContent();
    message.userInfos = Object.entries(object.userInfos ?? {}).reduce<
      { [key: string]: BusinessContent_CohostUserInfo }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = BusinessContent_CohostUserInfo.fromPartial(value);
      }
      return acc;
    }, {});
    message.waitingUsers =
      object.waitingUsers?.map((e) => BusinessContent_ListChangeBizContent_VirtualWaitingUser.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBusinessContent_ListChangeBizContent_UserInfosEntry(): BusinessContent_ListChangeBizContent_UserInfosEntry {
  return { key: "0", value: undefined };
}

export const BusinessContent_ListChangeBizContent_UserInfosEntry: MessageFns<
  BusinessContent_ListChangeBizContent_UserInfosEntry
> = {
  encode(
    message: BusinessContent_ListChangeBizContent_UserInfosEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== undefined) {
      BusinessContent_CohostUserInfo.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_ListChangeBizContent_UserInfosEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_ListChangeBizContent_UserInfosEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = BusinessContent_CohostUserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BusinessContent_ListChangeBizContent_UserInfosEntry>, I>>(
    base?: I,
  ): BusinessContent_ListChangeBizContent_UserInfosEntry {
    return BusinessContent_ListChangeBizContent_UserInfosEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessContent_ListChangeBizContent_UserInfosEntry>, I>>(
    object: I,
  ): BusinessContent_ListChangeBizContent_UserInfosEntry {
    const message = createBaseBusinessContent_ListChangeBizContent_UserInfosEntry();
    message.key = object.key ?? "0";
    message.value = (object.value !== undefined && object.value !== null)
      ? BusinessContent_CohostUserInfo.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseBusinessContent_ListChangeBizContent_VirtualWaitingUser(): BusinessContent_ListChangeBizContent_VirtualWaitingUser {
  return { userId: "0", timestamp: "0", avatars: [] };
}

export const BusinessContent_ListChangeBizContent_VirtualWaitingUser: MessageFns<
  BusinessContent_ListChangeBizContent_VirtualWaitingUser
> = {
  encode(
    message: BusinessContent_ListChangeBizContent_VirtualWaitingUser,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.timestamp !== "0") {
      writer.uint32(16).int64(message.timestamp);
    }
    for (const v of message.avatars) {
      Image.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_ListChangeBizContent_VirtualWaitingUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_ListChangeBizContent_VirtualWaitingUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.avatars.push(Image.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BusinessContent_ListChangeBizContent_VirtualWaitingUser>, I>>(
    base?: I,
  ): BusinessContent_ListChangeBizContent_VirtualWaitingUser {
    return BusinessContent_ListChangeBizContent_VirtualWaitingUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessContent_ListChangeBizContent_VirtualWaitingUser>, I>>(
    object: I,
  ): BusinessContent_ListChangeBizContent_VirtualWaitingUser {
    const message = createBaseBusinessContent_ListChangeBizContent_VirtualWaitingUser();
    message.userId = object.userId ?? "0";
    message.timestamp = object.timestamp ?? "0";
    message.avatars = object.avatars?.map((e) => Image.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBusinessContent_CohostUserInfo(): BusinessContent_CohostUserInfo {
  return {
    permissionType: "0",
    sourceType: 0,
    isLowVersion: false,
    bestTeammateUid: "0",
    hasTopicPerm: false,
    streamConfig: undefined,
    inDifferentInviteTypeControlGroup: false,
    nickname: "",
    displayId: "",
    avatarThumb: undefined,
    followStatus: "0",
    userIdStr: "",
  };
}

export const BusinessContent_CohostUserInfo: MessageFns<BusinessContent_CohostUserInfo> = {
  encode(message: BusinessContent_CohostUserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.permissionType !== "0") {
      writer.uint32(8).int64(message.permissionType);
    }
    if (message.sourceType !== 0) {
      writer.uint32(16).int32(message.sourceType);
    }
    if (message.isLowVersion !== false) {
      writer.uint32(24).bool(message.isLowVersion);
    }
    if (message.bestTeammateUid !== "0") {
      writer.uint32(32).int64(message.bestTeammateUid);
    }
    if (message.hasTopicPerm !== false) {
      writer.uint32(40).bool(message.hasTopicPerm);
    }
    if (message.streamConfig !== undefined) {
      BusinessContent_CohostUserInfo_CohostStreamConfig.encode(message.streamConfig, writer.uint32(50).fork()).join();
    }
    if (message.inDifferentInviteTypeControlGroup !== false) {
      writer.uint32(56).bool(message.inDifferentInviteTypeControlGroup);
    }
    if (message.nickname !== "") {
      writer.uint32(90).string(message.nickname);
    }
    if (message.displayId !== "") {
      writer.uint32(98).string(message.displayId);
    }
    if (message.avatarThumb !== undefined) {
      Image.encode(message.avatarThumb, writer.uint32(106).fork()).join();
    }
    if (message.followStatus !== "0") {
      writer.uint32(112).int64(message.followStatus);
    }
    if (message.userIdStr !== "") {
      writer.uint32(122).string(message.userIdStr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_CohostUserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_CohostUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.permissionType = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sourceType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isLowVersion = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.bestTeammateUid = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.hasTopicPerm = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.streamConfig = BusinessContent_CohostUserInfo_CohostStreamConfig.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.inDifferentInviteTypeControlGroup = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.displayId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.avatarThumb = Image.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.followStatus = reader.int64().toString();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.userIdStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BusinessContent_CohostUserInfo>, I>>(base?: I): BusinessContent_CohostUserInfo {
    return BusinessContent_CohostUserInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessContent_CohostUserInfo>, I>>(
    object: I,
  ): BusinessContent_CohostUserInfo {
    const message = createBaseBusinessContent_CohostUserInfo();
    message.permissionType = object.permissionType ?? "0";
    message.sourceType = object.sourceType ?? 0;
    message.isLowVersion = object.isLowVersion ?? false;
    message.bestTeammateUid = object.bestTeammateUid ?? "0";
    message.hasTopicPerm = object.hasTopicPerm ?? false;
    message.streamConfig = (object.streamConfig !== undefined && object.streamConfig !== null)
      ? BusinessContent_CohostUserInfo_CohostStreamConfig.fromPartial(object.streamConfig)
      : undefined;
    message.inDifferentInviteTypeControlGroup = object.inDifferentInviteTypeControlGroup ?? false;
    message.nickname = object.nickname ?? "";
    message.displayId = object.displayId ?? "";
    message.avatarThumb = (object.avatarThumb !== undefined && object.avatarThumb !== null)
      ? Image.fromPartial(object.avatarThumb)
      : undefined;
    message.followStatus = object.followStatus ?? "0";
    message.userIdStr = object.userIdStr ?? "";
    return message;
  },
};

function createBaseBusinessContent_CohostUserInfo_CohostStreamConfig(): BusinessContent_CohostUserInfo_CohostStreamConfig {
  return { screenShareStreamId: "" };
}

export const BusinessContent_CohostUserInfo_CohostStreamConfig: MessageFns<
  BusinessContent_CohostUserInfo_CohostStreamConfig
> = {
  encode(
    message: BusinessContent_CohostUserInfo_CohostStreamConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.screenShareStreamId !== "") {
      writer.uint32(10).string(message.screenShareStreamId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_CohostUserInfo_CohostStreamConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_CohostUserInfo_CohostStreamConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.screenShareStreamId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BusinessContent_CohostUserInfo_CohostStreamConfig>, I>>(
    base?: I,
  ): BusinessContent_CohostUserInfo_CohostStreamConfig {
    return BusinessContent_CohostUserInfo_CohostStreamConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessContent_CohostUserInfo_CohostStreamConfig>, I>>(
    object: I,
  ): BusinessContent_CohostUserInfo_CohostStreamConfig {
    const message = createBaseBusinessContent_CohostUserInfo_CohostStreamConfig();
    message.screenShareStreamId = object.screenShareStreamId ?? "";
    return message;
  },
};

function createBaseBusinessContent_JoinGroupBizContent(): BusinessContent_JoinGroupBizContent {
  return {
    fromRoomAgeRestricted: 0,
    fromTag: undefined,
    dialog: undefined,
    punishInfo: undefined,
    topicInfo: undefined,
    algoRequestId: "",
    cohostLayoutMode: 0,
    tag: undefined,
    gameTag: undefined,
    newUserEducation: "",
    joinGroupMsgExtra: undefined,
  };
}

export const BusinessContent_JoinGroupBizContent: MessageFns<BusinessContent_JoinGroupBizContent> = {
  encode(message: BusinessContent_JoinGroupBizContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromRoomAgeRestricted !== 0) {
      writer.uint32(8).int32(message.fromRoomAgeRestricted);
    }
    if (message.fromTag !== undefined) {
      BusinessContent_Tag.encode(message.fromTag, writer.uint32(18).fork()).join();
    }
    if (message.dialog !== undefined) {
      BusinessContent_PerceptionDialogInfo.encode(message.dialog, writer.uint32(26).fork()).join();
    }
    if (message.punishInfo !== undefined) {
      PunishEventInfo.encode(message.punishInfo, writer.uint32(34).fork()).join();
    }
    if (message.topicInfo !== undefined) {
      CohostTopic.encode(message.topicInfo, writer.uint32(42).fork()).join();
    }
    if (message.algoRequestId !== "") {
      writer.uint32(50).string(message.algoRequestId);
    }
    if (message.cohostLayoutMode !== 0) {
      writer.uint32(56).int32(message.cohostLayoutMode);
    }
    if (message.tag !== undefined) {
      BusinessContent_JoinGroupBizContent_TagV2.encode(message.tag, writer.uint32(66).fork()).join();
    }
    if (message.gameTag !== undefined) {
      BusinessContent_JoinGroupBizContent_RivalsGameTag.encode(message.gameTag, writer.uint32(74).fork()).join();
    }
    if (message.newUserEducation !== "") {
      writer.uint32(90).string(message.newUserEducation);
    }
    if (message.joinGroupMsgExtra !== undefined) {
      BusinessContent_JoinGroupMessageExtra.encode(message.joinGroupMsgExtra, writer.uint32(810).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_JoinGroupBizContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_JoinGroupBizContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromRoomAgeRestricted = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fromTag = BusinessContent_Tag.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dialog = BusinessContent_PerceptionDialogInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.punishInfo = PunishEventInfo.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.topicInfo = CohostTopic.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.algoRequestId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.cohostLayoutMode = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tag = BusinessContent_JoinGroupBizContent_TagV2.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.gameTag = BusinessContent_JoinGroupBizContent_RivalsGameTag.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.newUserEducation = reader.string();
          continue;
        }
        case 101: {
          if (tag !== 810) {
            break;
          }

          message.joinGroupMsgExtra = BusinessContent_JoinGroupMessageExtra.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BusinessContent_JoinGroupBizContent>, I>>(
    base?: I,
  ): BusinessContent_JoinGroupBizContent {
    return BusinessContent_JoinGroupBizContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessContent_JoinGroupBizContent>, I>>(
    object: I,
  ): BusinessContent_JoinGroupBizContent {
    const message = createBaseBusinessContent_JoinGroupBizContent();
    message.fromRoomAgeRestricted = object.fromRoomAgeRestricted ?? 0;
    message.fromTag = (object.fromTag !== undefined && object.fromTag !== null)
      ? BusinessContent_Tag.fromPartial(object.fromTag)
      : undefined;
    message.dialog = (object.dialog !== undefined && object.dialog !== null)
      ? BusinessContent_PerceptionDialogInfo.fromPartial(object.dialog)
      : undefined;
    message.punishInfo = (object.punishInfo !== undefined && object.punishInfo !== null)
      ? PunishEventInfo.fromPartial(object.punishInfo)
      : undefined;
    message.topicInfo = (object.topicInfo !== undefined && object.topicInfo !== null)
      ? CohostTopic.fromPartial(object.topicInfo)
      : undefined;
    message.algoRequestId = object.algoRequestId ?? "";
    message.cohostLayoutMode = object.cohostLayoutMode ?? 0;
    message.tag = (object.tag !== undefined && object.tag !== null)
      ? BusinessContent_JoinGroupBizContent_TagV2.fromPartial(object.tag)
      : undefined;
    message.gameTag = (object.gameTag !== undefined && object.gameTag !== null)
      ? BusinessContent_JoinGroupBizContent_RivalsGameTag.fromPartial(object.gameTag)
      : undefined;
    message.newUserEducation = object.newUserEducation ?? "";
    message.joinGroupMsgExtra = (object.joinGroupMsgExtra !== undefined && object.joinGroupMsgExtra !== null)
      ? BusinessContent_JoinGroupMessageExtra.fromPartial(object.joinGroupMsgExtra)
      : undefined;
    return message;
  },
};

function createBaseBusinessContent_JoinGroupBizContent_RivalsGameTag(): BusinessContent_JoinGroupBizContent_RivalsGameTag {
  return { tagId: "0", tagDisplayText: "" };
}

export const BusinessContent_JoinGroupBizContent_RivalsGameTag: MessageFns<
  BusinessContent_JoinGroupBizContent_RivalsGameTag
> = {
  encode(
    message: BusinessContent_JoinGroupBizContent_RivalsGameTag,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.tagId !== "0") {
      writer.uint32(8).int64(message.tagId);
    }
    if (message.tagDisplayText !== "") {
      writer.uint32(18).string(message.tagDisplayText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_JoinGroupBizContent_RivalsGameTag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_JoinGroupBizContent_RivalsGameTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tagId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tagDisplayText = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BusinessContent_JoinGroupBizContent_RivalsGameTag>, I>>(
    base?: I,
  ): BusinessContent_JoinGroupBizContent_RivalsGameTag {
    return BusinessContent_JoinGroupBizContent_RivalsGameTag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessContent_JoinGroupBizContent_RivalsGameTag>, I>>(
    object: I,
  ): BusinessContent_JoinGroupBizContent_RivalsGameTag {
    const message = createBaseBusinessContent_JoinGroupBizContent_RivalsGameTag();
    message.tagId = object.tagId ?? "0";
    message.tagDisplayText = object.tagDisplayText ?? "";
    return message;
  },
};

function createBaseBusinessContent_JoinGroupBizContent_TagV2(): BusinessContent_JoinGroupBizContent_TagV2 {
  return {
    tagClassification: 0,
    tagType: 0,
    tagValue: "",
    starlingKey: "",
    secondDegreeRelationContent: undefined,
    cohostHistoryDay: "0",
    similarInterestContent: undefined,
  };
}

export const BusinessContent_JoinGroupBizContent_TagV2: MessageFns<BusinessContent_JoinGroupBizContent_TagV2> = {
  encode(message: BusinessContent_JoinGroupBizContent_TagV2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tagClassification !== 0) {
      writer.uint32(8).int32(message.tagClassification);
    }
    if (message.tagType !== 0) {
      writer.uint32(16).int32(message.tagType);
    }
    if (message.tagValue !== "") {
      writer.uint32(26).string(message.tagValue);
    }
    if (message.starlingKey !== "") {
      writer.uint32(34).string(message.starlingKey);
    }
    if (message.secondDegreeRelationContent !== undefined) {
      BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent.encode(
        message.secondDegreeRelationContent,
        writer.uint32(82).fork(),
      ).join();
    }
    if (message.cohostHistoryDay !== "0") {
      writer.uint32(88).int64(message.cohostHistoryDay);
    }
    if (message.similarInterestContent !== undefined) {
      BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent.encode(
        message.similarInterestContent,
        writer.uint32(98).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_JoinGroupBizContent_TagV2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_JoinGroupBizContent_TagV2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tagClassification = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.tagType = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tagValue = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.starlingKey = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.secondDegreeRelationContent = BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent
            .decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.cohostHistoryDay = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.similarInterestContent = BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BusinessContent_JoinGroupBizContent_TagV2>, I>>(
    base?: I,
  ): BusinessContent_JoinGroupBizContent_TagV2 {
    return BusinessContent_JoinGroupBizContent_TagV2.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessContent_JoinGroupBizContent_TagV2>, I>>(
    object: I,
  ): BusinessContent_JoinGroupBizContent_TagV2 {
    const message = createBaseBusinessContent_JoinGroupBizContent_TagV2();
    message.tagClassification = object.tagClassification ?? 0;
    message.tagType = object.tagType ?? 0;
    message.tagValue = object.tagValue ?? "";
    message.starlingKey = object.starlingKey ?? "";
    message.secondDegreeRelationContent =
      (object.secondDegreeRelationContent !== undefined && object.secondDegreeRelationContent !== null)
        ? BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent.fromPartial(
          object.secondDegreeRelationContent,
        )
        : undefined;
    message.cohostHistoryDay = object.cohostHistoryDay ?? "0";
    message.similarInterestContent =
      (object.similarInterestContent !== undefined && object.similarInterestContent !== null)
        ? BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent.fromPartial(object.similarInterestContent)
        : undefined;
    return message;
  },
};

function createBaseBusinessContent_JoinGroupBizContent_TagV2_UserInfo(): BusinessContent_JoinGroupBizContent_TagV2_UserInfo {
  return { userId: "0", nickName: "", avatarThumb: undefined };
}

export const BusinessContent_JoinGroupBizContent_TagV2_UserInfo: MessageFns<
  BusinessContent_JoinGroupBizContent_TagV2_UserInfo
> = {
  encode(
    message: BusinessContent_JoinGroupBizContent_TagV2_UserInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.nickName !== "") {
      writer.uint32(18).string(message.nickName);
    }
    if (message.avatarThumb !== undefined) {
      Image.encode(message.avatarThumb, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_JoinGroupBizContent_TagV2_UserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_JoinGroupBizContent_TagV2_UserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nickName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.avatarThumb = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BusinessContent_JoinGroupBizContent_TagV2_UserInfo>, I>>(
    base?: I,
  ): BusinessContent_JoinGroupBizContent_TagV2_UserInfo {
    return BusinessContent_JoinGroupBizContent_TagV2_UserInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessContent_JoinGroupBizContent_TagV2_UserInfo>, I>>(
    object: I,
  ): BusinessContent_JoinGroupBizContent_TagV2_UserInfo {
    const message = createBaseBusinessContent_JoinGroupBizContent_TagV2_UserInfo();
    message.userId = object.userId ?? "0";
    message.nickName = object.nickName ?? "";
    message.avatarThumb = (object.avatarThumb !== undefined && object.avatarThumb !== null)
      ? Image.fromPartial(object.avatarThumb)
      : undefined;
    return message;
  },
};

function createBaseBusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent(): BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent {
  return { relatedUsers: [], totalRelatedUserCnt: "0" };
}

export const BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent: MessageFns<
  BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent
> = {
  encode(
    message: BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.relatedUsers) {
      BusinessContent_JoinGroupBizContent_TagV2_UserInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalRelatedUserCnt !== "0") {
      writer.uint32(16).int64(message.totalRelatedUserCnt);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.relatedUsers.push(BusinessContent_JoinGroupBizContent_TagV2_UserInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalRelatedUserCnt = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent>, I>>(
    base?: I,
  ): BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent {
    return BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent>, I>>(
    object: I,
  ): BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent {
    const message = createBaseBusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent();
    message.relatedUsers =
      object.relatedUsers?.map((e) => BusinessContent_JoinGroupBizContent_TagV2_UserInfo.fromPartial(e)) || [];
    message.totalRelatedUserCnt = object.totalRelatedUserCnt ?? "0";
    return message;
  },
};

function createBaseBusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent(): BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent {
  return { contentId: "0", displayText: "" };
}

export const BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent: MessageFns<
  BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent
> = {
  encode(
    message: BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.contentId !== "0") {
      writer.uint32(8).int64(message.contentId);
    }
    if (message.displayText !== "") {
      writer.uint32(18).string(message.displayText);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.contentId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayText = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent>, I>>(
    base?: I,
  ): BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent {
    return BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent>, I>>(
    object: I,
  ): BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent {
    const message = createBaseBusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent();
    message.contentId = object.contentId ?? "0";
    message.displayText = object.displayText ?? "";
    return message;
  },
};

function createBaseBusinessContent_Tag(): BusinessContent_Tag {
  return { tagType: 0, tagValue: "", tagText: "" };
}

export const BusinessContent_Tag: MessageFns<BusinessContent_Tag> = {
  encode(message: BusinessContent_Tag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tagType !== 0) {
      writer.uint32(8).int32(message.tagType);
    }
    if (message.tagValue !== "") {
      writer.uint32(18).string(message.tagValue);
    }
    if (message.tagText !== "") {
      writer.uint32(26).string(message.tagText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_Tag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_Tag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tagType = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tagValue = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tagText = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BusinessContent_Tag>, I>>(base?: I): BusinessContent_Tag {
    return BusinessContent_Tag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessContent_Tag>, I>>(object: I): BusinessContent_Tag {
    const message = createBaseBusinessContent_Tag();
    message.tagType = object.tagType ?? 0;
    message.tagValue = object.tagValue ?? "";
    message.tagText = object.tagText ?? "";
    return message;
  },
};

function createBaseBusinessContent_PerceptionDialogInfo(): BusinessContent_PerceptionDialogInfo {
  return {
    iconType: "0",
    title: undefined,
    subTitle: undefined,
    adviceActionText: undefined,
    defaultActionText: undefined,
    violationDetailUrl: "",
    scene: 0,
    targetUserId: "0",
    targetRoomId: "0",
    countDownTime: "0",
    showFeedback: false,
    feedbackOptionsList: [],
    policyTip: "0",
  };
}

export const BusinessContent_PerceptionDialogInfo: MessageFns<BusinessContent_PerceptionDialogInfo> = {
  encode(message: BusinessContent_PerceptionDialogInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iconType !== "0") {
      writer.uint32(8).int64(message.iconType);
    }
    if (message.title !== undefined) {
      Text.encode(message.title, writer.uint32(18).fork()).join();
    }
    if (message.subTitle !== undefined) {
      Text.encode(message.subTitle, writer.uint32(26).fork()).join();
    }
    if (message.adviceActionText !== undefined) {
      Text.encode(message.adviceActionText, writer.uint32(34).fork()).join();
    }
    if (message.defaultActionText !== undefined) {
      Text.encode(message.defaultActionText, writer.uint32(42).fork()).join();
    }
    if (message.violationDetailUrl !== "") {
      writer.uint32(50).string(message.violationDetailUrl);
    }
    if (message.scene !== 0) {
      writer.uint32(56).int32(message.scene);
    }
    if (message.targetUserId !== "0") {
      writer.uint32(64).int64(message.targetUserId);
    }
    if (message.targetRoomId !== "0") {
      writer.uint32(72).int64(message.targetRoomId);
    }
    if (message.countDownTime !== "0") {
      writer.uint32(80).int64(message.countDownTime);
    }
    if (message.showFeedback !== false) {
      writer.uint32(88).bool(message.showFeedback);
    }
    for (const v of message.feedbackOptionsList) {
      BusinessContent_PerceptionFeedbackOption.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.policyTip !== "0") {
      writer.uint32(104).int64(message.policyTip);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_PerceptionDialogInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_PerceptionDialogInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.iconType = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = Text.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subTitle = Text.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.adviceActionText = Text.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.defaultActionText = Text.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.violationDetailUrl = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.scene = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.targetUserId = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.targetRoomId = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.countDownTime = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.showFeedback = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.feedbackOptionsList.push(BusinessContent_PerceptionFeedbackOption.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.policyTip = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BusinessContent_PerceptionDialogInfo>, I>>(
    base?: I,
  ): BusinessContent_PerceptionDialogInfo {
    return BusinessContent_PerceptionDialogInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessContent_PerceptionDialogInfo>, I>>(
    object: I,
  ): BusinessContent_PerceptionDialogInfo {
    const message = createBaseBusinessContent_PerceptionDialogInfo();
    message.iconType = object.iconType ?? "0";
    message.title = (object.title !== undefined && object.title !== null) ? Text.fromPartial(object.title) : undefined;
    message.subTitle = (object.subTitle !== undefined && object.subTitle !== null)
      ? Text.fromPartial(object.subTitle)
      : undefined;
    message.adviceActionText = (object.adviceActionText !== undefined && object.adviceActionText !== null)
      ? Text.fromPartial(object.adviceActionText)
      : undefined;
    message.defaultActionText = (object.defaultActionText !== undefined && object.defaultActionText !== null)
      ? Text.fromPartial(object.defaultActionText)
      : undefined;
    message.violationDetailUrl = object.violationDetailUrl ?? "";
    message.scene = object.scene ?? 0;
    message.targetUserId = object.targetUserId ?? "0";
    message.targetRoomId = object.targetRoomId ?? "0";
    message.countDownTime = object.countDownTime ?? "0";
    message.showFeedback = object.showFeedback ?? false;
    message.feedbackOptionsList =
      object.feedbackOptionsList?.map((e) => BusinessContent_PerceptionFeedbackOption.fromPartial(e)) || [];
    message.policyTip = object.policyTip ?? "0";
    return message;
  },
};

function createBaseBusinessContent_PerceptionFeedbackOption(): BusinessContent_PerceptionFeedbackOption {
  return { id: "0", contentKey: "" };
}

export const BusinessContent_PerceptionFeedbackOption: MessageFns<BusinessContent_PerceptionFeedbackOption> = {
  encode(message: BusinessContent_PerceptionFeedbackOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.contentKey !== "") {
      writer.uint32(18).string(message.contentKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_PerceptionFeedbackOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_PerceptionFeedbackOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contentKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BusinessContent_PerceptionFeedbackOption>, I>>(
    base?: I,
  ): BusinessContent_PerceptionFeedbackOption {
    return BusinessContent_PerceptionFeedbackOption.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessContent_PerceptionFeedbackOption>, I>>(
    object: I,
  ): BusinessContent_PerceptionFeedbackOption {
    const message = createBaseBusinessContent_PerceptionFeedbackOption();
    message.id = object.id ?? "0";
    message.contentKey = object.contentKey ?? "";
    return message;
  },
};

function createBaseBusinessContent_JoinGroupMessageExtra(): BusinessContent_JoinGroupMessageExtra {
  return { sourceType: "0", extra: undefined, otherUsersList: [] };
}

export const BusinessContent_JoinGroupMessageExtra: MessageFns<BusinessContent_JoinGroupMessageExtra> = {
  encode(message: BusinessContent_JoinGroupMessageExtra, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceType !== "0") {
      writer.uint32(8).int64(message.sourceType);
    }
    if (message.extra !== undefined) {
      BusinessContent_JoinGroupMessageExtra_RivalExtra.encode(message.extra, writer.uint32(18).fork()).join();
    }
    for (const v of message.otherUsersList) {
      BusinessContent_JoinGroupMessageExtra_RivalExtra.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_JoinGroupMessageExtra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_JoinGroupMessageExtra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sourceType = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.extra = BusinessContent_JoinGroupMessageExtra_RivalExtra.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.otherUsersList.push(BusinessContent_JoinGroupMessageExtra_RivalExtra.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BusinessContent_JoinGroupMessageExtra>, I>>(
    base?: I,
  ): BusinessContent_JoinGroupMessageExtra {
    return BusinessContent_JoinGroupMessageExtra.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessContent_JoinGroupMessageExtra>, I>>(
    object: I,
  ): BusinessContent_JoinGroupMessageExtra {
    const message = createBaseBusinessContent_JoinGroupMessageExtra();
    message.sourceType = object.sourceType ?? "0";
    message.extra = (object.extra !== undefined && object.extra !== null)
      ? BusinessContent_JoinGroupMessageExtra_RivalExtra.fromPartial(object.extra)
      : undefined;
    message.otherUsersList =
      object.otherUsersList?.map((e) => BusinessContent_JoinGroupMessageExtra_RivalExtra.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBusinessContent_JoinGroupMessageExtra_RivalExtra(): BusinessContent_JoinGroupMessageExtra_RivalExtra {
  return {
    userCount: "0",
    avatarThumb: undefined,
    displayId: "",
    authenticationInfo: undefined,
    nickname: "",
    followStatus: "0",
    hashtag: undefined,
    topHostInfo: undefined,
    userId: "0",
    isBestTeammate: false,
  };
}

export const BusinessContent_JoinGroupMessageExtra_RivalExtra: MessageFns<
  BusinessContent_JoinGroupMessageExtra_RivalExtra
> = {
  encode(
    message: BusinessContent_JoinGroupMessageExtra_RivalExtra,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userCount !== "0") {
      writer.uint32(32).int64(message.userCount);
    }
    if (message.avatarThumb !== undefined) {
      Image.encode(message.avatarThumb, writer.uint32(42).fork()).join();
    }
    if (message.displayId !== "") {
      writer.uint32(50).string(message.displayId);
    }
    if (message.authenticationInfo !== undefined) {
      BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo.encode(
        message.authenticationInfo,
        writer.uint32(58).fork(),
      ).join();
    }
    if (message.nickname !== "") {
      writer.uint32(66).string(message.nickname);
    }
    if (message.followStatus !== "0") {
      writer.uint32(72).int64(message.followStatus);
    }
    if (message.hashtag !== undefined) {
      BusinessContent_Hashtag.encode(message.hashtag, writer.uint32(82).fork()).join();
    }
    if (message.topHostInfo !== undefined) {
      BusinessContent_TopHostInfo.encode(message.topHostInfo, writer.uint32(90).fork()).join();
    }
    if (message.userId !== "0") {
      writer.uint32(96).int64(message.userId);
    }
    if (message.isBestTeammate !== false) {
      writer.uint32(104).bool(message.isBestTeammate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_JoinGroupMessageExtra_RivalExtra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_JoinGroupMessageExtra_RivalExtra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.userCount = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.avatarThumb = Image.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.displayId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.authenticationInfo = BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.followStatus = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.hashtag = BusinessContent_Hashtag.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.topHostInfo = BusinessContent_TopHostInfo.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isBestTeammate = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BusinessContent_JoinGroupMessageExtra_RivalExtra>, I>>(
    base?: I,
  ): BusinessContent_JoinGroupMessageExtra_RivalExtra {
    return BusinessContent_JoinGroupMessageExtra_RivalExtra.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessContent_JoinGroupMessageExtra_RivalExtra>, I>>(
    object: I,
  ): BusinessContent_JoinGroupMessageExtra_RivalExtra {
    const message = createBaseBusinessContent_JoinGroupMessageExtra_RivalExtra();
    message.userCount = object.userCount ?? "0";
    message.avatarThumb = (object.avatarThumb !== undefined && object.avatarThumb !== null)
      ? Image.fromPartial(object.avatarThumb)
      : undefined;
    message.displayId = object.displayId ?? "";
    message.authenticationInfo = (object.authenticationInfo !== undefined && object.authenticationInfo !== null)
      ? BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo.fromPartial(object.authenticationInfo)
      : undefined;
    message.nickname = object.nickname ?? "";
    message.followStatus = object.followStatus ?? "0";
    message.hashtag = (object.hashtag !== undefined && object.hashtag !== null)
      ? BusinessContent_Hashtag.fromPartial(object.hashtag)
      : undefined;
    message.topHostInfo = (object.topHostInfo !== undefined && object.topHostInfo !== null)
      ? BusinessContent_TopHostInfo.fromPartial(object.topHostInfo)
      : undefined;
    message.userId = object.userId ?? "0";
    message.isBestTeammate = object.isBestTeammate ?? false;
    return message;
  },
};

function createBaseBusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo(): BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo {
  return { customVerify: "", enterpriseVerifyReason: "", authenticationBadge: undefined };
}

export const BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo: MessageFns<
  BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo
> = {
  encode(
    message: BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.customVerify !== "") {
      writer.uint32(10).string(message.customVerify);
    }
    if (message.enterpriseVerifyReason !== "") {
      writer.uint32(18).string(message.enterpriseVerifyReason);
    }
    if (message.authenticationBadge !== undefined) {
      Image.encode(message.authenticationBadge, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.customVerify = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.enterpriseVerifyReason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authenticationBadge = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo>, I>>(
    base?: I,
  ): BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo {
    return BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo>, I>>(
    object: I,
  ): BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo {
    const message = createBaseBusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo();
    message.customVerify = object.customVerify ?? "";
    message.enterpriseVerifyReason = object.enterpriseVerifyReason ?? "";
    message.authenticationBadge = (object.authenticationBadge !== undefined && object.authenticationBadge !== null)
      ? Image.fromPartial(object.authenticationBadge)
      : undefined;
    return message;
  },
};

function createBaseBusinessContent_Hashtag(): BusinessContent_Hashtag {
  return { id: "0", title: "", image: undefined, namespace: 0 };
}

export const BusinessContent_Hashtag: MessageFns<BusinessContent_Hashtag> = {
  encode(message: BusinessContent_Hashtag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.image !== undefined) {
      Image.encode(message.image, writer.uint32(26).fork()).join();
    }
    if (message.namespace !== 0) {
      writer.uint32(32).int32(message.namespace);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_Hashtag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_Hashtag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.image = Image.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.namespace = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BusinessContent_Hashtag>, I>>(base?: I): BusinessContent_Hashtag {
    return BusinessContent_Hashtag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessContent_Hashtag>, I>>(object: I): BusinessContent_Hashtag {
    const message = createBaseBusinessContent_Hashtag();
    message.id = object.id ?? "0";
    message.title = object.title ?? "";
    message.image = (object.image !== undefined && object.image !== null) ? Image.fromPartial(object.image) : undefined;
    message.namespace = object.namespace ?? 0;
    return message;
  },
};

function createBaseBusinessContent_TopHostInfo(): BusinessContent_TopHostInfo {
  return { rankType: "", topIndex: "0" };
}

export const BusinessContent_TopHostInfo: MessageFns<BusinessContent_TopHostInfo> = {
  encode(message: BusinessContent_TopHostInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rankType !== "") {
      writer.uint32(10).string(message.rankType);
    }
    if (message.topIndex !== "0") {
      writer.uint32(16).int64(message.topIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BusinessContent_TopHostInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBusinessContent_TopHostInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rankType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.topIndex = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BusinessContent_TopHostInfo>, I>>(base?: I): BusinessContent_TopHostInfo {
    return BusinessContent_TopHostInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BusinessContent_TopHostInfo>, I>>(object: I): BusinessContent_TopHostInfo {
    const message = createBaseBusinessContent_TopHostInfo();
    message.rankType = object.rankType ?? "";
    message.topIndex = object.topIndex ?? "0";
    return message;
  },
};

function createBaseJoinGroupContent(): JoinGroupContent {
  return { groupUser: undefined, joinUser: undefined, type: 0, groupExtInfo: [] };
}

export const JoinGroupContent: MessageFns<JoinGroupContent> = {
  encode(message: JoinGroupContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupUser !== undefined) {
      GroupChannelAllUser.encode(message.groupUser, writer.uint32(10).fork()).join();
    }
    if (message.joinUser !== undefined) {
      GroupPlayer.encode(message.joinUser, writer.uint32(18).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    for (const v of message.groupExtInfo) {
      RTCExtraInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoinGroupContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinGroupContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupUser = GroupChannelAllUser.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.joinUser = GroupPlayer.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.groupExtInfo.push(RTCExtraInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<JoinGroupContent>, I>>(base?: I): JoinGroupContent {
    return JoinGroupContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JoinGroupContent>, I>>(object: I): JoinGroupContent {
    const message = createBaseJoinGroupContent();
    message.groupUser = (object.groupUser !== undefined && object.groupUser !== null)
      ? GroupChannelAllUser.fromPartial(object.groupUser)
      : undefined;
    message.joinUser = (object.joinUser !== undefined && object.joinUser !== null)
      ? GroupPlayer.fromPartial(object.joinUser)
      : undefined;
    message.type = object.type ?? 0;
    message.groupExtInfo = object.groupExtInfo?.map((e) => RTCExtraInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBasePrivilegeLogExtra(): PrivilegeLogExtra {
  return { dataVersion: "", privilegeId: "", privilegeVersion: "", privilegeOrderId: "", level: "" };
}

export const PrivilegeLogExtra: MessageFns<PrivilegeLogExtra> = {
  encode(message: PrivilegeLogExtra, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataVersion !== "") {
      writer.uint32(10).string(message.dataVersion);
    }
    if (message.privilegeId !== "") {
      writer.uint32(18).string(message.privilegeId);
    }
    if (message.privilegeVersion !== "") {
      writer.uint32(26).string(message.privilegeVersion);
    }
    if (message.privilegeOrderId !== "") {
      writer.uint32(34).string(message.privilegeOrderId);
    }
    if (message.level !== "") {
      writer.uint32(42).string(message.level);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivilegeLogExtra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivilegeLogExtra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dataVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.privilegeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.privilegeVersion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.privilegeOrderId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.level = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<PrivilegeLogExtra>, I>>(base?: I): PrivilegeLogExtra {
    return PrivilegeLogExtra.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrivilegeLogExtra>, I>>(object: I): PrivilegeLogExtra {
    const message = createBasePrivilegeLogExtra();
    message.dataVersion = object.dataVersion ?? "";
    message.privilegeId = object.privilegeId ?? "";
    message.privilegeVersion = object.privilegeVersion ?? "";
    message.privilegeOrderId = object.privilegeOrderId ?? "";
    message.level = object.level ?? "";
    return message;
  },
};

function createBaseFontStyle(): FontStyle {
  return { fontSize: 0, fontWidth: 0, fontColor: "", borderColor: "" };
}

export const FontStyle: MessageFns<FontStyle> = {
  encode(message: FontStyle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fontSize !== 0) {
      writer.uint32(8).int32(message.fontSize);
    }
    if (message.fontWidth !== 0) {
      writer.uint32(16).int32(message.fontWidth);
    }
    if (message.fontColor !== "") {
      writer.uint32(26).string(message.fontColor);
    }
    if (message.borderColor !== "") {
      writer.uint32(34).string(message.borderColor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FontStyle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFontStyle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fontSize = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fontWidth = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fontColor = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.borderColor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<FontStyle>, I>>(base?: I): FontStyle {
    return FontStyle.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FontStyle>, I>>(object: I): FontStyle {
    const message = createBaseFontStyle();
    message.fontSize = object.fontSize ?? 0;
    message.fontWidth = object.fontWidth ?? 0;
    message.fontColor = object.fontColor ?? "";
    message.borderColor = object.borderColor ?? "";
    return message;
  },
};

function createBaseUserHonor(): UserHonor {
  return {
    totalDiamond: "0",
    diamondIcon: undefined,
    currentHonorName: "",
    currentHonorIcon: undefined,
    nextHonorName: "",
    level: 0,
    nextHonorIcon: undefined,
    currentDiamond: "0",
    thisGradeMinDiamond: "0",
    thisGradeMaxDiamond: "0",
    gradeDescribe: "",
    gradeIconList: [],
    screenChatType: "0",
    imIcon: undefined,
    imIconWithLevel: undefined,
    liveIcon: undefined,
    newImIconWithLevel: undefined,
    newLiveIcon: undefined,
    upgradeNeedConsume: "0",
    nextPrivileges: "",
    profileDialogBg: undefined,
    profileDialogBackBg: undefined,
    score: "0",
    gradeBanner: "",
  };
}

export const UserHonor: MessageFns<UserHonor> = {
  encode(message: UserHonor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalDiamond !== "0") {
      writer.uint32(8).int64(message.totalDiamond);
    }
    if (message.diamondIcon !== undefined) {
      Image.encode(message.diamondIcon, writer.uint32(18).fork()).join();
    }
    if (message.currentHonorName !== "") {
      writer.uint32(26).string(message.currentHonorName);
    }
    if (message.currentHonorIcon !== undefined) {
      Image.encode(message.currentHonorIcon, writer.uint32(34).fork()).join();
    }
    if (message.nextHonorName !== "") {
      writer.uint32(42).string(message.nextHonorName);
    }
    if (message.level !== 0) {
      writer.uint32(48).int32(message.level);
    }
    if (message.nextHonorIcon !== undefined) {
      Image.encode(message.nextHonorIcon, writer.uint32(58).fork()).join();
    }
    if (message.currentDiamond !== "0") {
      writer.uint32(72).int64(message.currentDiamond);
    }
    if (message.thisGradeMinDiamond !== "0") {
      writer.uint32(80).int64(message.thisGradeMinDiamond);
    }
    if (message.thisGradeMaxDiamond !== "0") {
      writer.uint32(88).int64(message.thisGradeMaxDiamond);
    }
    if (message.gradeDescribe !== "") {
      writer.uint32(106).string(message.gradeDescribe);
    }
    for (const v of message.gradeIconList) {
      GradeIcon.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.screenChatType !== "0") {
      writer.uint32(120).int64(message.screenChatType);
    }
    if (message.imIcon !== undefined) {
      Image.encode(message.imIcon, writer.uint32(130).fork()).join();
    }
    if (message.imIconWithLevel !== undefined) {
      Image.encode(message.imIconWithLevel, writer.uint32(138).fork()).join();
    }
    if (message.liveIcon !== undefined) {
      Image.encode(message.liveIcon, writer.uint32(146).fork()).join();
    }
    if (message.newImIconWithLevel !== undefined) {
      Image.encode(message.newImIconWithLevel, writer.uint32(154).fork()).join();
    }
    if (message.newLiveIcon !== undefined) {
      Image.encode(message.newLiveIcon, writer.uint32(162).fork()).join();
    }
    if (message.upgradeNeedConsume !== "0") {
      writer.uint32(168).int64(message.upgradeNeedConsume);
    }
    if (message.nextPrivileges !== "") {
      writer.uint32(178).string(message.nextPrivileges);
    }
    if (message.profileDialogBg !== undefined) {
      Image.encode(message.profileDialogBg, writer.uint32(186).fork()).join();
    }
    if (message.profileDialogBackBg !== undefined) {
      Image.encode(message.profileDialogBackBg, writer.uint32(194).fork()).join();
    }
    if (message.score !== "0") {
      writer.uint32(200).int64(message.score);
    }
    if (message.gradeBanner !== "") {
      writer.uint32(8010).string(message.gradeBanner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserHonor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserHonor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalDiamond = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.diamondIcon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currentHonorName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currentHonorIcon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nextHonorName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.level = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.nextHonorIcon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.currentDiamond = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.thisGradeMinDiamond = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.thisGradeMaxDiamond = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.gradeDescribe = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.gradeIconList.push(GradeIcon.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.screenChatType = reader.int64().toString();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.imIcon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.imIconWithLevel = Image.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.liveIcon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.newImIconWithLevel = Image.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.newLiveIcon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.upgradeNeedConsume = reader.int64().toString();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.nextPrivileges = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.profileDialogBg = Image.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.profileDialogBackBg = Image.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.score = reader.int64().toString();
          continue;
        }
        case 1001: {
          if (tag !== 8010) {
            break;
          }

          message.gradeBanner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<UserHonor>, I>>(base?: I): UserHonor {
    return UserHonor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserHonor>, I>>(object: I): UserHonor {
    const message = createBaseUserHonor();
    message.totalDiamond = object.totalDiamond ?? "0";
    message.diamondIcon = (object.diamondIcon !== undefined && object.diamondIcon !== null)
      ? Image.fromPartial(object.diamondIcon)
      : undefined;
    message.currentHonorName = object.currentHonorName ?? "";
    message.currentHonorIcon = (object.currentHonorIcon !== undefined && object.currentHonorIcon !== null)
      ? Image.fromPartial(object.currentHonorIcon)
      : undefined;
    message.nextHonorName = object.nextHonorName ?? "";
    message.level = object.level ?? 0;
    message.nextHonorIcon = (object.nextHonorIcon !== undefined && object.nextHonorIcon !== null)
      ? Image.fromPartial(object.nextHonorIcon)
      : undefined;
    message.currentDiamond = object.currentDiamond ?? "0";
    message.thisGradeMinDiamond = object.thisGradeMinDiamond ?? "0";
    message.thisGradeMaxDiamond = object.thisGradeMaxDiamond ?? "0";
    message.gradeDescribe = object.gradeDescribe ?? "";
    message.gradeIconList = object.gradeIconList?.map((e) => GradeIcon.fromPartial(e)) || [];
    message.screenChatType = object.screenChatType ?? "0";
    message.imIcon = (object.imIcon !== undefined && object.imIcon !== null)
      ? Image.fromPartial(object.imIcon)
      : undefined;
    message.imIconWithLevel = (object.imIconWithLevel !== undefined && object.imIconWithLevel !== null)
      ? Image.fromPartial(object.imIconWithLevel)
      : undefined;
    message.liveIcon = (object.liveIcon !== undefined && object.liveIcon !== null)
      ? Image.fromPartial(object.liveIcon)
      : undefined;
    message.newImIconWithLevel = (object.newImIconWithLevel !== undefined && object.newImIconWithLevel !== null)
      ? Image.fromPartial(object.newImIconWithLevel)
      : undefined;
    message.newLiveIcon = (object.newLiveIcon !== undefined && object.newLiveIcon !== null)
      ? Image.fromPartial(object.newLiveIcon)
      : undefined;
    message.upgradeNeedConsume = object.upgradeNeedConsume ?? "0";
    message.nextPrivileges = object.nextPrivileges ?? "";
    message.profileDialogBg = (object.profileDialogBg !== undefined && object.profileDialogBg !== null)
      ? Image.fromPartial(object.profileDialogBg)
      : undefined;
    message.profileDialogBackBg = (object.profileDialogBackBg !== undefined && object.profileDialogBackBg !== null)
      ? Image.fromPartial(object.profileDialogBackBg)
      : undefined;
    message.score = object.score ?? "0";
    message.gradeBanner = object.gradeBanner ?? "";
    return message;
  },
};

function createBaseGradeIcon(): GradeIcon {
  return { icon: undefined, iconDiamond: "0", level: "0", levelStr: "" };
}

export const GradeIcon: MessageFns<GradeIcon> = {
  encode(message: GradeIcon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.icon !== undefined) {
      Image.encode(message.icon, writer.uint32(10).fork()).join();
    }
    if (message.iconDiamond !== "0") {
      writer.uint32(16).int64(message.iconDiamond);
    }
    if (message.level !== "0") {
      writer.uint32(24).int64(message.level);
    }
    if (message.levelStr !== "") {
      writer.uint32(34).string(message.levelStr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GradeIcon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGradeIcon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.icon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.iconDiamond = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.level = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.levelStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<GradeIcon>, I>>(base?: I): GradeIcon {
    return GradeIcon.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GradeIcon>, I>>(object: I): GradeIcon {
    const message = createBaseGradeIcon();
    message.icon = (object.icon !== undefined && object.icon !== null) ? Image.fromPartial(object.icon) : undefined;
    message.iconDiamond = object.iconDiamond ?? "0";
    message.level = object.level ?? "0";
    message.levelStr = object.levelStr ?? "";
    return message;
  },
};

function createBaseBorderInfo(): BorderInfo {
  return {
    icon: undefined,
    level: "0",
    source: "",
    profileDecorationRibbon: undefined,
    borderLogExtra: undefined,
    ribbonLogExtra: undefined,
    avatarBackgroundColor: "",
    avatarBackgroundBorderColor: "",
  };
}

export const BorderInfo: MessageFns<BorderInfo> = {
  encode(message: BorderInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.icon !== undefined) {
      Image.encode(message.icon, writer.uint32(10).fork()).join();
    }
    if (message.level !== "0") {
      writer.uint32(16).int64(message.level);
    }
    if (message.source !== "") {
      writer.uint32(26).string(message.source);
    }
    if (message.profileDecorationRibbon !== undefined) {
      Image.encode(message.profileDecorationRibbon, writer.uint32(34).fork()).join();
    }
    if (message.borderLogExtra !== undefined) {
      PrivilegeLogExtra.encode(message.borderLogExtra, writer.uint32(42).fork()).join();
    }
    if (message.ribbonLogExtra !== undefined) {
      PrivilegeLogExtra.encode(message.ribbonLogExtra, writer.uint32(50).fork()).join();
    }
    if (message.avatarBackgroundColor !== "") {
      writer.uint32(58).string(message.avatarBackgroundColor);
    }
    if (message.avatarBackgroundBorderColor !== "") {
      writer.uint32(66).string(message.avatarBackgroundBorderColor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BorderInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBorderInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.icon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.level = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.profileDecorationRibbon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.borderLogExtra = PrivilegeLogExtra.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.ribbonLogExtra = PrivilegeLogExtra.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.avatarBackgroundColor = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.avatarBackgroundBorderColor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BorderInfo>, I>>(base?: I): BorderInfo {
    return BorderInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BorderInfo>, I>>(object: I): BorderInfo {
    const message = createBaseBorderInfo();
    message.icon = (object.icon !== undefined && object.icon !== null) ? Image.fromPartial(object.icon) : undefined;
    message.level = object.level ?? "0";
    message.source = object.source ?? "";
    message.profileDecorationRibbon =
      (object.profileDecorationRibbon !== undefined && object.profileDecorationRibbon !== null)
        ? Image.fromPartial(object.profileDecorationRibbon)
        : undefined;
    message.borderLogExtra = (object.borderLogExtra !== undefined && object.borderLogExtra !== null)
      ? PrivilegeLogExtra.fromPartial(object.borderLogExtra)
      : undefined;
    message.ribbonLogExtra = (object.ribbonLogExtra !== undefined && object.ribbonLogExtra !== null)
      ? PrivilegeLogExtra.fromPartial(object.ribbonLogExtra)
      : undefined;
    message.avatarBackgroundColor = object.avatarBackgroundColor ?? "";
    message.avatarBackgroundBorderColor = object.avatarBackgroundBorderColor ?? "";
    return message;
  },
};

function createBaseFansClubMember(): FansClubMember {
  return { data: undefined, preferData: {} };
}

export const FansClubMember: MessageFns<FansClubMember> = {
  encode(message: FansClubMember, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      FansClubData.encode(message.data, writer.uint32(10).fork()).join();
    }
    Object.entries(message.preferData).forEach(([key, value]) => {
      FansClubMember_PreferDataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FansClubMember {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFansClubMember();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = FansClubData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = FansClubMember_PreferDataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.preferData[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<FansClubMember>, I>>(base?: I): FansClubMember {
    return FansClubMember.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FansClubMember>, I>>(object: I): FansClubMember {
    const message = createBaseFansClubMember();
    message.data = (object.data !== undefined && object.data !== null)
      ? FansClubData.fromPartial(object.data)
      : undefined;
    message.preferData = Object.entries(object.preferData ?? {}).reduce<{ [key: number]: FansClubData }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[globalThis.Number(key)] = FansClubData.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseFansClubMember_PreferDataEntry(): FansClubMember_PreferDataEntry {
  return { key: 0, value: undefined };
}

export const FansClubMember_PreferDataEntry: MessageFns<FansClubMember_PreferDataEntry> = {
  encode(message: FansClubMember_PreferDataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== undefined) {
      FansClubData.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FansClubMember_PreferDataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFansClubMember_PreferDataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = FansClubData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<FansClubMember_PreferDataEntry>, I>>(base?: I): FansClubMember_PreferDataEntry {
    return FansClubMember_PreferDataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FansClubMember_PreferDataEntry>, I>>(
    object: I,
  ): FansClubMember_PreferDataEntry {
    const message = createBaseFansClubMember_PreferDataEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? FansClubData.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseFansClubData(): FansClubData {
  return { clubName: "", level: 0, userFansClubStatus: 0, badge: undefined, availableGiftIds: [], anchorId: "0" };
}

export const FansClubData: MessageFns<FansClubData> = {
  encode(message: FansClubData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clubName !== "") {
      writer.uint32(10).string(message.clubName);
    }
    if (message.level !== 0) {
      writer.uint32(16).int32(message.level);
    }
    if (message.userFansClubStatus !== 0) {
      writer.uint32(24).int32(message.userFansClubStatus);
    }
    if (message.badge !== undefined) {
      FansClubData_UserBadge.encode(message.badge, writer.uint32(34).fork()).join();
    }
    writer.uint32(42).fork();
    for (const v of message.availableGiftIds) {
      writer.int64(v);
    }
    writer.join();
    if (message.anchorId !== "0") {
      writer.uint32(48).int64(message.anchorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FansClubData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFansClubData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clubName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.level = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.userFansClubStatus = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.badge = FansClubData_UserBadge.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.availableGiftIds.push(reader.int64().toString());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.availableGiftIds.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.anchorId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<FansClubData>, I>>(base?: I): FansClubData {
    return FansClubData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FansClubData>, I>>(object: I): FansClubData {
    const message = createBaseFansClubData();
    message.clubName = object.clubName ?? "";
    message.level = object.level ?? 0;
    message.userFansClubStatus = object.userFansClubStatus ?? 0;
    message.badge = (object.badge !== undefined && object.badge !== null)
      ? FansClubData_UserBadge.fromPartial(object.badge)
      : undefined;
    message.availableGiftIds = object.availableGiftIds?.map((e) => e) || [];
    message.anchorId = object.anchorId ?? "0";
    return message;
  },
};

function createBaseFansClubData_UserBadge(): FansClubData_UserBadge {
  return { icons: {}, title: "" };
}

export const FansClubData_UserBadge: MessageFns<FansClubData_UserBadge> = {
  encode(message: FansClubData_UserBadge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.icons).forEach(([key, value]) => {
      FansClubData_UserBadge_IconsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FansClubData_UserBadge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFansClubData_UserBadge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = FansClubData_UserBadge_IconsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.icons[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<FansClubData_UserBadge>, I>>(base?: I): FansClubData_UserBadge {
    return FansClubData_UserBadge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FansClubData_UserBadge>, I>>(object: I): FansClubData_UserBadge {
    const message = createBaseFansClubData_UserBadge();
    message.icons = Object.entries(object.icons ?? {}).reduce<{ [key: number]: Image }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[globalThis.Number(key)] = Image.fromPartial(value);
      }
      return acc;
    }, {});
    message.title = object.title ?? "";
    return message;
  },
};

function createBaseFansClubData_UserBadge_IconsEntry(): FansClubData_UserBadge_IconsEntry {
  return { key: 0, value: undefined };
}

export const FansClubData_UserBadge_IconsEntry: MessageFns<FansClubData_UserBadge_IconsEntry> = {
  encode(message: FansClubData_UserBadge_IconsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== undefined) {
      Image.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FansClubData_UserBadge_IconsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFansClubData_UserBadge_IconsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<FansClubData_UserBadge_IconsEntry>, I>>(
    base?: I,
  ): FansClubData_UserBadge_IconsEntry {
    return FansClubData_UserBadge_IconsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FansClubData_UserBadge_IconsEntry>, I>>(
    object: I,
  ): FansClubData_UserBadge_IconsEntry {
    const message = createBaseFansClubData_UserBadge_IconsEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null) ? Image.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseAuthor(): Author {
  return { videoTotalCount: "0", videoTotalPlayCount: "0", videoTotalFavoriteCount: "0" };
}

export const Author: MessageFns<Author> = {
  encode(message: Author, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoTotalCount !== "0") {
      writer.uint32(8).int64(message.videoTotalCount);
    }
    if (message.videoTotalPlayCount !== "0") {
      writer.uint32(16).int64(message.videoTotalPlayCount);
    }
    if (message.videoTotalFavoriteCount !== "0") {
      writer.uint32(48).int64(message.videoTotalFavoriteCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Author {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.videoTotalCount = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.videoTotalPlayCount = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.videoTotalFavoriteCount = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Author>, I>>(base?: I): Author {
    return Author.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Author>, I>>(object: I): Author {
    const message = createBaseAuthor();
    message.videoTotalCount = object.videoTotalCount ?? "0";
    message.videoTotalPlayCount = object.videoTotalPlayCount ?? "0";
    message.videoTotalFavoriteCount = object.videoTotalFavoriteCount ?? "0";
    return message;
  },
};

function createBasePublicAreaCommon(): PublicAreaCommon {
  return { userLabel: undefined, userConsumeInRoom: "0" };
}

export const PublicAreaCommon: MessageFns<PublicAreaCommon> = {
  encode(message: PublicAreaCommon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userLabel !== undefined) {
      Image.encode(message.userLabel, writer.uint32(10).fork()).join();
    }
    if (message.userConsumeInRoom !== "0") {
      writer.uint32(16).int64(message.userConsumeInRoom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicAreaCommon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicAreaCommon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userLabel = Image.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.userConsumeInRoom = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<PublicAreaCommon>, I>>(base?: I): PublicAreaCommon {
    return PublicAreaCommon.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublicAreaCommon>, I>>(object: I): PublicAreaCommon {
    const message = createBasePublicAreaCommon();
    message.userLabel = (object.userLabel !== undefined && object.userLabel !== null)
      ? Image.fromPartial(object.userLabel)
      : undefined;
    message.userConsumeInRoom = object.userConsumeInRoom ?? "0";
    return message;
  },
};

function createBasePublicAreaMessageCommon(): PublicAreaMessageCommon {
  return {
    scrollGapCount: "0",
    anchorScrollGapCount: "0",
    releaseToScrollArea: false,
    anchorReleaseToScrollArea: false,
    isAnchorMarked: false,
    creatorSuccessInfo: undefined,
    portraitInfo: undefined,
    userInteractionInfo: undefined,
    adminFoldType: "0",
  };
}

export const PublicAreaMessageCommon: MessageFns<PublicAreaMessageCommon> = {
  encode(message: PublicAreaMessageCommon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scrollGapCount !== "0") {
      writer.uint32(8).int64(message.scrollGapCount);
    }
    if (message.anchorScrollGapCount !== "0") {
      writer.uint32(16).int64(message.anchorScrollGapCount);
    }
    if (message.releaseToScrollArea !== false) {
      writer.uint32(24).bool(message.releaseToScrollArea);
    }
    if (message.anchorReleaseToScrollArea !== false) {
      writer.uint32(32).bool(message.anchorReleaseToScrollArea);
    }
    if (message.isAnchorMarked !== false) {
      writer.uint32(40).bool(message.isAnchorMarked);
    }
    if (message.creatorSuccessInfo !== undefined) {
      PublicAreaMessageCommon_CreatorSuccessInfo.encode(message.creatorSuccessInfo, writer.uint32(50).fork()).join();
    }
    if (message.portraitInfo !== undefined) {
      PublicAreaMessageCommon_PortraitInfo.encode(message.portraitInfo, writer.uint32(58).fork()).join();
    }
    if (message.userInteractionInfo !== undefined) {
      PublicAreaMessageCommon_UserInteractionInfo.encode(message.userInteractionInfo, writer.uint32(66).fork()).join();
    }
    if (message.adminFoldType !== "0") {
      writer.uint32(72).int64(message.adminFoldType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicAreaMessageCommon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicAreaMessageCommon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.scrollGapCount = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.anchorScrollGapCount = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.releaseToScrollArea = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.anchorReleaseToScrollArea = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isAnchorMarked = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.creatorSuccessInfo = PublicAreaMessageCommon_CreatorSuccessInfo.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.portraitInfo = PublicAreaMessageCommon_PortraitInfo.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.userInteractionInfo = PublicAreaMessageCommon_UserInteractionInfo.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.adminFoldType = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<PublicAreaMessageCommon>, I>>(base?: I): PublicAreaMessageCommon {
    return PublicAreaMessageCommon.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublicAreaMessageCommon>, I>>(object: I): PublicAreaMessageCommon {
    const message = createBasePublicAreaMessageCommon();
    message.scrollGapCount = object.scrollGapCount ?? "0";
    message.anchorScrollGapCount = object.anchorScrollGapCount ?? "0";
    message.releaseToScrollArea = object.releaseToScrollArea ?? false;
    message.anchorReleaseToScrollArea = object.anchorReleaseToScrollArea ?? false;
    message.isAnchorMarked = object.isAnchorMarked ?? false;
    message.creatorSuccessInfo = (object.creatorSuccessInfo !== undefined && object.creatorSuccessInfo !== null)
      ? PublicAreaMessageCommon_CreatorSuccessInfo.fromPartial(object.creatorSuccessInfo)
      : undefined;
    message.portraitInfo = (object.portraitInfo !== undefined && object.portraitInfo !== null)
      ? PublicAreaMessageCommon_PortraitInfo.fromPartial(object.portraitInfo)
      : undefined;
    message.userInteractionInfo = (object.userInteractionInfo !== undefined && object.userInteractionInfo !== null)
      ? PublicAreaMessageCommon_UserInteractionInfo.fromPartial(object.userInteractionInfo)
      : undefined;
    message.adminFoldType = object.adminFoldType ?? "0";
    return message;
  },
};

function createBasePublicAreaMessageCommon_TagItem(): PublicAreaMessageCommon_TagItem {
  return { tagType: 0, tagText: undefined };
}

export const PublicAreaMessageCommon_TagItem: MessageFns<PublicAreaMessageCommon_TagItem> = {
  encode(message: PublicAreaMessageCommon_TagItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tagType !== 0) {
      writer.uint32(8).int32(message.tagType);
    }
    if (message.tagText !== undefined) {
      Text.encode(message.tagText, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicAreaMessageCommon_TagItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicAreaMessageCommon_TagItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tagType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tagText = Text.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<PublicAreaMessageCommon_TagItem>, I>>(base?: I): PublicAreaMessageCommon_TagItem {
    return PublicAreaMessageCommon_TagItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublicAreaMessageCommon_TagItem>, I>>(
    object: I,
  ): PublicAreaMessageCommon_TagItem {
    const message = createBasePublicAreaMessageCommon_TagItem();
    message.tagType = object.tagType ?? 0;
    message.tagText = (object.tagText !== undefined && object.tagText !== null)
      ? Text.fromPartial(object.tagText)
      : undefined;
    return message;
  },
};

function createBasePublicAreaMessageCommon_Topic(): PublicAreaMessageCommon_Topic {
  return { topicActionType: 0, topicText: undefined, topicTips: undefined };
}

export const PublicAreaMessageCommon_Topic: MessageFns<PublicAreaMessageCommon_Topic> = {
  encode(message: PublicAreaMessageCommon_Topic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicActionType !== 0) {
      writer.uint32(8).int32(message.topicActionType);
    }
    if (message.topicText !== undefined) {
      Text.encode(message.topicText, writer.uint32(18).fork()).join();
    }
    if (message.topicTips !== undefined) {
      Text.encode(message.topicTips, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicAreaMessageCommon_Topic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicAreaMessageCommon_Topic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.topicActionType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.topicText = Text.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.topicTips = Text.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<PublicAreaMessageCommon_Topic>, I>>(base?: I): PublicAreaMessageCommon_Topic {
    return PublicAreaMessageCommon_Topic.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublicAreaMessageCommon_Topic>, I>>(
    object: I,
  ): PublicAreaMessageCommon_Topic {
    const message = createBasePublicAreaMessageCommon_Topic();
    message.topicActionType = object.topicActionType ?? 0;
    message.topicText = (object.topicText !== undefined && object.topicText !== null)
      ? Text.fromPartial(object.topicText)
      : undefined;
    message.topicTips = (object.topicTips !== undefined && object.topicTips !== null)
      ? Text.fromPartial(object.topicTips)
      : undefined;
    return message;
  },
};

function createBasePublicAreaMessageCommon_CreatorSuccessInfo(): PublicAreaMessageCommon_CreatorSuccessInfo {
  return { tags: [], topic: undefined };
}

export const PublicAreaMessageCommon_CreatorSuccessInfo: MessageFns<PublicAreaMessageCommon_CreatorSuccessInfo> = {
  encode(message: PublicAreaMessageCommon_CreatorSuccessInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tags) {
      PublicAreaMessageCommon_TagItem.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.topic !== undefined) {
      PublicAreaMessageCommon_Topic.encode(message.topic, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicAreaMessageCommon_CreatorSuccessInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicAreaMessageCommon_CreatorSuccessInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tags.push(PublicAreaMessageCommon_TagItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.topic = PublicAreaMessageCommon_Topic.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<PublicAreaMessageCommon_CreatorSuccessInfo>, I>>(
    base?: I,
  ): PublicAreaMessageCommon_CreatorSuccessInfo {
    return PublicAreaMessageCommon_CreatorSuccessInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublicAreaMessageCommon_CreatorSuccessInfo>, I>>(
    object: I,
  ): PublicAreaMessageCommon_CreatorSuccessInfo {
    const message = createBasePublicAreaMessageCommon_CreatorSuccessInfo();
    message.tags = object.tags?.map((e) => PublicAreaMessageCommon_TagItem.fromPartial(e)) || [];
    message.topic = (object.topic !== undefined && object.topic !== null)
      ? PublicAreaMessageCommon_Topic.fromPartial(object.topic)
      : undefined;
    return message;
  },
};

function createBasePublicAreaMessageCommon_UserMetrics(): PublicAreaMessageCommon_UserMetrics {
  return { type: 0, metricsValue: "" };
}

export const PublicAreaMessageCommon_UserMetrics: MessageFns<PublicAreaMessageCommon_UserMetrics> = {
  encode(message: PublicAreaMessageCommon_UserMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.metricsValue !== "") {
      writer.uint32(18).string(message.metricsValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicAreaMessageCommon_UserMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicAreaMessageCommon_UserMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metricsValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<PublicAreaMessageCommon_UserMetrics>, I>>(
    base?: I,
  ): PublicAreaMessageCommon_UserMetrics {
    return PublicAreaMessageCommon_UserMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublicAreaMessageCommon_UserMetrics>, I>>(
    object: I,
  ): PublicAreaMessageCommon_UserMetrics {
    const message = createBasePublicAreaMessageCommon_UserMetrics();
    message.type = object.type ?? 0;
    message.metricsValue = object.metricsValue ?? "";
    return message;
  },
};

function createBasePublicAreaMessageCommon_PortraitTag(): PublicAreaMessageCommon_PortraitTag {
  return { tagId: "", priority: "0", showValue: "", showArgs: "" };
}

export const PublicAreaMessageCommon_PortraitTag: MessageFns<PublicAreaMessageCommon_PortraitTag> = {
  encode(message: PublicAreaMessageCommon_PortraitTag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tagId !== "") {
      writer.uint32(10).string(message.tagId);
    }
    if (message.priority !== "0") {
      writer.uint32(16).int64(message.priority);
    }
    if (message.showValue !== "") {
      writer.uint32(26).string(message.showValue);
    }
    if (message.showArgs !== "") {
      writer.uint32(34).string(message.showArgs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicAreaMessageCommon_PortraitTag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicAreaMessageCommon_PortraitTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tagId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.priority = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.showValue = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.showArgs = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<PublicAreaMessageCommon_PortraitTag>, I>>(
    base?: I,
  ): PublicAreaMessageCommon_PortraitTag {
    return PublicAreaMessageCommon_PortraitTag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublicAreaMessageCommon_PortraitTag>, I>>(
    object: I,
  ): PublicAreaMessageCommon_PortraitTag {
    const message = createBasePublicAreaMessageCommon_PortraitTag();
    message.tagId = object.tagId ?? "";
    message.priority = object.priority ?? "0";
    message.showValue = object.showValue ?? "";
    message.showArgs = object.showArgs ?? "";
    return message;
  },
};

function createBasePublicAreaMessageCommon_PortraitInfo(): PublicAreaMessageCommon_PortraitInfo {
  return { userMetrics: [], portraitTag: [] };
}

export const PublicAreaMessageCommon_PortraitInfo: MessageFns<PublicAreaMessageCommon_PortraitInfo> = {
  encode(message: PublicAreaMessageCommon_PortraitInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.userMetrics) {
      PublicAreaMessageCommon_UserMetrics.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.portraitTag) {
      PublicAreaMessageCommon_PortraitTag.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicAreaMessageCommon_PortraitInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicAreaMessageCommon_PortraitInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userMetrics.push(PublicAreaMessageCommon_UserMetrics.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.portraitTag.push(PublicAreaMessageCommon_PortraitTag.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<PublicAreaMessageCommon_PortraitInfo>, I>>(
    base?: I,
  ): PublicAreaMessageCommon_PortraitInfo {
    return PublicAreaMessageCommon_PortraitInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublicAreaMessageCommon_PortraitInfo>, I>>(
    object: I,
  ): PublicAreaMessageCommon_PortraitInfo {
    const message = createBasePublicAreaMessageCommon_PortraitInfo();
    message.userMetrics = object.userMetrics?.map((e) => PublicAreaMessageCommon_UserMetrics.fromPartial(e)) || [];
    message.portraitTag = object.portraitTag?.map((e) => PublicAreaMessageCommon_PortraitTag.fromPartial(e)) || [];
    return message;
  },
};

function createBasePublicAreaMessageCommon_UserInteractionInfo(): PublicAreaMessageCommon_UserInteractionInfo {
  return { likeCnt: "0", commentCnt: "0", shareCnt: "0" };
}

export const PublicAreaMessageCommon_UserInteractionInfo: MessageFns<PublicAreaMessageCommon_UserInteractionInfo> = {
  encode(
    message: PublicAreaMessageCommon_UserInteractionInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.likeCnt !== "0") {
      writer.uint32(8).int64(message.likeCnt);
    }
    if (message.commentCnt !== "0") {
      writer.uint32(16).int64(message.commentCnt);
    }
    if (message.shareCnt !== "0") {
      writer.uint32(24).int64(message.shareCnt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicAreaMessageCommon_UserInteractionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicAreaMessageCommon_UserInteractionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.likeCnt = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.commentCnt = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.shareCnt = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<PublicAreaMessageCommon_UserInteractionInfo>, I>>(
    base?: I,
  ): PublicAreaMessageCommon_UserInteractionInfo {
    return PublicAreaMessageCommon_UserInteractionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublicAreaMessageCommon_UserInteractionInfo>, I>>(
    object: I,
  ): PublicAreaMessageCommon_UserInteractionInfo {
    const message = createBasePublicAreaMessageCommon_UserInteractionInfo();
    message.likeCnt = object.likeCnt ?? "0";
    message.commentCnt = object.commentCnt ?? "0";
    message.shareCnt = object.shareCnt ?? "0";
    return message;
  },
};

function createBaseGiftModeMeta(): GiftModeMeta {
  return { giftId: "0", giftNameKey: "", giftIconImage: undefined, giftModeDesc: undefined };
}

export const GiftModeMeta: MessageFns<GiftModeMeta> = {
  encode(message: GiftModeMeta, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftId !== "0") {
      writer.uint32(8).int64(message.giftId);
    }
    if (message.giftNameKey !== "") {
      writer.uint32(18).string(message.giftNameKey);
    }
    if (message.giftIconImage !== undefined) {
      Image.encode(message.giftIconImage, writer.uint32(26).fork()).join();
    }
    if (message.giftModeDesc !== undefined) {
      Text.encode(message.giftModeDesc, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GiftModeMeta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGiftModeMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.giftId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.giftNameKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.giftIconImage = Image.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.giftModeDesc = Text.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<GiftModeMeta>, I>>(base?: I): GiftModeMeta {
    return GiftModeMeta.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GiftModeMeta>, I>>(object: I): GiftModeMeta {
    const message = createBaseGiftModeMeta();
    message.giftId = object.giftId ?? "0";
    message.giftNameKey = object.giftNameKey ?? "";
    message.giftIconImage = (object.giftIconImage !== undefined && object.giftIconImage !== null)
      ? Image.fromPartial(object.giftIconImage)
      : undefined;
    message.giftModeDesc = (object.giftModeDesc !== undefined && object.giftModeDesc !== null)
      ? Text.fromPartial(object.giftModeDesc)
      : undefined;
    return message;
  },
};

function createBaseBattleTeamUser(): BattleTeamUser {
  return { userId: "0", score: "0", userIdStr: "" };
}

export const BattleTeamUser: MessageFns<BattleTeamUser> = {
  encode(message: BattleTeamUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.score !== "0") {
      writer.uint32(16).int64(message.score);
    }
    if (message.userIdStr !== "") {
      writer.uint32(26).string(message.userIdStr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BattleTeamUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleTeamUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.score = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userIdStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BattleTeamUser>, I>>(base?: I): BattleTeamUser {
    return BattleTeamUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BattleTeamUser>, I>>(object: I): BattleTeamUser {
    const message = createBaseBattleTeamUser();
    message.userId = object.userId ?? "0";
    message.score = object.score ?? "0";
    message.userIdStr = object.userIdStr ?? "";
    return message;
  },
};

function createBaseBattleSetting(): BattleSetting {
  return {
    battleId: "0",
    startTimeMs: "0",
    duration: 0,
    channelId: "0",
    status: 0,
    inviteType: 0,
    giftModeMeta: undefined,
    battleType: 0,
    extraDurationSecond: "0",
    endTimeMs: "0",
  };
}

export const BattleSetting: MessageFns<BattleSetting> = {
  encode(message: BattleSetting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.battleId !== "0") {
      writer.uint32(8).int64(message.battleId);
    }
    if (message.startTimeMs !== "0") {
      writer.uint32(16).int64(message.startTimeMs);
    }
    if (message.duration !== 0) {
      writer.uint32(24).int32(message.duration);
    }
    if (message.channelId !== "0") {
      writer.uint32(32).int64(message.channelId);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.inviteType !== 0) {
      writer.uint32(48).int32(message.inviteType);
    }
    if (message.giftModeMeta !== undefined) {
      GiftModeMeta.encode(message.giftModeMeta, writer.uint32(58).fork()).join();
    }
    if (message.battleType !== 0) {
      writer.uint32(64).int32(message.battleType);
    }
    if (message.extraDurationSecond !== "0") {
      writer.uint32(72).int64(message.extraDurationSecond);
    }
    if (message.endTimeMs !== "0") {
      writer.uint32(80).int64(message.endTimeMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BattleSetting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleSetting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.battleId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.startTimeMs = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.duration = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.channelId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.inviteType = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.giftModeMeta = GiftModeMeta.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.battleType = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.extraDurationSecond = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.endTimeMs = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BattleSetting>, I>>(base?: I): BattleSetting {
    return BattleSetting.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BattleSetting>, I>>(object: I): BattleSetting {
    const message = createBaseBattleSetting();
    message.battleId = object.battleId ?? "0";
    message.startTimeMs = object.startTimeMs ?? "0";
    message.duration = object.duration ?? 0;
    message.channelId = object.channelId ?? "0";
    message.status = object.status ?? 0;
    message.inviteType = object.inviteType ?? 0;
    message.giftModeMeta = (object.giftModeMeta !== undefined && object.giftModeMeta !== null)
      ? GiftModeMeta.fromPartial(object.giftModeMeta)
      : undefined;
    message.battleType = object.battleType ?? 0;
    message.extraDurationSecond = object.extraDurationSecond ?? "0";
    message.endTimeMs = object.endTimeMs ?? "0";
    return message;
  },
};

function createBaseBattleTeamUserArmies(): BattleTeamUserArmies {
  return { teamId: "0", teamUsers: [], teamTotalScore: "0", userArmies: undefined, hostRank: "0" };
}

export const BattleTeamUserArmies: MessageFns<BattleTeamUserArmies> = {
  encode(message: BattleTeamUserArmies, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.teamId !== "0") {
      writer.uint32(8).int64(message.teamId);
    }
    for (const v of message.teamUsers) {
      BattleTeamUser.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.teamTotalScore !== "0") {
      writer.uint32(24).int64(message.teamTotalScore);
    }
    if (message.userArmies !== undefined) {
      BattleUserArmies.encode(message.userArmies, writer.uint32(34).fork()).join();
    }
    if (message.hostRank !== "0") {
      writer.uint32(40).int64(message.hostRank);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BattleTeamUserArmies {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleTeamUserArmies();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.teamId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.teamUsers.push(BattleTeamUser.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.teamTotalScore = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userArmies = BattleUserArmies.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.hostRank = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BattleTeamUserArmies>, I>>(base?: I): BattleTeamUserArmies {
    return BattleTeamUserArmies.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BattleTeamUserArmies>, I>>(object: I): BattleTeamUserArmies {
    const message = createBaseBattleTeamUserArmies();
    message.teamId = object.teamId ?? "0";
    message.teamUsers = object.teamUsers?.map((e) => BattleTeamUser.fromPartial(e)) || [];
    message.teamTotalScore = object.teamTotalScore ?? "0";
    message.userArmies = (object.userArmies !== undefined && object.userArmies !== null)
      ? BattleUserArmies.fromPartial(object.userArmies)
      : undefined;
    message.hostRank = object.hostRank ?? "0";
    return message;
  },
};

function createBaseBattleUserArmies(): BattleUserArmies {
  return { userArmy: [], hostScore: "0", anchorIdStr: "" };
}

export const BattleUserArmies: MessageFns<BattleUserArmies> = {
  encode(message: BattleUserArmies, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.userArmy) {
      BattleUserArmy.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.hostScore !== "0") {
      writer.uint32(16).int64(message.hostScore);
    }
    if (message.anchorIdStr !== "") {
      writer.uint32(26).string(message.anchorIdStr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BattleUserArmies {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleUserArmies();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userArmy.push(BattleUserArmy.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.hostScore = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.anchorIdStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BattleUserArmies>, I>>(base?: I): BattleUserArmies {
    return BattleUserArmies.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BattleUserArmies>, I>>(object: I): BattleUserArmies {
    const message = createBaseBattleUserArmies();
    message.userArmy = object.userArmy?.map((e) => BattleUserArmy.fromPartial(e)) || [];
    message.hostScore = object.hostScore ?? "0";
    message.anchorIdStr = object.anchorIdStr ?? "";
    return message;
  },
};

function createBaseBattleUserArmy(): BattleUserArmy {
  return { userId: "0", score: "0", nickname: "", avatarThumb: undefined, diamondScore: "0", userIdStr: "" };
}

export const BattleUserArmy: MessageFns<BattleUserArmy> = {
  encode(message: BattleUserArmy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.score !== "0") {
      writer.uint32(16).int64(message.score);
    }
    if (message.nickname !== "") {
      writer.uint32(26).string(message.nickname);
    }
    if (message.avatarThumb !== undefined) {
      Image.encode(message.avatarThumb, writer.uint32(34).fork()).join();
    }
    if (message.diamondScore !== "0") {
      writer.uint32(40).int64(message.diamondScore);
    }
    if (message.userIdStr !== "") {
      writer.uint32(50).string(message.userIdStr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BattleUserArmy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleUserArmy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.score = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.avatarThumb = Image.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.diamondScore = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.userIdStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<BattleUserArmy>, I>>(base?: I): BattleUserArmy {
    return BattleUserArmy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BattleUserArmy>, I>>(object: I): BattleUserArmy {
    const message = createBaseBattleUserArmy();
    message.userId = object.userId ?? "0";
    message.score = object.score ?? "0";
    message.nickname = object.nickname ?? "";
    message.avatarThumb = (object.avatarThumb !== undefined && object.avatarThumb !== null)
      ? Image.fromPartial(object.avatarThumb)
      : undefined;
    message.diamondScore = object.diamondScore ?? "0";
    message.userIdStr = object.userIdStr ?? "";
    return message;
  },
};

function createBaseHighScoreControlCfg(): HighScoreControlCfg {
  return { normalControlApplied: false, threshold: "0", originDisplayToUserList: [] };
}

export const HighScoreControlCfg: MessageFns<HighScoreControlCfg> = {
  encode(message: HighScoreControlCfg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.normalControlApplied !== false) {
      writer.uint32(8).bool(message.normalControlApplied);
    }
    if (message.threshold !== "0") {
      writer.uint32(16).int64(message.threshold);
    }
    writer.uint32(26).fork();
    for (const v of message.originDisplayToUserList) {
      writer.int64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HighScoreControlCfg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHighScoreControlCfg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.normalControlApplied = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.threshold = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.originDisplayToUserList.push(reader.int64().toString());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.originDisplayToUserList.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<HighScoreControlCfg>, I>>(base?: I): HighScoreControlCfg {
    return HighScoreControlCfg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HighScoreControlCfg>, I>>(object: I): HighScoreControlCfg {
    const message = createBaseHighScoreControlCfg();
    message.normalControlApplied = object.normalControlApplied ?? false;
    message.threshold = object.threshold ?? "0";
    message.originDisplayToUserList = object.originDisplayToUserList?.map((e) => e) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

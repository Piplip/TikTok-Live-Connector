// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.27.1
// source: webcast.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  ApplyContent,
  BadgeStruct,
  BattleSetting,
  BattleTeamUser,
  BattleTeamUserArmies,
  BattleUserArmies,
  BusinessContent,
  CancelApplyContent,
  CancelInviteContent,
  CancelJoinGroupContent,
  CohostListChangeContent,
  CommonMessageData,
  CreateChannelContent,
  Emote,
  FanTicketRoomNoticeContent,
  FinishChannelContent,
  Gift,
  GroupChangeContent,
  HighScoreControlCfg,
  Image,
  InviteContent,
  JoinDirectContent,
  JoinGroupContent,
  KickOutContent,
  LeaveContent,
  LeaveJoinGroupContent,
  LinkerAcceptNoticeContent,
  LinkerCancelContent,
  LinkerCloseContent,
  LinkerCreateContent,
  LinkerEnterContent,
  LinkerInviteContent,
  LinkerKickOutContent,
  LinkerLeaveContent,
  LinkerLinkedListChangeContent,
  LinkerListChangeContent,
  LinkerMediaChangeContent,
  LinkerMicIdxUpdateContent,
  LinkerMuteContent,
  LinkerRandomMatchContent,
  LinkerReplyContent,
  LinkerSysKickOutContent,
  LinkerUpdateUserContent,
  LinkerUpdateUserSettingContent,
  LinkerWaitingListChangeContent,
  LinkmicUserToastContent,
  ListChangeContent,
  LiveStreamGoal,
  LiveStreamGoalIndicator,
  MsgFilter,
  P2PGroupChangeContent,
  PermitApplyContent,
  PermitJoinGroupContent,
  PollEndContent,
  PollStartContent,
  PollUpdateVotesContent,
  PrivilegeLogExtra,
  PublicAreaCommon,
  PublicAreaMessageCommon,
  PunishEventInfo,
  Ranking,
  ReplyInviteContent,
  Text,
  TimeStampContainer,
  User,
  UserIdentity,
  ValueLabel,
} from "./data";
import {
  AuditStatus,
  BattleABTestType,
  BattleAction,
  BattleTaskMessageType,
  ControlAction,
  EnvelopeBusinessType,
  EnvelopeDisplay,
  EnvelopeFollowShowStatus,
  ExhibitionType,
  GiftMessageIgnoreConfig,
  GiftMessageVersion,
  GiftPermissionType,
  GiftSource,
  GoalMessageSource,
  HorizontalOnclickTriggerType,
  LinkMessageType,
  LinkmicGiftExpressionStrategy,
  MemberMessageAction,
  MessageDisplayStyle,
  MessageType,
  MultiplierType,
  OldSubscribeStatus,
  PerceptionDialogIconType,
  PollAppealStatus,
  PollKind,
  PollTemplateStatus,
  ProfitRankType,
  RankTestMessageScene,
  Reason,
  Result,
  RewardStatus,
  Scene,
  SubscribeType,
  SubscribingStatus,
  TriggerReason,
  UnionAnimationInfoType,
} from "./enums";

export const protobufPackage = "";

export interface Message {
  type: string;
  binary: Uint8Array;
}

export interface WebsocketParam {
  name: string;
  value: string;
}

export interface WebcastRoomUserSeqMessage {
  common: CommonMessageData | undefined;
  viewerCount: number;
  ranksList: WebcastRoomUserSeqMessage_Contributor[];
  popStr: string;
  seatsList: WebcastRoomUserSeqMessage_Contributor[];
  popularity: string;
  totalUser: number;
  anonymous: string;
}

export interface WebcastRoomUserSeqMessage_Contributor {
  coinCount: number;
  user: User | undefined;
  rank: number;
  delta: string;
}

export interface ImageModel {
  mUrls: string[];
  mUri: string;
  height: number;
  width: number;
  avgColor: string;
  imageType: number;
  schema: string;
  content: ImageModel_Content | undefined;
  isAnimated: boolean;
}

export interface ImageModel_Content {
  name: string;
  fontColor: string;
  level: string;
}

export interface WebcastChatMessage {
  common: CommonMessageData | undefined;
  user: User | undefined;
  comment: string;
  visibleToSender: boolean;
  background: ImageModel | undefined;
  fullScreenTextColor: string;
  backgroundImageV2: ImageModel | undefined;
  publicAreaCommon: PublicAreaCommon | undefined;
  giftImage: ImageModel | undefined;
  inputType: number;
  atUser: User | undefined;
  emotes: WebcastSubEmote[];
  contentLanguage: string;
  msgFilter: MsgFilter | undefined;
  quickChatScene: number;
  communityflaggedStatus: number;
  commentQualityScores: WebcastChatMessage_CommentQualityScore[];
  userIdentity: WebcastChatMessage_UserIdentity | undefined;
  commentTag: WebcastChatMessage_CommentTag[];
  publicAreaMessageCommon: PublicAreaMessageCommon | undefined;
  screenTime: string;
  signature: string;
  signatureVersion: string;
  ecStreamerKey: string;
}

export enum WebcastChatMessage_CommentTag {
  COMMENT_TAG_NORMAL = 0,
  COMMENT_TAG_CANDIDATE = 1,
  COMMENT_TAG_OVERAGE = 2,
  UNRECOGNIZED = -1,
}

export interface WebcastChatMessage_UserIdentity {
  isGiftGiverOfAnchor: boolean;
  isSubscriberOfAnchor: boolean;
  isMutualFollowingWithAnchor: boolean;
  isFollowerOfAnchor: boolean;
  isModeratorOfAnchor: boolean;
  isAnchor: boolean;
}

export interface WebcastChatMessage_CommentQualityScore {
  version: string;
  score: string;
}

export interface EmoteUploadInfo {
  userId: string;
  emoteUploadSource?: EmoteUploadInfo_UserEmoteUploadSource | undefined;
  userInfo: User | undefined;
  userIdStr: string;
}

export enum EmoteUploadInfo_UserEmoteUploadSource {
  USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_ANCHOR = 0,
  USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_SUBSCRIBER = 1,
  USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_MODERATOR = 2,
  UNRECOGNIZED = -1,
}

/** Chat Emotes (Subscriber) */
export interface WebcastEmoteChatMessage {
  common: CommonMessageData | undefined;
  user: User | undefined;
  emoteList: Emote[];
  msgFilter: MsgFilter | undefined;
  userIdentity: UserIdentity | undefined;
}

export interface WebcastSubEmote {
  /** starting at 0, you insert the emote itself into the comment at that place */
  placeInComment: number;
  emote: EmoteDetails | undefined;
}

export interface WebcastMemberMessage {
  common: CommonMessageData | undefined;
  user: User | undefined;
  action: MemberMessageAction;
  memberCount: number;
  operator: User | undefined;
  isSetToAdmin: boolean;
  isTopUser: boolean;
  rankScore: string;
  topUserNo: string;
  enterType: string;
  actionDescription: string;
  userId: string;
  effectConfig: WebcastMemberMessage_EffectConfig | undefined;
  popStr: string;
  enterEffectConfig: WebcastMemberMessage_EffectConfig | undefined;
  backgroundImage: Image | undefined;
  backgroundImageV2: Image | undefined;
  anchorDisplayText: Text | undefined;
  clientEnterSource: string;
  clientEnterType: string;
  clientLiveReason: string;
  actionDuration: string;
  userShareType: string;
  displayStyle: WebcastMemberMessage_DisplayStyle;
  adminPermissions: { [key: number]: number };
  kickSource: number;
  allowPreviewTime: string;
  lastSubscriptionAction: string;
  publicAreaMessageCommon: PublicAreaMessageCommon | undefined;
  liveSubOnlyTier: string;
  liveSubOnlyMonth: string;
  ecStreamerKey: string;
  showWave: string;
  waveAlgorithmData: WebcastMemberMessage_WaveAlgorithmData | undefined;
  hitAbStatus: WebcastMemberMessage_HitABStatus;
}

export enum WebcastMemberMessage_DisplayStyle {
  DISPLAY_STYLE_NORMAL = 0,
  DISPLAY_STYLE_STAY = 1,
  DISPLAY_STYLE_CHAT = 2,
  UNRECOGNIZED = -1,
}

export enum WebcastMemberMessage_HitABStatus {
  HIT_A_B_STATUS_HIT_AB_STATUS_NO_HIT = 0,
  HIT_A_B_STATUS_HIT_AB_STATUS_ENTER_FROM_EXTERNAL_LINK_NEW_TEXT = 1,
  HIT_A_B_STATUS_HIT_AB_STATUS_ENTER_FROM_RE_POST_NEW_TEXT = 2,
  UNRECOGNIZED = -1,
}

export interface WebcastMemberMessage_AdminPermissionsEntry {
  key: number;
  value: number;
}

/**
 * @EffectConfig
 * proto.webcast.im.MemberMessage
 * C:\Users\ja\RiderProjects\TikTokProBufferGenerator\Application\output\sources\test.js
 */
export interface WebcastMemberMessage_EffectConfig {
  type: string;
  icon: Image | undefined;
  avatarPos: string;
  text: Text | undefined;
  textIcon: Image | undefined;
  stayTime: number;
  animAssetId: string;
  badge: Image | undefined;
  flexSettingArrayList: string[];
}

export interface WebcastMemberMessage_WaveAlgorithmData {
  algorithmVersion: string;
  isAlgHit: boolean;
  predictScore: string;
  isRewatch: boolean;
  isFollow: boolean;
}

export interface WebcastMemberMessage_EffectConfigBean {
  type: number;
  icon: ImageModel | undefined;
  textKey: Text | undefined;
  badge: ImageModel | undefined;
}

export interface WebcastGiftMessage {
  common: CommonMessageData | undefined;
  giftId: number;
  user: User | undefined;
  repeatEnd: number;
  groupId: string;
  giftDetails: Gift | undefined;
  monitorExtra: string;
  fanTicketCount: string;
  groupCount: number;
  repeatCount: number;
  comboCount: number;
  toUser: User | undefined;
  textEffect: WebcastGiftMessage_TextEffect | undefined;
  incomeTaskgifts: string;
  roomFanTicketCount: string;
  priority: WebcastGiftMessage_GiftIMPriority | undefined;
  logId: string;
  sendType: string;
  publicAreaCommon: PublicAreaCommon | undefined;
  trayDisplayText: Text | undefined;
  bannedDisplayEffects: string;
  mTrayInfo: WebcastGiftMessage_GiftTrayInfo | undefined;
  giftExtra: WebcastGiftMessage_GiftMonitorInfo | undefined;
  colorId: string;
  isFirstSent: boolean;
  displayTextForAnchor: Text | undefined;
  displayTextForAudience: Text | undefined;
  orderId: string;
  giftsInBox: WebcastGiftMessage_GiftsBoxInfo | undefined;
  msgFilter: MsgFilter | undefined;
  lynxExtra: WebcastGiftMessage_LynxGiftExtra[];
  userIdentity: UserIdentity | undefined;
  matchInfo: WebcastGiftMessage_MatchInfo | undefined;
  linkmicGiftExpressionStrategy: LinkmicGiftExpressionStrategy;
  flyingMicResources: WebcastGiftMessage_FlyingMicResources | undefined;
  disableGiftTracking: boolean;
  asset: WebcastGiftMessage_AssetsModel | undefined;
  version: GiftMessageVersion;
  sponsorshipInfo: WebcastGiftMessage_SponsorshipInfo[];
  flyingMicResourcesV2: WebcastGiftMessage_FlyingMicResources | undefined;
  publicAreaMessageCommon: PublicAreaMessageCommon | undefined;
  signature: string;
  signatureVersion: string;
  multiGenerateMessage: boolean;
  toMemberId: string;
  toMemberIdInt: string;
  toMemberNickname: string;
  interactiveGiftInfo: WebcastGiftMessage_InteractiveGiftInfo | undefined;
}

export interface WebcastGiftMessage_InteractiveGiftInfo {
  crossScreenDelay: string;
  crossScreenRole: string;
  ignoreConfig: GiftMessageIgnoreConfig;
  uniqId: string;
  toUserTeamId: string;
}

export interface WebcastGiftMessage_GiftIMPriority {
  queueSizesList: string[];
  selfQueuePriority: string;
  priority: string;
}

export interface WebcastGiftMessage_TextEffect {
  portraitDetail: WebcastGiftMessage_TextEffect_Detail | undefined;
  landscapeDetail: WebcastGiftMessage_TextEffect_Detail | undefined;
}

export interface WebcastGiftMessage_TextEffect_Detail {
  text: Text | undefined;
  textFontSize: number;
  background: Image | undefined;
  start: string;
  duration: string;
  x: number;
  y: number;
  width: number;
  height: number;
  shadowDx: number;
  shadowDy: number;
  shadowRadius: number;
  shadowColor: string;
  strokeColor: string;
  strokeWidth: number;
}

export interface WebcastGiftMessage_GiftTrayInfo {
  mDynamicImg: Image | undefined;
  canMirror: boolean;
  trayNormalBgImg: Image | undefined;
  trayNormalBgColor: string[];
  traySmallBgImg: Image | undefined;
  traySmallBgColor: string[];
  rightTagText: Text | undefined;
  rightTagBgImg: Image | undefined;
  rightTagBgColor: string[];
  trayNameTextColor: string;
  trayDescTextColor: string;
  rightTagJumpSchema: string;
}

export interface WebcastGiftMessage_GiftMonitorInfo {
  anchorId: string;
  profitApiMessageDur: string;
  sendGiftProfitApiStartMs: string;
  sendGiftProfitCoreStartMs: string;
  sendGiftReqStartMs: string;
  sendGiftSendMessageSuccessMs: string;
  sendProfitApiDur: string;
  toUserId: string;
  sendGiftStartClientLocalMs: string;
  fromPlatform: string;
  fromVersion: string;
}

export interface WebcastGiftMessage_MatchInfo {
  critical: string;
  effectCardInUse: boolean;
  multiplierType: MultiplierType;
  multiplierValue: string;
}

export interface WebcastGiftMessage_GiftsBoxInfo {
  gifts: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox[];
}

export interface WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox {
  giftId: string;
  effectId: string;
  colorId: string;
  remainTimes: number;
  asset: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel | undefined;
}

export interface WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel {
  name: string;
  resourceUri: string;
  resourceModel: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel | undefined;
  describe: string;
  id: string;
  resourceType: number;
  md5: string;
  size: string;
  lokiExtraContent: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent | undefined;
  downloadType: number;
  resourceByteVC1Model: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel | undefined;
  bytevc1Md5: string;
  videoResourceList: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource[];
  faceRecognitionArchiveMeta: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta | undefined;
  lynxUrlSettingsKey: string;
  downgradeResourceType: number;
  assetExtra: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra | undefined;
  stickerAssetVariant: number;
  immediateDownload: boolean;
  stickerAssetVariantReason: number;
}

export interface WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra {
  effectStarlingKey: string;
}

export interface WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel {
  urlList: string[];
  uri: string;
}

export interface WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent {
  giftType: string;
  giftDuration: string;
  needScreenShot: boolean;
  ismultiFrame: boolean;
  viewOverlay: string;
  befViewRenderSize:
    | WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize
    | undefined;
  befViewRenderFPS: number;
  befViewFitMode: number;
  modelNames: string;
  requirements: string[];
}

export interface WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize {
  with: number;
  height: number;
}

export interface WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource {
  videoTypeName: string;
  videoUrl: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel | undefined;
  videoMd5: string;
}

export interface WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta {
  version: string;
  requirements: string[];
  modelNames: string;
  sdkExtra: string;
}

export interface WebcastGiftMessage_AssetsModel {
  name: string;
  resourceUri: string;
  resourceModel: WebcastGiftMessage_AssetsModel_ResourceModel | undefined;
  describe: string;
  id: string;
  resourceType: number;
  md5: string;
  size: string;
  lokiExtraContent: WebcastGiftMessage_AssetsModel_LokiExtraContent | undefined;
  downloadType: number;
  resourceByteVC1Model: WebcastGiftMessage_AssetsModel_ResourceModel | undefined;
  bytevc1Md5: string;
  videoResourceList: WebcastGiftMessage_AssetsModel_VideoResource[];
  faceRecognitionArchiveMeta: WebcastGiftMessage_AssetsModel_FaceRecognitionMeta | undefined;
  lynxUrlSettingsKey: string;
  downgradeResourceType: number;
  assetExtra: WebcastGiftMessage_AssetsModel_AssetExtra | undefined;
  stickerAssetVariant: number;
  immediateDownload: boolean;
  stickerAssetVariantReason: number;
}

export interface WebcastGiftMessage_AssetsModel_AssetExtra {
  effectStarlingKey: string;
}

export interface WebcastGiftMessage_AssetsModel_ResourceModel {
  urlList: string[];
  uri: string;
}

export interface WebcastGiftMessage_AssetsModel_LokiExtraContent {
  giftType: string;
  giftDuration: string;
  needScreenShot: boolean;
  ismultiFrame: boolean;
  viewOverlay: string;
  befViewRenderSize: WebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize | undefined;
  befViewRenderFPS: number;
  befViewFitMode: number;
  modelNames: string;
  requirements: string[];
}

export interface WebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize {
  with: number;
  height: number;
}

export interface WebcastGiftMessage_AssetsModel_VideoResource {
  videoTypeName: string;
  videoUrl: WebcastGiftMessage_AssetsModel_ResourceModel | undefined;
  videoMd5: string;
}

export interface WebcastGiftMessage_AssetsModel_FaceRecognitionMeta {
  version: string;
  requirements: string[];
  modelNames: string;
  sdkExtra: string;
}

export interface WebcastGiftMessage_LynxGiftExtra {
  id: string;
  code: string;
  type: string;
  params: string[];
  extra: string;
}

export interface WebcastGiftMessage_FlyingMicResources {
  pathImage: Image | undefined;
  micImage: Image | undefined;
  transitionConfigs: WebcastGiftMessage_FlyingMicResources_TransitionConfig[];
}

export interface WebcastGiftMessage_FlyingMicResources_TransitionConfig {
  configId: string;
  resourceImage: Image | undefined;
}

export interface WebcastGiftMessage_SponsorshipInfo {
  giftId: string;
  sponsorId: string;
  lightGiftUp: boolean;
  unlightedGiftIcon: string;
  giftGalleryDetailPageSchemeUrl: string;
  giftGalleryClickSponsor: boolean;
  becomeAllSponsored: boolean;
}

/** Battle start */
export interface WebcastLinkMicBattle {
  common: CommonMessageData | undefined;
  battleId: string;
  battleSetting: BattleSetting | undefined;
  action: BattleAction;
  battleResult: { [key: string]: WebcastLinkMicBattle_BattleResult };
  mBattleDisplayConfig: WebcastLinkMicBattle_BattleDisplayConfig | undefined;
  inviteeGiftPermissionType: GiftPermissionType;
  armies: { [key: string]: BattleUserArmies };
  anchorInfo: { [key: string]: WebcastLinkMicBattle_BattleUserInfo };
  bubbleText: string;
  supportedActions: WebcastLinkMicBattle_SupportedActionsWrapper[];
  battleCombos: { [key: string]: WebcastLinkMicBattle_BattleComboInfo };
  teamUsers: WebcastLinkMicBattle_TeamUsersInfo[];
  inviteeGiftPermissionTypes: WebcastLinkMicBattle_BattleInviteeGiftPermission[];
  actionByUserId: string;
  teamBattleResult: WebcastLinkMicBattle_BattleTeamResult[];
  teamArmies: BattleTeamUserArmies[];
  abtestSettings: WebcastLinkMicBattle_BattleABTestSetting[];
  teamMatchCampaign: WebcastLinkMicBattle_TeamMatchCampaign | undefined;
  fuzzyDisplayConfigV2: HighScoreControlCfg | undefined;
}

export interface WebcastLinkMicBattle_BattleResultEntry {
  key: string;
  value: WebcastLinkMicBattle_BattleResult | undefined;
}

export interface WebcastLinkMicBattle_ArmiesEntry {
  key: string;
  value: BattleUserArmies | undefined;
}

export interface WebcastLinkMicBattle_AnchorInfoEntry {
  key: string;
  value: WebcastLinkMicBattle_BattleUserInfo | undefined;
}

export interface WebcastLinkMicBattle_BattleCombosEntry {
  key: string;
  value: WebcastLinkMicBattle_BattleComboInfo | undefined;
}

export interface WebcastLinkMicBattle_TeamMatchCampaign {
  bestTeammateRelation: WebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation[];
  startSfxTeamId: string[];
  hasTeamMatchMvpSfx: boolean;
}

export interface WebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation {
  userId: string;
  bestTeammateId: string;
}

export interface WebcastLinkMicBattle_BattleTeamResult {
  teamId: string;
  teamUsers: BattleTeamUser[];
  result: number;
  totalScore: string;
}

export interface WebcastLinkMicBattle_BattleInviteeGiftPermission {
  userId: string;
  giftPermissionType: number;
}

export interface WebcastLinkMicBattle_SupportedActionsWrapper {
  actionType: string;
}

export interface WebcastLinkMicBattle_TeamUsersInfo {
  teamId: string;
  userIds: string[];
}

export interface WebcastLinkMicBattle_BattleComboInfo {
  userId: string;
  comboStatus: string;
  comboCount: string;
  comboIconUrl: string;
  comboType: number;
  comboRuleGuideSchema: string;
}

export interface WebcastLinkMicBattle_BattleResult {
  userId: string;
  result: Result;
  score: string;
}

export interface WebcastLinkMicBattle_BattleDisplayConfig {
  threshold: number;
  text: string;
  diffThreshold: number;
  diffText: string;
  exemptStrategy: WebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy | undefined;
}

export interface WebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy {
  exemptBothHost: boolean;
  exemptAudienceTop: number;
}

export interface WebcastLinkMicBattle_BattleUserInfo {
  user: WebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo | undefined;
  tags: WebcastLinkMicBattle_BattleUserInfo_BattleRivalTag[];
}

export interface WebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo {
  userId: string;
  nickName: string;
  avatarThumb: Image | undefined;
  displayId: string;
}

export interface WebcastLinkMicBattle_BattleUserInfo_BattleRivalTag {
  bgImage: Image | undefined;
  iconImage: Image | undefined;
  content: string;
}

export interface WebcastLinkMicBattle_BattleABTestSetting {
  uid: string;
  abTestList: WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList | undefined;
}

export interface WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList {
  abTestList: WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest[];
}

export interface WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest {
  abTestType: BattleABTestType;
  group: number;
}

/** Battle status */
export interface WebcastLinkMicArmies {
  common: CommonMessageData | undefined;
  battleId: string;
  battleItems: { [key: string]: BattleUserArmies };
  channelId: string;
  giftSentTime: string;
  scoreUpdateTime: string;
  battleStatus: TriggerReason;
  fromUserId: string;
  giftId: string;
  giftCount: number;
  gifIconImage: Image | undefined;
  totalDiamondCount: number;
  repeatCount: number;
  teamArmies: BattleTeamUserArmies[];
  triggerCriticalStrike: boolean;
  hasTeamMatchMvpSfx: boolean;
  logId: string;
  battleSettings: BattleSetting | undefined;
  fuzzyDisplayConfigV2: HighScoreControlCfg | undefined;
}

export interface WebcastLinkMicArmies_BattleItemsEntry {
  key: string;
  value: BattleUserArmies | undefined;
}

export interface WebcastLinkMicArmiesItems {
  hostUserId: string;
  battleGroups: WebcastLinkMicArmiesGroup[];
}

export interface WebcastLinkMicArmiesGroup {
  users: User[];
  points: number;
}

/** Follow & share event */
export interface WebcastSocialMessage {
  common: CommonMessageData | undefined;
  user: User | undefined;
  shareType: string;
  action: string;
  shareTarget: string;
  followCount: number;
  shareDisplayStyle: string;
  shareCount: number;
  publicAreaMessageCommon: PublicAreaMessageCommon | undefined;
  signature: string;
  signatureVersion: string;
  showDurationMs: string;
}

/** Like event (is only sent from time to time, not with every like) */
export interface WebcastLikeMessage {
  common: CommonMessageData | undefined;
  likeCount: number;
  totalLikeCount: number;
  color: number;
  user: User | undefined;
  icon: string;
  icons: Image[];
  specifiedDisplayText: SpecifiedDisplayText[];
  effectCnt: string;
  likeEffect: LikeEffect[];
  publicAreaMessageCommon: PublicAreaMessageCommon | undefined;
  roomMessageHeatLevel: string;
}

export interface SpecifiedDisplayText {
  uid: string;
  displayText: Text | undefined;
}

export interface LikeEffect {
  version: string;
  effectCnt: string;
  effectIntervalMs: string;
  level: string;
}

/** New question event */
export interface WebcastQuestionNewMessage {
  common: CommonMessageData | undefined;
  details: WebcastQuestionNewMessage_Question | undefined;
}

export interface WebcastQuestionNewMessage_Question {
  questionId: string;
  questionText: string;
  answerStatus: number;
  createTime: string;
  user: User | undefined;
  createFrom: number;
  answerFrom: number;
}

/** Contains UI information */
export interface WebcastMessageEventDetails {
  displayType: string;
  label: string;
}

/** Source: Co-opted https://github.com/zerodytrash/TikTok-Livestream-Chat-Connector/issues/19#issuecomment-1074150342 */
export interface WebcastLiveIntroMessage {
  common: CommonMessageData | undefined;
  roomId: string;
  auditStatus: AuditStatus;
  description: string;
  host: User | undefined;
  introMode: number;
  badges: BadgeStruct[];
  language: string;
}

export interface SystemMessage {
  description: string;
}

export interface RankItem {
  colour: string;
  id: string;
}

export interface WebcastHourlyRankMessage {
  data: WebcastHourlyRankMessage_RankContainer | undefined;
  common: CommonMessageData | undefined;
  data2: number;
}

export interface WebcastHourlyRankMessage_RankContainer {
  data1: number;
  rankingData: WebcastHourlyRankMessage_RankContainer_RankingData | undefined;
  data2: number;
  rankings: Ranking | undefined;
  rankingData2: WebcastHourlyRankMessage_RankContainer_RankingData2 | undefined;
  data3: number;
  data4: number;
}

export interface WebcastHourlyRankMessage_RankContainer_RankingData {
  data1: number;
  rankdata: Ranking | undefined;
  data2: string;
}

export interface WebcastHourlyRankMessage_RankContainer_RankingData2 {
  data1: number;
  data2: number;
  rankdata: Ranking | undefined;
  data3: string;
  data4: number;
  data5: number;
}

export interface EmoteDetails {
  emoteId: string;
  image: EmoteImage | undefined;
}

export interface EmoteImage {
  imageUrl: string;
}

export interface WebcastEnvelopeMessage {
  common: CommonMessageData | undefined;
  envelopeInfo: WebcastEnvelopeMessage_EnvelopeInfo | undefined;
  display: EnvelopeDisplay;
}

export interface WebcastEnvelopeMessage_EnvelopeInfo {
  envelopeId: string;
  businessType: EnvelopeBusinessType;
  envelopeIdc: string;
  sendUserName: string;
  diamondCount: number;
  peopleCount: number;
  unpackAt: number;
  sendUserId: string;
  sendUserAvatar: Image | undefined;
  createAt: string;
  roomId: string;
  followShowStatus: EnvelopeFollowShowStatus;
  skinId: number;
}

export interface TreasureBoxData {
  coins: number;
  canOpen: number;
  timestamp: string;
}

/** New Subscriber message */
export interface WebcastSubNotifyMessage {
  common: CommonMessageData | undefined;
  user: User | undefined;
  exhibitionType: ExhibitionType;
  subMonth: string;
  subscribeType: SubscribeType;
  oldSubscribeStatus: OldSubscribeStatus;
  subscribeMessageType?: MessageType | undefined;
  subscribingStatus: SubscribingStatus;
  isSend: boolean;
  isCustom: boolean;
  giftSource: GiftSource;
  messageDisplayStyle: MessageDisplayStyle;
  publicAreaMessageCommon: PublicAreaMessageCommon | undefined;
  packageId: string;
  eventTracking: WebcastSubNotifyMessage_EventTracking | undefined;
}

export interface WebcastSubNotifyMessage_EventTracking {
  giftSubSenderId: string;
  giftSubReceiverId: string;
  anchorId: string;
  giftSubOrderCreateTime: string;
}

export interface FollowInfo {
  followingCount: number;
  followerCount: number;
  followStatus: number;
  pushStatus: number;
}

export interface ProfilePicture {
  urls: string[];
}

export interface UserBadgesAttributes {
  badgeSceneType: number;
  imageBadges: UserImageBadge[];
  badges: UserBadge[];
  privilegeLogExtra: PrivilegeLogExtra | undefined;
}

export interface UserBadge {
  type: string;
  name: string;
}

export interface UserImageBadge {
  displayType: number;
  image: UserImageBadgeImage | undefined;
}

export interface UserImageBadgeImage {
  url: string;
}

/** Websocket acknowledgment message */
export interface WebSocketAckMessage {
  id: string;
  type: string;
}

/** Message representing the room info */
export interface HeartbeatFrameRoomInfo {
  roomId: string;
}

/** Message representing metadata field 6 */
export interface HeartbeatFrameMetadataField6 {
  unknown1: number;
}

/** Message representing metadata field 7 */
export interface HeartbeatFrameMetadataField7 {
  unknown1: number;
}

/** Heartbeat keepalive message */
export interface HeartbeatFrame {
  metadataField6: HeartbeatFrameMetadataField6 | undefined;
  metadataField7: HeartbeatFrameMetadataField7 | undefined;
  roomInfo: HeartbeatFrameRoomInfo | undefined;
}

/**
 * TODO: In a future release, set client_enter=1 on both /im/fetch and WS url; this is what the web client does
 * Didn't do it because it requires an agent update & sign server update
 *         // Create a room enter container
 *        const container = ImEnterRoomMessagePushFrame.fromPartial({
 *            payloadType: "im_enter_room",
 *            payload: {
 *                roomId: roomId,
 *                unknown1: 12,
 *                role: "audience",
 *                cursor: cursor,
 *                unknown2: 0,
 *                unknown3: "0",
 *                unknown4: 0
 *            },
 *            metadata: {
 *                unknown1: 98
 *            }
 *        });
 */
export interface ImEnterRoomMessagePushFrame {
  metadata:
    | ImEnterRoomMessagePushFrame_Metadata
    | undefined;
  /** "im_enter_room" */
  payloadType: string;
  payload: ImEnterRoomMessagePushFrame_ImEnterRoomMessage | undefined;
}

export interface ImEnterRoomMessagePushFrame_Metadata {
  /** "98" */
  unknown1: number;
}

export interface ImEnterRoomMessagePushFrame_ImEnterRoomMessage {
  /** Room ID */
  roomId: string;
  /** "12" */
  unknown1: number;
  /** "audience" */
  role: string;
  /** Cursor */
  cursor: string;
  /** "0" */
  unknown2?:
    | number
    | undefined;
  /** "0" */
  unknown3: string;
  /** "0" */
  unknown4?: number | undefined;
}

export interface WebcastBarrageMessage {
  common: CommonMessageData | undefined;
  event: WebcastBarrageMessage_BarrageEvent | undefined;
  msgType?: WebcastBarrageMessage_BarrageType | undefined;
  icon: ImageModel | undefined;
  duration: string;
  backGround: ImageModel | undefined;
  rightIcon: ImageModel | undefined;
  displayConfig: number;
  galleryGiftId: string;
  useMarquee: boolean;
  showType?: WebcastBarrageMessage_ShowType | undefined;
  renderType?: WebcastBarrageMessage_RenderType | undefined;
  leftIconDisplayType?: WebcastBarrageMessage_IconDisplayType | undefined;
  ribbonAnimation: ImageModel | undefined;
  hybridUrl: string;
  schema: string;
  subType: string;
  privilegeLogExtra: PrivilegeLogExtra | undefined;
  content: Text | undefined;
  scene: Scene;
  control: WebcastBarrageMessage_DisplayControl | undefined;
  rightLabel: WebcastBarrageMessage_RightLabel | undefined;
  badge: BadgeStruct | undefined;
  animationData: WebcastBarrageMessage_AnimationData | undefined;
  commonBarrageContent: Text | undefined;
  userGradeParam: WebcastBarrageMessage_BarrageTypeUserGradeParam | undefined;
  fansLevelParam: WebcastBarrageMessage_BarrageTypeFansLevelParam | undefined;
  subscribeGiftParam: WebcastBarrageMessage_BarrageTypeSubscribeGiftParam | undefined;
  giftGalleryParams: WebcastBarrageMessage_BarrageTypeGiftGalleryParam | undefined;
}

export enum WebcastBarrageMessage_BarrageType {
  BARRAGE_TYPE_UNKNOWN = 0,
  BARRAGE_TYPE_E_COM_ORDERING = 1,
  BARRAGE_TYPE_E_COM_BUYING = 2,
  BARRAGE_TYPE_NORMAL = 3,
  BARRAGE_TYPE_SUBSCRIBE = 4,
  BARRAGE_TYPE_EVENT_VIEW = 5,
  BARRAGE_TYPE_EVENT_REGISTERED = 6,
  BARRAGE_TYPE_SUBSCRIBE_GIFT = 7,
  BARRAGE_TYPE_USER_UPGRADE = 8,
  BARRAGE_TYPE_GRADE_USER_ENTRANCE_NOTIFICATION = 9,
  BARRAGE_TYPE_FANS_LEVEL_UPGRADE = 10,
  BARRAGE_TYPE_FANS_LEVEL_ENTRANCE = 11,
  BARRAGE_TYPE_GAME_PARTNERSHIP = 12,
  BARRAGE_TYPE_GIFT_GALLERY = 13,
  BARRAGE_TYPE_E_COM_BOUGHT = 14,
  BARRAGE_TYPE_COMMON_BARRAGE = 100,
  UNRECOGNIZED = -1,
}

export enum WebcastBarrageMessage_ShowType {
  SHOW_TYPE_NORMAL = 0,
  SHOW_TYPE_FADE_IN_OUT = 1,
  UNRECOGNIZED = -1,
}

export enum WebcastBarrageMessage_RenderType {
  RENDER_TYPE_NATIVE = 0,
  RENDER_TYPE_HYBRID = 1,
  RENDER_TYPE_ALPHA = 2,
  UNRECOGNIZED = -1,
}

export enum WebcastBarrageMessage_IconDisplayType {
  ICON_DISPLAY_TYPE_IMAGE = 0,
  ICON_DISPLAY_TYPE_BADGE = 1,
  UNRECOGNIZED = -1,
}

export interface WebcastBarrageMessage_BarrageEvent {
  eventName: string;
  params: { [key: string]: string };
}

export interface WebcastBarrageMessage_BarrageEvent_ParamsEntry {
  key: string;
  value: string;
}

export interface WebcastBarrageMessage_BarrageTypeUserGradeParam {
  currentGrade: number;
  displayConfig: number;
  userId: string;
  user: User | undefined;
}

export interface WebcastBarrageMessage_BarrageTypeFansLevelParam {
  currentGrade: number;
  displayConfig: number;
  user: User | undefined;
}

export interface WebcastBarrageMessage_BarrageTypeSubscribeGiftParam {
  giftSubCount: string;
  showGiftSubCount: boolean;
}

export interface WebcastBarrageMessage_AnimationData {
  geckoChannelName: string;
  fileName: string;
  height: string;
  width: string;
  rightOffset: string;
}

export interface WebcastBarrageMessage_BarrageTypeGiftGalleryParam {
  fromUserId: string;
  toUserId: string;
}

export interface WebcastBarrageMessage_DisplayControl {
  priority: number;
  duration: string;
  targetGroupShowRst: { [key: number]: WebcastBarrageMessage_DisplayControl_ShowResult };
  horizontalTriggerType: HorizontalOnclickTriggerType;
}

export interface WebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry {
  key: number;
  value: WebcastBarrageMessage_DisplayControl_ShowResult | undefined;
}

export interface WebcastBarrageMessage_DisplayControl_ShowResult {
  banned: boolean;
}

export interface WebcastBarrageMessage_RightLabel {
  backgroundColor: string;
  content: Text | undefined;
  height: string;
}

export interface WebcastPushFrame {
  seqId: string;
  id: string;
  service: string;
  method: string;
  headers: { [key: string]: string };
  payloadEncoding: string;
  type: string;
  binary: Uint8Array;
}

export interface WebcastPushFrame_HeadersEntry {
  key: string;
  value: string;
}

/** Response from TikTokServer. Container for Messages */
export interface ProtoMessageFetchResult {
  messages: BaseProtoMessage[];
  cursor: string;
  fetchInterval: string;
  now: string;
  internalExt: string;
  fetchType: number;
  wsParams: { [key: string]: string };
  heartBeatDuration: string;
  needsAck: boolean;
  wsUrl: string;
  isFirst: boolean;
  historyCommentCursor: string;
  historyNoMore: boolean;
}

export interface ProtoMessageFetchResult_WsParamsEntry {
  key: string;
  value: string;
}

export interface BaseProtoMessage {
  type: string;
  payload: Uint8Array;
  msgId: string;
  msgType: number;
  offset: string;
  isHistory: boolean;
}

export interface WebcastRoomMessage {
  common: CommonMessageData | undefined;
  content: string;
  supportLandscape: boolean;
  source: string;
  icon: Image | undefined;
  scene: Scene;
  isWelcome: boolean;
  publicAreaCommon: PublicAreaMessageCommon | undefined;
  showDurationMs: string;
  subScene: string;
}

/** Closed Captioning for Video */
export interface WebcastCaptionMessage {
  common: CommonMessageData | undefined;
  timestampMs: string;
  durationMs: string;
  content: WebcastCaptionMessage_CaptionContent[];
  sentenceId: string;
  sequenceId: string;
  definite: boolean;
}

export interface WebcastCaptionMessage_CaptionContent {
  lang: string;
  content: string;
}

/** System-Control Message from Room (e.g. Host ended Stream) */
export interface WebcastControlMessage {
  common: CommonMessageData | undefined;
  action: ControlAction;
  tips: string;
  extra: WebcastControlMessage_Extra | undefined;
  perceptionDialog: WebcastControlMessage_PerceptionDialogInfo | undefined;
  perceptionAudienceText: Text | undefined;
  punishInfo: PunishEventInfo | undefined;
  floatText: Text | undefined;
  floatStyle: number;
}

/**
 * @Extra
 * proto.webcast.im.ControlMessage
 */
export interface WebcastControlMessage_Extra {
  banInfoUrl: string;
  reasonNo: string;
  title: Text | undefined;
  violationReason: Text | undefined;
  content: Text | undefined;
  gotItButton: Text | undefined;
  banDetailButton: Text | undefined;
  source: string;
}

export interface WebcastControlMessage_PerceptionDialogInfo {
  iconType: PerceptionDialogIconType;
  title: Text | undefined;
  subTitle: Text | undefined;
  adviceActionText: Text | undefined;
  defaultActionText: Text | undefined;
  violationDetailUrl: string;
  scene: Scene;
  targetUserId: string;
  targetRoomId: string;
  countDownTime: string;
  showFeedback: boolean;
  feedbackOptions: WebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption[];
  policyTip: string;
  appealPopup: number;
}

export interface WebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption {
  id: string;
  contentKey: string;
}

export interface WebcastGoalUpdateMessage {
  common: CommonMessageData | undefined;
  indicator: LiveStreamGoalIndicator | undefined;
  goal: LiveStreamGoal | undefined;
  contributorId: string;
  contributorAvatar: Image | undefined;
  contributorDisplayId: string;
  contributeSubgoal: WebcastGoalUpdateMessage_LiveStreamSubGoal | undefined;
  contributeCount: string;
  contributeScore: string;
  giftRepeatCount: string;
  contributorIdStr: string;
  pin: boolean;
  unpin: boolean;
  pinInfo: WebcastGoalUpdateMessage_GoalPinInfo | undefined;
  updateSource: GoalMessageSource;
  goalExtra: string;
}

export interface WebcastGoalUpdateMessage_LiveStreamSubGoal {
  type: number;
  id: string;
  progress: string;
  target: string;
  gift: WebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift | undefined;
  idStr: string;
  pinInfo: WebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo | undefined;
  source: number;
  recommendedText: string;
  recommendedCommon: string;
}

export interface WebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift {
  name: string;
  icon: Image | undefined;
  diamondCount: string;
  type: number;
}

export interface WebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo {
  pinStartTime: string;
  pinEndTime: string;
  pinReadyTime: string;
}

export interface WebcastGoalUpdateMessage_GoalPinInfo {
  pin: boolean;
  unpin: boolean;
  pinEndTime: string;
  subGoalId: string;
  subGoalIdStr: string;
}

/** Message related to Chat-moderation? */
export interface WebcastImDeleteMessage {
  common: CommonMessageData | undefined;
  deleteMsgIdsList: string[];
  deleteUserIdsList: string[];
}

export interface WebcastInRoomBannerMessage {
  common: CommonMessageData | undefined;
  data: { [key: string]: string };
  position: number;
  actionType: number;
}

export interface WebcastInRoomBannerMessage_DataEntry {
  key: string;
  value: string;
}

export interface WebcastRankUpdateMessage {
  common: CommonMessageData | undefined;
  updatesList: WebcastRankUpdateMessage_RankUpdate[];
  /** @warning Enum not found, should be GroupType */
  groupType: string;
  priority: string;
  tabsList: WebcastRankUpdateMessage_RankTabInfo[];
  isAnimationLoopPlay: boolean;
  animationLoopForOff: boolean;
  unionAnimation: WebcastRankUpdateMessage_UnionAnimationInfo[];
  tabInfo: WebcastRankUpdateMessage_RankListTabInfo[];
}

export interface WebcastRankUpdateMessage_UnionAnimationInfo {
  unionType: UnionAnimationInfoType;
  rankTypeArray: ProfitRankType;
  supportedVersion: string;
}

export interface WebcastRankUpdateMessage_RankListTabInfo {
  tabs: WebcastRankUpdateMessage_RankTabInfo[];
  supportedVersion: string;
}

export interface WebcastRankUpdateMessage_RankTabInfo {
  rankType: ProfitRankType;
  title: string;
  titleText: Text | undefined;
  listLynxType: string;
}

/**
 * @RankUpdate
 * proto.webcast.im.RankUpdateMessage
 */
export interface WebcastRankUpdateMessage_RankUpdate {
  /** @warning Enum not found, should be RankType */
  rankType: string;
  ownerRank: string;
  defaultContent: Text | undefined;
  showEntranceAnimation: boolean;
  countdown: string;
  /** @warning Enum not found, should be RelatedTabRankType */
  relatedTabRankType: string;
  /** @warning Enum not found, should be RequestFirstShowType */
  requestFirstShowType: string;
  supportedVersion: string;
  owneronrank: boolean;
}

/** --- HandMade -- */
export interface WebcastPollMessage {
  common: CommonMessageData | undefined;
  messageType: MessageType;
  pollId: string;
  startContent: PollStartContent | undefined;
  endContent: PollEndContent | undefined;
  updateContent: PollUpdateVotesContent | undefined;
  pollKind: PollKind;
  pollBasicInfo: WebcastPollMessage_PollBasicInfo | undefined;
  templateContent: WebcastPollMessage_TemplateContent | undefined;
}

export interface WebcastPollMessage_TemplateContent {
  templateId: string;
  templateIdStr: string;
  status: PollTemplateStatus;
  pollKind: PollKind;
  appealStatus: PollAppealStatus;
  violationIdStr: string;
}

export interface WebcastPollMessage_PollBasicInfo {
  pollSponsor: string;
  giftId: string;
  title: string;
  isSuggestedQuestion: boolean;
  userCnt: string;
  gift: Gift | undefined;
  pollIdStr: string;
  suggestedQuestionKey: string;
  pollDuration: string;
  timeRemain: string;
  pollIndex: string;
  templateId: string;
}

export interface WebcastRankTextMessage {
  common: CommonMessageData | undefined;
  scene: RankTestMessageScene;
  ownerIdxBeforeUpdate: string;
  ownerIdxAfterUpdate: string;
  selfGetBadgeMsg: Text | undefined;
  otherGetBadgeMsg: Text | undefined;
  curUserId: string;
}

export interface WebcastLinkMicBattlePunishFinish {
  common: CommonMessageData | undefined;
  channelId: string;
  opUid: string;
  reason: Reason;
  battleId: string;
  battleSettings: BattleSetting | undefined;
}

export interface WebcastLinkmicBattleTaskMessage {
  common: CommonMessageData | undefined;
  battleTaskMessageType: BattleTaskMessageType;
  taskStart: WebcastLinkmicBattleTaskMessage_BattleTaskStart | undefined;
  taskUpdate: WebcastLinkmicBattleTaskMessage_BattleTaskUpdate | undefined;
  taskSettle: WebcastLinkmicBattleTaskMessage_BattleTaskSettle | undefined;
  rewardSettle: WebcastLinkmicBattleTaskMessage_BattleRewardSettle | undefined;
  battleId: string;
}

export interface WebcastLinkmicBattleTaskMessage_BattlePrompt {
  promptKey: string;
  promptElements: WebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem[];
}

export interface WebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem {
  promptFieldKey: string;
  promptFieldValue: string;
}

export interface WebcastLinkmicBattleTaskMessage_BattleTaskStart {
  battleBonusConfig: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig | undefined;
}

export interface WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig {
  previewStartTime: string;
  previewPeriodConfig: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod[];
  taskPeriodConfig: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig | undefined;
  rewardPeriodConfig: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig | undefined;
  taskGiftGuide: {
    [key: string]: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide;
  };
  previewStartTimestamp: string;
  previewClickActionSchemaUrl: string;
}

export interface WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry {
  key: string;
  value: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide | undefined;
}

export interface WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod {
  duration: string;
  promot: WebcastLinkmicBattleTaskMessage_BattlePrompt | undefined;
  icon: Image | undefined;
}

export interface WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig {
  taskStartTime: string;
  duration: string;
  targetStartTimestamp: string;
  clickAction: number;
  clickToastPrompt: WebcastLinkmicBattleTaskMessage_BattlePrompt | undefined;
  promptType: number;
  taskStaticPrompt: WebcastLinkmicBattleTaskMessage_BattlePrompt | undefined;
  progressTarget: string;
  targetType: number;
  icon: Image | undefined;
  clickActionSchemaUrl: string;
}

export interface WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig {
  rewardStartTime: string;
  duration: string;
  rewardMultiple: number;
  rewardStartTimestamp: string;
  rewardPraparePrompt: WebcastLinkmicBattleTaskMessage_BattlePrompt | undefined;
  rewardingPrompt: WebcastLinkmicBattleTaskMessage_BattlePrompt | undefined;
  clickPrompt: WebcastLinkmicBattleTaskMessage_BattlePrompt | undefined;
}

export interface WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide {
  guidePrompt: WebcastLinkmicBattleTaskMessage_BattlePrompt | undefined;
  promptType: number;
  disappearDuration: number;
  iconImage: Image | undefined;
  giftImage: Image | undefined;
  recommendGiftId: string;
  recommendGiftCount: number;
  guideContent: Text | undefined;
}

export interface WebcastLinkmicBattleTaskMessage_BattleTaskUpdate {
  taskProgress: string;
  fromUserUid: string;
  promptKey: string;
  logId: string;
}

export interface WebcastLinkmicBattleTaskMessage_BattleTaskSettle {
  taskResult: WebcastLinkmicBattleTaskMessage_BattleTaskSettle_Result;
  rewardStartTime: string;
  rewardStartTimestamp: string;
}

export enum WebcastLinkmicBattleTaskMessage_BattleTaskSettle_Result {
  RESULT_SUCCEED = 0,
  RESULT_FAILED = 1,
  RESULT_BOTH_SUCCEED = 2,
  UNRECOGNIZED = -1,
}

export interface WebcastLinkmicBattleTaskMessage_BattleRewardSettle {
  rewardSettlePrompt: WebcastLinkmicBattleTaskMessage_BattlePrompt | undefined;
  status: RewardStatus;
}

export interface WebcastLinkMicFanTicketMethod {
  common: CommonMessageData | undefined;
  FanTicketRoomNotice: FanTicketRoomNoticeContent | undefined;
}

export interface WebcastLinkMicMethod {
  common: CommonMessageData | undefined;
  messageType: MessageType;
  accessKey: string;
  anchorLinkmicId: string;
  userId: string;
  fanTicket: string;
  totalLinkMicFanTicket: string;
  channelId: string;
  layout: string;
  vendor: string;
  dimension: string;
  theme: string;
  inviteUid: string;
  reply: number;
  duration: number;
  matchType: number;
  win: boolean;
  prompts: string;
  toUserId: string;
  tips: string;
  startTimeMs: string;
  confluenceType: number;
  fromRoomId: string;
  inviteType: number;
  subType: string;
  rtcExtInfo: string;
  appId: string;
  appSign: string;
  anchorLinkMicIdStr: string;
  rivalAnchorId: string;
  rivalLinkmicId: number;
  rivalLinkmicIdStr: string;
  shouldShowPopup: boolean;
  rtcJoinChannel: boolean;
  fanTicketType: number;
}

export interface WebcastUnauthorizedMemberMessage {
  common: CommonMessageData | undefined;
  action: number;
  nickNamePrefix: Text | undefined;
  nickName: string;
  enterText: Text | undefined;
  publicAreaCommon: PublicAreaMessageCommon | undefined;
}

export interface WebcastMsgDetectMessage {
  common: CommonMessageData | undefined;
  detectType: number;
  triggerCondition: WebcastMsgDetectMessage_TriggerCondition | undefined;
  timeInfo: WebcastMsgDetectMessage_TimeInfo | undefined;
  triggerBy: number;
  fromRegion: string;
}

export interface WebcastMsgDetectMessage_TimeInfo {
  clientStartMs: string;
  apiRecvTimeMs: string;
  apiSendToGoimMs: string;
}

export interface WebcastMsgDetectMessage_TriggerCondition {
  uplinkDetectHttp: boolean;
  uplinkDetectWebSocket: boolean;
  detectP2PMsg: boolean;
  detectRoomMsg: boolean;
  httpOptimize: boolean;
}

export interface WebcastOecLiveShoppingMessage {
  common: CommonMessageData | undefined;
  data1: number;
  shopData:
    | WebcastOecLiveShoppingMessage_LiveShoppingData
    | undefined;
  /** Uses index 1, 2 & 3 */
  shopTimings: TimeStampContainer | undefined;
  details: WebcastOecLiveShoppingMessage_LiveShoppingDetails | undefined;
}

export interface WebcastOecLiveShoppingMessage_LiveShoppingData {
  title: string;
  /** $55.99 */
  priceString: string;
  imageUrl: string;
  shopUrl: string;
  data1: string;
  /** "Shopify" */
  shopName: string;
  data2: string;
  shopUrl2: string;
  data3: string;
  data4: string;
}

export interface WebcastOecLiveShoppingMessage_LiveShoppingDetails {
  id1: string;
  data1: string;
  data2: number;
  timestamp: string;
  data: ValueLabel | undefined;
}

/** Host Pins comment to stream */
export interface WebcastRoomPinMessage {
  common: CommonMessageData | undefined;
  chatMessage?: WebcastChatMessage | undefined;
  socialMessage?: WebcastSocialMessage | undefined;
  giftMessage?: WebcastGiftMessage | undefined;
  memberMessage?: WebcastMemberMessage | undefined;
  likeMessage?: WebcastLikeMessage | undefined;
  method: string;
  pinTime: string;
  operator: User | undefined;
  action: number;
  displayDuration: string;
  pinId: string;
  ecStreamerKey: string;
}

export interface WebcastLinkMessage {
  common: CommonMessageData | undefined;
  MessageType: LinkMessageType;
  LinkerId: string;
  Scene: Scene;
  InviteContent: LinkerInviteContent | undefined;
  ReplyContent: LinkerReplyContent | undefined;
  CreateContent: LinkerCreateContent | undefined;
  CloseContent: LinkerCloseContent | undefined;
  EnterContent: LinkerEnterContent | undefined;
  LeaveContent: LinkerLeaveContent | undefined;
  CancelContent: LinkerCancelContent | undefined;
  KickOutContent: LinkerKickOutContent | undefined;
  LinkedListChangeContent: LinkerLinkedListChangeContent | undefined;
  UpdateUserContent: LinkerUpdateUserContent | undefined;
  WaitingListChangeContent: LinkerWaitingListChangeContent | undefined;
  MuteContent: LinkerMuteContent | undefined;
  RandomMatchContent: LinkerRandomMatchContent | undefined;
  UpdateUserSettingContent: LinkerUpdateUserSettingContent | undefined;
  MicIdxUpdateContent: LinkerMicIdxUpdateContent | undefined;
  ListChangeContent: LinkerListChangeContent | undefined;
  CohostListChangeContent: CohostListChangeContent | undefined;
  MediaChangeContent: LinkerMediaChangeContent | undefined;
  AcceptNoticeContent: LinkerAcceptNoticeContent | undefined;
  SysKickOutContent: LinkerSysKickOutContent | undefined;
  UserToastContent: LinkmicUserToastContent | undefined;
  extra: string;
  expireTimestamp: string;
  transferExtra: string;
}

/** @WebcastLinkLayerMessage */
export interface WebcastLinkLayerMessage {
  common: CommonMessageData | undefined;
  messageType: MessageType;
  channelId: string;
  scene: Scene;
  source: string;
  centerizedIdc: string;
  rtcRoomId: string;
  createChannelContent: CreateChannelContent | undefined;
  listChangeContent: ListChangeContent | undefined;
  inviteContent: InviteContent | undefined;
  applyContent: ApplyContent | undefined;
  permitApplyContent: PermitApplyContent | undefined;
  replyInviteContent: ReplyInviteContent | undefined;
  kickOutContent: KickOutContent | undefined;
  cancelApplyContent: CancelApplyContent | undefined;
  cancelInviteContent: CancelInviteContent | undefined;
  leaveContent: LeaveContent | undefined;
  finishContent: FinishChannelContent | undefined;
  joinDirectContent: JoinDirectContent | undefined;
  joinGroupContent: JoinGroupContent | undefined;
  permitGroupContent: PermitJoinGroupContent | undefined;
  cancelGroupContent: CancelJoinGroupContent | undefined;
  leaveGroupContent: LeaveJoinGroupContent | undefined;
  p2pGroupChangeContent: P2PGroupChangeContent | undefined;
  groupChangeContent: GroupChangeContent | undefined;
  businessContent: BusinessContent | undefined;
}

/** @RoomVerifyMessage */
export interface RoomVerifyMessage {
  common: CommonMessageData | undefined;
  action: number;
  content: string;
  noticeType: string;
  closeRoom: boolean;
}

function createBaseMessage(): Message {
  return { type: "", binary: new Uint8Array(0) };
}

export const Message: MessageFns<Message> = {
  encode(message: Message, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.binary.length !== 0) {
      writer.uint32(18).bytes(message.binary);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.binary = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebsocketParam(): WebsocketParam {
  return { name: "", value: "" };
}

export const WebsocketParam: MessageFns<WebsocketParam> = {
  encode(message: WebsocketParam, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebsocketParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebsocketParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastRoomUserSeqMessage(): WebcastRoomUserSeqMessage {
  return {
    common: undefined,
    viewerCount: 0,
    ranksList: [],
    popStr: "",
    seatsList: [],
    popularity: "0",
    totalUser: 0,
    anonymous: "0",
  };
}

export const WebcastRoomUserSeqMessage: MessageFns<WebcastRoomUserSeqMessage> = {
  encode(message: WebcastRoomUserSeqMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.viewerCount !== 0) {
      writer.uint32(24).int32(message.viewerCount);
    }
    for (const v of message.ranksList) {
      WebcastRoomUserSeqMessage_Contributor.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.popStr !== "") {
      writer.uint32(34).string(message.popStr);
    }
    for (const v of message.seatsList) {
      WebcastRoomUserSeqMessage_Contributor.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.popularity !== "0") {
      writer.uint32(48).int64(message.popularity);
    }
    if (message.totalUser !== 0) {
      writer.uint32(56).int32(message.totalUser);
    }
    if (message.anonymous !== "0") {
      writer.uint32(64).int64(message.anonymous);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastRoomUserSeqMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastRoomUserSeqMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.viewerCount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ranksList.push(WebcastRoomUserSeqMessage_Contributor.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.popStr = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.seatsList.push(WebcastRoomUserSeqMessage_Contributor.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.popularity = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalUser = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.anonymous = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastRoomUserSeqMessage_Contributor(): WebcastRoomUserSeqMessage_Contributor {
  return { coinCount: 0, user: undefined, rank: 0, delta: "0" };
}

export const WebcastRoomUserSeqMessage_Contributor: MessageFns<WebcastRoomUserSeqMessage_Contributor> = {
  encode(message: WebcastRoomUserSeqMessage_Contributor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coinCount !== 0) {
      writer.uint32(8).int32(message.coinCount);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.rank !== 0) {
      writer.uint32(24).int32(message.rank);
    }
    if (message.delta !== "0") {
      writer.uint32(32).int64(message.delta);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastRoomUserSeqMessage_Contributor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastRoomUserSeqMessage_Contributor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.coinCount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rank = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.delta = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseImageModel(): ImageModel {
  return {
    mUrls: [],
    mUri: "",
    height: 0,
    width: 0,
    avgColor: "",
    imageType: 0,
    schema: "",
    content: undefined,
    isAnimated: false,
  };
}

export const ImageModel: MessageFns<ImageModel> = {
  encode(message: ImageModel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.mUrls) {
      writer.uint32(10).string(v!);
    }
    if (message.mUri !== "") {
      writer.uint32(18).string(message.mUri);
    }
    if (message.height !== 0) {
      writer.uint32(24).int32(message.height);
    }
    if (message.width !== 0) {
      writer.uint32(32).int32(message.width);
    }
    if (message.avgColor !== "") {
      writer.uint32(42).string(message.avgColor);
    }
    if (message.imageType !== 0) {
      writer.uint32(48).int32(message.imageType);
    }
    if (message.schema !== "") {
      writer.uint32(58).string(message.schema);
    }
    if (message.content !== undefined) {
      ImageModel_Content.encode(message.content, writer.uint32(66).fork()).join();
    }
    if (message.isAnimated !== false) {
      writer.uint32(72).bool(message.isAnimated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mUrls.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mUri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.avgColor = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.imageType = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.content = ImageModel_Content.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isAnimated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseImageModel_Content(): ImageModel_Content {
  return { name: "", fontColor: "", level: "0" };
}

export const ImageModel_Content: MessageFns<ImageModel_Content> = {
  encode(message: ImageModel_Content, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.fontColor !== "") {
      writer.uint32(18).string(message.fontColor);
    }
    if (message.level !== "0") {
      writer.uint32(24).int64(message.level);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageModel_Content {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageModel_Content();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fontColor = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.level = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastChatMessage(): WebcastChatMessage {
  return {
    common: undefined,
    user: undefined,
    comment: "",
    visibleToSender: false,
    background: undefined,
    fullScreenTextColor: "",
    backgroundImageV2: undefined,
    publicAreaCommon: undefined,
    giftImage: undefined,
    inputType: 0,
    atUser: undefined,
    emotes: [],
    contentLanguage: "",
    msgFilter: undefined,
    quickChatScene: 0,
    communityflaggedStatus: 0,
    commentQualityScores: [],
    userIdentity: undefined,
    commentTag: [],
    publicAreaMessageCommon: undefined,
    screenTime: "0",
    signature: "",
    signatureVersion: "",
    ecStreamerKey: "",
  };
}

export const WebcastChatMessage: MessageFns<WebcastChatMessage> = {
  encode(message: WebcastChatMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    if (message.visibleToSender !== false) {
      writer.uint32(32).bool(message.visibleToSender);
    }
    if (message.background !== undefined) {
      ImageModel.encode(message.background, writer.uint32(42).fork()).join();
    }
    if (message.fullScreenTextColor !== "") {
      writer.uint32(50).string(message.fullScreenTextColor);
    }
    if (message.backgroundImageV2 !== undefined) {
      ImageModel.encode(message.backgroundImageV2, writer.uint32(58).fork()).join();
    }
    if (message.publicAreaCommon !== undefined) {
      PublicAreaCommon.encode(message.publicAreaCommon, writer.uint32(74).fork()).join();
    }
    if (message.giftImage !== undefined) {
      ImageModel.encode(message.giftImage, writer.uint32(82).fork()).join();
    }
    if (message.inputType !== 0) {
      writer.uint32(88).int32(message.inputType);
    }
    if (message.atUser !== undefined) {
      User.encode(message.atUser, writer.uint32(98).fork()).join();
    }
    for (const v of message.emotes) {
      WebcastSubEmote.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.contentLanguage !== "") {
      writer.uint32(114).string(message.contentLanguage);
    }
    if (message.msgFilter !== undefined) {
      MsgFilter.encode(message.msgFilter, writer.uint32(122).fork()).join();
    }
    if (message.quickChatScene !== 0) {
      writer.uint32(128).int32(message.quickChatScene);
    }
    if (message.communityflaggedStatus !== 0) {
      writer.uint32(136).int32(message.communityflaggedStatus);
    }
    for (const v of message.commentQualityScores) {
      WebcastChatMessage_CommentQualityScore.encode(v!, writer.uint32(154).fork()).join();
    }
    if (message.userIdentity !== undefined) {
      WebcastChatMessage_UserIdentity.encode(message.userIdentity, writer.uint32(146).fork()).join();
    }
    writer.uint32(162).fork();
    for (const v of message.commentTag) {
      writer.int32(v);
    }
    writer.join();
    if (message.publicAreaMessageCommon !== undefined) {
      PublicAreaMessageCommon.encode(message.publicAreaMessageCommon, writer.uint32(170).fork()).join();
    }
    if (message.screenTime !== "0") {
      writer.uint32(176).int64(message.screenTime);
    }
    if (message.signature !== "") {
      writer.uint32(186).string(message.signature);
    }
    if (message.signatureVersion !== "") {
      writer.uint32(194).string(message.signatureVersion);
    }
    if (message.ecStreamerKey !== "") {
      writer.uint32(202).string(message.ecStreamerKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastChatMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.visibleToSender = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.background = ImageModel.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fullScreenTextColor = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.backgroundImageV2 = ImageModel.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.publicAreaCommon = PublicAreaCommon.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.giftImage = ImageModel.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.inputType = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.atUser = User.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.emotes.push(WebcastSubEmote.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.contentLanguage = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.msgFilter = MsgFilter.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.quickChatScene = reader.int32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.communityflaggedStatus = reader.int32();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.commentQualityScores.push(WebcastChatMessage_CommentQualityScore.decode(reader, reader.uint32()));
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.userIdentity = WebcastChatMessage_UserIdentity.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag === 160) {
            message.commentTag.push(reader.int32() as any);

            continue;
          }

          if (tag === 162) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.commentTag.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.publicAreaMessageCommon = PublicAreaMessageCommon.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.screenTime = reader.int64().toString();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.signatureVersion = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.ecStreamerKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastChatMessage_UserIdentity(): WebcastChatMessage_UserIdentity {
  return {
    isGiftGiverOfAnchor: false,
    isSubscriberOfAnchor: false,
    isMutualFollowingWithAnchor: false,
    isFollowerOfAnchor: false,
    isModeratorOfAnchor: false,
    isAnchor: false,
  };
}

export const WebcastChatMessage_UserIdentity: MessageFns<WebcastChatMessage_UserIdentity> = {
  encode(message: WebcastChatMessage_UserIdentity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isGiftGiverOfAnchor !== false) {
      writer.uint32(8).bool(message.isGiftGiverOfAnchor);
    }
    if (message.isSubscriberOfAnchor !== false) {
      writer.uint32(16).bool(message.isSubscriberOfAnchor);
    }
    if (message.isMutualFollowingWithAnchor !== false) {
      writer.uint32(24).bool(message.isMutualFollowingWithAnchor);
    }
    if (message.isFollowerOfAnchor !== false) {
      writer.uint32(32).bool(message.isFollowerOfAnchor);
    }
    if (message.isModeratorOfAnchor !== false) {
      writer.uint32(40).bool(message.isModeratorOfAnchor);
    }
    if (message.isAnchor !== false) {
      writer.uint32(48).bool(message.isAnchor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastChatMessage_UserIdentity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastChatMessage_UserIdentity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isGiftGiverOfAnchor = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSubscriberOfAnchor = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isMutualFollowingWithAnchor = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isFollowerOfAnchor = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isModeratorOfAnchor = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isAnchor = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastChatMessage_CommentQualityScore(): WebcastChatMessage_CommentQualityScore {
  return { version: "", score: "0" };
}

export const WebcastChatMessage_CommentQualityScore: MessageFns<WebcastChatMessage_CommentQualityScore> = {
  encode(message: WebcastChatMessage_CommentQualityScore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.score !== "0") {
      writer.uint32(16).int64(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastChatMessage_CommentQualityScore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastChatMessage_CommentQualityScore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.score = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEmoteUploadInfo(): EmoteUploadInfo {
  return { userId: "0", emoteUploadSource: undefined, userInfo: undefined, userIdStr: "" };
}

export const EmoteUploadInfo: MessageFns<EmoteUploadInfo> = {
  encode(message: EmoteUploadInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.emoteUploadSource !== undefined) {
      writer.uint32(16).int32(message.emoteUploadSource);
    }
    if (message.userInfo !== undefined) {
      User.encode(message.userInfo, writer.uint32(26).fork()).join();
    }
    if (message.userIdStr !== "") {
      writer.uint32(34).string(message.userIdStr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmoteUploadInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmoteUploadInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.emoteUploadSource = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userInfo = User.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userIdStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastEmoteChatMessage(): WebcastEmoteChatMessage {
  return { common: undefined, user: undefined, emoteList: [], msgFilter: undefined, userIdentity: undefined };
}

export const WebcastEmoteChatMessage: MessageFns<WebcastEmoteChatMessage> = {
  encode(message: WebcastEmoteChatMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    for (const v of message.emoteList) {
      Emote.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.msgFilter !== undefined) {
      MsgFilter.encode(message.msgFilter, writer.uint32(34).fork()).join();
    }
    if (message.userIdentity !== undefined) {
      UserIdentity.encode(message.userIdentity, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastEmoteChatMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastEmoteChatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.emoteList.push(Emote.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.msgFilter = MsgFilter.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userIdentity = UserIdentity.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastSubEmote(): WebcastSubEmote {
  return { placeInComment: 0, emote: undefined };
}

export const WebcastSubEmote: MessageFns<WebcastSubEmote> = {
  encode(message: WebcastSubEmote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.placeInComment !== 0) {
      writer.uint32(8).int32(message.placeInComment);
    }
    if (message.emote !== undefined) {
      EmoteDetails.encode(message.emote, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastSubEmote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastSubEmote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.placeInComment = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.emote = EmoteDetails.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastMemberMessage(): WebcastMemberMessage {
  return {
    common: undefined,
    user: undefined,
    action: 0,
    memberCount: 0,
    operator: undefined,
    isSetToAdmin: false,
    isTopUser: false,
    rankScore: "0",
    topUserNo: "0",
    enterType: "0",
    actionDescription: "",
    userId: "0",
    effectConfig: undefined,
    popStr: "",
    enterEffectConfig: undefined,
    backgroundImage: undefined,
    backgroundImageV2: undefined,
    anchorDisplayText: undefined,
    clientEnterSource: "",
    clientEnterType: "",
    clientLiveReason: "",
    actionDuration: "0",
    userShareType: "",
    displayStyle: 0,
    adminPermissions: {},
    kickSource: 0,
    allowPreviewTime: "0",
    lastSubscriptionAction: "0",
    publicAreaMessageCommon: undefined,
    liveSubOnlyTier: "0",
    liveSubOnlyMonth: "0",
    ecStreamerKey: "",
    showWave: "0",
    waveAlgorithmData: undefined,
    hitAbStatus: 0,
  };
}

export const WebcastMemberMessage: MessageFns<WebcastMemberMessage> = {
  encode(message: WebcastMemberMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.action !== 0) {
      writer.uint32(80).int32(message.action);
    }
    if (message.memberCount !== 0) {
      writer.uint32(24).int32(message.memberCount);
    }
    if (message.operator !== undefined) {
      User.encode(message.operator, writer.uint32(34).fork()).join();
    }
    if (message.isSetToAdmin !== false) {
      writer.uint32(40).bool(message.isSetToAdmin);
    }
    if (message.isTopUser !== false) {
      writer.uint32(48).bool(message.isTopUser);
    }
    if (message.rankScore !== "0") {
      writer.uint32(56).int64(message.rankScore);
    }
    if (message.topUserNo !== "0") {
      writer.uint32(64).int64(message.topUserNo);
    }
    if (message.enterType !== "0") {
      writer.uint32(72).int64(message.enterType);
    }
    if (message.actionDescription !== "") {
      writer.uint32(90).string(message.actionDescription);
    }
    if (message.userId !== "0") {
      writer.uint32(96).int64(message.userId);
    }
    if (message.effectConfig !== undefined) {
      WebcastMemberMessage_EffectConfig.encode(message.effectConfig, writer.uint32(106).fork()).join();
    }
    if (message.popStr !== "") {
      writer.uint32(114).string(message.popStr);
    }
    if (message.enterEffectConfig !== undefined) {
      WebcastMemberMessage_EffectConfig.encode(message.enterEffectConfig, writer.uint32(122).fork()).join();
    }
    if (message.backgroundImage !== undefined) {
      Image.encode(message.backgroundImage, writer.uint32(130).fork()).join();
    }
    if (message.backgroundImageV2 !== undefined) {
      Image.encode(message.backgroundImageV2, writer.uint32(138).fork()).join();
    }
    if (message.anchorDisplayText !== undefined) {
      Text.encode(message.anchorDisplayText, writer.uint32(146).fork()).join();
    }
    if (message.clientEnterSource !== "") {
      writer.uint32(154).string(message.clientEnterSource);
    }
    if (message.clientEnterType !== "") {
      writer.uint32(162).string(message.clientEnterType);
    }
    if (message.clientLiveReason !== "") {
      writer.uint32(170).string(message.clientLiveReason);
    }
    if (message.actionDuration !== "0") {
      writer.uint32(176).int64(message.actionDuration);
    }
    if (message.userShareType !== "") {
      writer.uint32(186).string(message.userShareType);
    }
    if (message.displayStyle !== 0) {
      writer.uint32(192).int32(message.displayStyle);
    }
    Object.entries(message.adminPermissions).forEach(([key, value]) => {
      WebcastMemberMessage_AdminPermissionsEntry.encode({ key: key as any, value }, writer.uint32(202).fork()).join();
    });
    if (message.kickSource !== 0) {
      writer.uint32(208).int32(message.kickSource);
    }
    if (message.allowPreviewTime !== "0") {
      writer.uint32(216).int64(message.allowPreviewTime);
    }
    if (message.lastSubscriptionAction !== "0") {
      writer.uint32(224).int64(message.lastSubscriptionAction);
    }
    if (message.publicAreaMessageCommon !== undefined) {
      PublicAreaMessageCommon.encode(message.publicAreaMessageCommon, writer.uint32(234).fork()).join();
    }
    if (message.liveSubOnlyTier !== "0") {
      writer.uint32(240).int64(message.liveSubOnlyTier);
    }
    if (message.liveSubOnlyMonth !== "0") {
      writer.uint32(248).int64(message.liveSubOnlyMonth);
    }
    if (message.ecStreamerKey !== "") {
      writer.uint32(258).string(message.ecStreamerKey);
    }
    if (message.showWave !== "0") {
      writer.uint32(264).int64(message.showWave);
    }
    if (message.waveAlgorithmData !== undefined) {
      WebcastMemberMessage_WaveAlgorithmData.encode(message.waveAlgorithmData, writer.uint32(274).fork()).join();
    }
    if (message.hitAbStatus !== 0) {
      writer.uint32(280).int32(message.hitAbStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMemberMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMemberMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.memberCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.operator = User.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isSetToAdmin = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isTopUser = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.rankScore = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.topUserNo = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.enterType = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.actionDescription = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.effectConfig = WebcastMemberMessage_EffectConfig.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.popStr = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.enterEffectConfig = WebcastMemberMessage_EffectConfig.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.backgroundImage = Image.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.backgroundImageV2 = Image.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.anchorDisplayText = Text.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.clientEnterSource = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.clientEnterType = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.clientLiveReason = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.actionDuration = reader.int64().toString();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.userShareType = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.displayStyle = reader.int32() as any;
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          const entry25 = WebcastMemberMessage_AdminPermissionsEntry.decode(reader, reader.uint32());
          if (entry25.value !== undefined) {
            message.adminPermissions[entry25.key] = entry25.value;
          }
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.kickSource = reader.int32();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.allowPreviewTime = reader.int64().toString();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.lastSubscriptionAction = reader.int64().toString();
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.publicAreaMessageCommon = PublicAreaMessageCommon.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.liveSubOnlyTier = reader.int64().toString();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.liveSubOnlyMonth = reader.int64().toString();
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.ecStreamerKey = reader.string();
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.showWave = reader.int64().toString();
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.waveAlgorithmData = WebcastMemberMessage_WaveAlgorithmData.decode(reader, reader.uint32());
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.hitAbStatus = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastMemberMessage_AdminPermissionsEntry(): WebcastMemberMessage_AdminPermissionsEntry {
  return { key: 0, value: 0 };
}

export const WebcastMemberMessage_AdminPermissionsEntry: MessageFns<WebcastMemberMessage_AdminPermissionsEntry> = {
  encode(message: WebcastMemberMessage_AdminPermissionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMemberMessage_AdminPermissionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMemberMessage_AdminPermissionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastMemberMessage_EffectConfig(): WebcastMemberMessage_EffectConfig {
  return {
    type: "0",
    icon: undefined,
    avatarPos: "0",
    text: undefined,
    textIcon: undefined,
    stayTime: 0,
    animAssetId: "0",
    badge: undefined,
    flexSettingArrayList: [],
  };
}

export const WebcastMemberMessage_EffectConfig: MessageFns<WebcastMemberMessage_EffectConfig> = {
  encode(message: WebcastMemberMessage_EffectConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "0") {
      writer.uint32(8).int64(message.type);
    }
    if (message.icon !== undefined) {
      Image.encode(message.icon, writer.uint32(18).fork()).join();
    }
    if (message.avatarPos !== "0") {
      writer.uint32(24).int64(message.avatarPos);
    }
    if (message.text !== undefined) {
      Text.encode(message.text, writer.uint32(34).fork()).join();
    }
    if (message.textIcon !== undefined) {
      Image.encode(message.textIcon, writer.uint32(42).fork()).join();
    }
    if (message.stayTime !== 0) {
      writer.uint32(48).int32(message.stayTime);
    }
    if (message.animAssetId !== "0") {
      writer.uint32(56).int64(message.animAssetId);
    }
    if (message.badge !== undefined) {
      Image.encode(message.badge, writer.uint32(66).fork()).join();
    }
    writer.uint32(74).fork();
    for (const v of message.flexSettingArrayList) {
      writer.int64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMemberMessage_EffectConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMemberMessage_EffectConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.icon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.avatarPos = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.text = Text.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.textIcon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.stayTime = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.animAssetId = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.badge = Image.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag === 72) {
            message.flexSettingArrayList.push(reader.int64().toString());

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.flexSettingArrayList.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastMemberMessage_WaveAlgorithmData(): WebcastMemberMessage_WaveAlgorithmData {
  return { algorithmVersion: "", isAlgHit: false, predictScore: "", isRewatch: false, isFollow: false };
}

export const WebcastMemberMessage_WaveAlgorithmData: MessageFns<WebcastMemberMessage_WaveAlgorithmData> = {
  encode(message: WebcastMemberMessage_WaveAlgorithmData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algorithmVersion !== "") {
      writer.uint32(10).string(message.algorithmVersion);
    }
    if (message.isAlgHit !== false) {
      writer.uint32(16).bool(message.isAlgHit);
    }
    if (message.predictScore !== "") {
      writer.uint32(26).string(message.predictScore);
    }
    if (message.isRewatch !== false) {
      writer.uint32(32).bool(message.isRewatch);
    }
    if (message.isFollow !== false) {
      writer.uint32(40).bool(message.isFollow);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMemberMessage_WaveAlgorithmData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMemberMessage_WaveAlgorithmData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.algorithmVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isAlgHit = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.predictScore = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isRewatch = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isFollow = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastMemberMessage_EffectConfigBean(): WebcastMemberMessage_EffectConfigBean {
  return { type: 0, icon: undefined, textKey: undefined, badge: undefined };
}

export const WebcastMemberMessage_EffectConfigBean: MessageFns<WebcastMemberMessage_EffectConfigBean> = {
  encode(message: WebcastMemberMessage_EffectConfigBean, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.icon !== undefined) {
      ImageModel.encode(message.icon, writer.uint32(18).fork()).join();
    }
    if (message.textKey !== undefined) {
      Text.encode(message.textKey, writer.uint32(34).fork()).join();
    }
    if (message.badge !== undefined) {
      ImageModel.encode(message.badge, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMemberMessage_EffectConfigBean {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMemberMessage_EffectConfigBean();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.icon = ImageModel.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.textKey = Text.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.badge = ImageModel.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage(): WebcastGiftMessage {
  return {
    common: undefined,
    giftId: 0,
    user: undefined,
    repeatEnd: 0,
    groupId: "0",
    giftDetails: undefined,
    monitorExtra: "",
    fanTicketCount: "0",
    groupCount: 0,
    repeatCount: 0,
    comboCount: 0,
    toUser: undefined,
    textEffect: undefined,
    incomeTaskgifts: "0",
    roomFanTicketCount: "0",
    priority: undefined,
    logId: "",
    sendType: "0",
    publicAreaCommon: undefined,
    trayDisplayText: undefined,
    bannedDisplayEffects: "0",
    mTrayInfo: undefined,
    giftExtra: undefined,
    colorId: "0",
    isFirstSent: false,
    displayTextForAnchor: undefined,
    displayTextForAudience: undefined,
    orderId: "",
    giftsInBox: undefined,
    msgFilter: undefined,
    lynxExtra: [],
    userIdentity: undefined,
    matchInfo: undefined,
    linkmicGiftExpressionStrategy: 0,
    flyingMicResources: undefined,
    disableGiftTracking: false,
    asset: undefined,
    version: 0,
    sponsorshipInfo: [],
    flyingMicResourcesV2: undefined,
    publicAreaMessageCommon: undefined,
    signature: "",
    signatureVersion: "",
    multiGenerateMessage: false,
    toMemberId: "",
    toMemberIdInt: "0",
    toMemberNickname: "",
    interactiveGiftInfo: undefined,
  };
}

export const WebcastGiftMessage: MessageFns<WebcastGiftMessage> = {
  encode(message: WebcastGiftMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.giftId !== 0) {
      writer.uint32(16).int32(message.giftId);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(58).fork()).join();
    }
    if (message.repeatEnd !== 0) {
      writer.uint32(72).int32(message.repeatEnd);
    }
    if (message.groupId !== "0") {
      writer.uint32(88).uint64(message.groupId);
    }
    if (message.giftDetails !== undefined) {
      Gift.encode(message.giftDetails, writer.uint32(122).fork()).join();
    }
    if (message.monitorExtra !== "") {
      writer.uint32(178).string(message.monitorExtra);
    }
    if (message.fanTicketCount !== "0") {
      writer.uint32(24).int64(message.fanTicketCount);
    }
    if (message.groupCount !== 0) {
      writer.uint32(32).int32(message.groupCount);
    }
    if (message.repeatCount !== 0) {
      writer.uint32(40).int32(message.repeatCount);
    }
    if (message.comboCount !== 0) {
      writer.uint32(48).int32(message.comboCount);
    }
    if (message.toUser !== undefined) {
      User.encode(message.toUser, writer.uint32(66).fork()).join();
    }
    if (message.textEffect !== undefined) {
      WebcastGiftMessage_TextEffect.encode(message.textEffect, writer.uint32(82).fork()).join();
    }
    if (message.incomeTaskgifts !== "0") {
      writer.uint32(96).int64(message.incomeTaskgifts);
    }
    if (message.roomFanTicketCount !== "0") {
      writer.uint32(104).int64(message.roomFanTicketCount);
    }
    if (message.priority !== undefined) {
      WebcastGiftMessage_GiftIMPriority.encode(message.priority, writer.uint32(114).fork()).join();
    }
    if (message.logId !== "") {
      writer.uint32(130).string(message.logId);
    }
    if (message.sendType !== "0") {
      writer.uint32(136).int64(message.sendType);
    }
    if (message.publicAreaCommon !== undefined) {
      PublicAreaCommon.encode(message.publicAreaCommon, writer.uint32(146).fork()).join();
    }
    if (message.trayDisplayText !== undefined) {
      Text.encode(message.trayDisplayText, writer.uint32(154).fork()).join();
    }
    if (message.bannedDisplayEffects !== "0") {
      writer.uint32(160).int64(message.bannedDisplayEffects);
    }
    if (message.mTrayInfo !== undefined) {
      WebcastGiftMessage_GiftTrayInfo.encode(message.mTrayInfo, writer.uint32(170).fork()).join();
    }
    if (message.giftExtra !== undefined) {
      WebcastGiftMessage_GiftMonitorInfo.encode(message.giftExtra, writer.uint32(186).fork()).join();
    }
    if (message.colorId !== "0") {
      writer.uint32(192).int64(message.colorId);
    }
    if (message.isFirstSent !== false) {
      writer.uint32(200).bool(message.isFirstSent);
    }
    if (message.displayTextForAnchor !== undefined) {
      Text.encode(message.displayTextForAnchor, writer.uint32(210).fork()).join();
    }
    if (message.displayTextForAudience !== undefined) {
      Text.encode(message.displayTextForAudience, writer.uint32(218).fork()).join();
    }
    if (message.orderId !== "") {
      writer.uint32(226).string(message.orderId);
    }
    if (message.giftsInBox !== undefined) {
      WebcastGiftMessage_GiftsBoxInfo.encode(message.giftsInBox, writer.uint32(234).fork()).join();
    }
    if (message.msgFilter !== undefined) {
      MsgFilter.encode(message.msgFilter, writer.uint32(242).fork()).join();
    }
    for (const v of message.lynxExtra) {
      WebcastGiftMessage_LynxGiftExtra.encode(v!, writer.uint32(250).fork()).join();
    }
    if (message.userIdentity !== undefined) {
      UserIdentity.encode(message.userIdentity, writer.uint32(258).fork()).join();
    }
    if (message.matchInfo !== undefined) {
      WebcastGiftMessage_MatchInfo.encode(message.matchInfo, writer.uint32(266).fork()).join();
    }
    if (message.linkmicGiftExpressionStrategy !== 0) {
      writer.uint32(272).int32(message.linkmicGiftExpressionStrategy);
    }
    if (message.flyingMicResources !== undefined) {
      WebcastGiftMessage_FlyingMicResources.encode(message.flyingMicResources, writer.uint32(282).fork()).join();
    }
    if (message.disableGiftTracking !== false) {
      writer.uint32(288).bool(message.disableGiftTracking);
    }
    if (message.asset !== undefined) {
      WebcastGiftMessage_AssetsModel.encode(message.asset, writer.uint32(298).fork()).join();
    }
    if (message.version !== 0) {
      writer.uint32(304).int32(message.version);
    }
    for (const v of message.sponsorshipInfo) {
      WebcastGiftMessage_SponsorshipInfo.encode(v!, writer.uint32(314).fork()).join();
    }
    if (message.flyingMicResourcesV2 !== undefined) {
      WebcastGiftMessage_FlyingMicResources.encode(message.flyingMicResourcesV2, writer.uint32(322).fork()).join();
    }
    if (message.publicAreaMessageCommon !== undefined) {
      PublicAreaMessageCommon.encode(message.publicAreaMessageCommon, writer.uint32(330).fork()).join();
    }
    if (message.signature !== "") {
      writer.uint32(338).string(message.signature);
    }
    if (message.signatureVersion !== "") {
      writer.uint32(346).string(message.signatureVersion);
    }
    if (message.multiGenerateMessage !== false) {
      writer.uint32(352).bool(message.multiGenerateMessage);
    }
    if (message.toMemberId !== "") {
      writer.uint32(362).string(message.toMemberId);
    }
    if (message.toMemberIdInt !== "0") {
      writer.uint32(368).int64(message.toMemberIdInt);
    }
    if (message.toMemberNickname !== "") {
      writer.uint32(378).string(message.toMemberNickname);
    }
    if (message.interactiveGiftInfo !== undefined) {
      WebcastGiftMessage_InteractiveGiftInfo.encode(message.interactiveGiftInfo, writer.uint32(386).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.giftId = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.repeatEnd = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.groupId = reader.uint64().toString();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.giftDetails = Gift.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.monitorExtra = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fanTicketCount = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.groupCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.repeatCount = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.comboCount = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.toUser = User.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.textEffect = WebcastGiftMessage_TextEffect.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.incomeTaskgifts = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.roomFanTicketCount = reader.int64().toString();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.priority = WebcastGiftMessage_GiftIMPriority.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.logId = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.sendType = reader.int64().toString();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.publicAreaCommon = PublicAreaCommon.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.trayDisplayText = Text.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.bannedDisplayEffects = reader.int64().toString();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.mTrayInfo = WebcastGiftMessage_GiftTrayInfo.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.giftExtra = WebcastGiftMessage_GiftMonitorInfo.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.colorId = reader.int64().toString();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.isFirstSent = reader.bool();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.displayTextForAnchor = Text.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.displayTextForAudience = Text.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.giftsInBox = WebcastGiftMessage_GiftsBoxInfo.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.msgFilter = MsgFilter.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.lynxExtra.push(WebcastGiftMessage_LynxGiftExtra.decode(reader, reader.uint32()));
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.userIdentity = UserIdentity.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.matchInfo = WebcastGiftMessage_MatchInfo.decode(reader, reader.uint32());
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.linkmicGiftExpressionStrategy = reader.int32() as any;
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.flyingMicResources = WebcastGiftMessage_FlyingMicResources.decode(reader, reader.uint32());
          continue;
        }
        case 36: {
          if (tag !== 288) {
            break;
          }

          message.disableGiftTracking = reader.bool();
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.asset = WebcastGiftMessage_AssetsModel.decode(reader, reader.uint32());
          continue;
        }
        case 38: {
          if (tag !== 304) {
            break;
          }

          message.version = reader.int32() as any;
          continue;
        }
        case 39: {
          if (tag !== 314) {
            break;
          }

          message.sponsorshipInfo.push(WebcastGiftMessage_SponsorshipInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.flyingMicResourcesV2 = WebcastGiftMessage_FlyingMicResources.decode(reader, reader.uint32());
          continue;
        }
        case 41: {
          if (tag !== 330) {
            break;
          }

          message.publicAreaMessageCommon = PublicAreaMessageCommon.decode(reader, reader.uint32());
          continue;
        }
        case 42: {
          if (tag !== 338) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 43: {
          if (tag !== 346) {
            break;
          }

          message.signatureVersion = reader.string();
          continue;
        }
        case 44: {
          if (tag !== 352) {
            break;
          }

          message.multiGenerateMessage = reader.bool();
          continue;
        }
        case 45: {
          if (tag !== 362) {
            break;
          }

          message.toMemberId = reader.string();
          continue;
        }
        case 46: {
          if (tag !== 368) {
            break;
          }

          message.toMemberIdInt = reader.int64().toString();
          continue;
        }
        case 47: {
          if (tag !== 378) {
            break;
          }

          message.toMemberNickname = reader.string();
          continue;
        }
        case 48: {
          if (tag !== 386) {
            break;
          }

          message.interactiveGiftInfo = WebcastGiftMessage_InteractiveGiftInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_InteractiveGiftInfo(): WebcastGiftMessage_InteractiveGiftInfo {
  return { crossScreenDelay: "0", crossScreenRole: "0", ignoreConfig: 0, uniqId: "0", toUserTeamId: "0" };
}

export const WebcastGiftMessage_InteractiveGiftInfo: MessageFns<WebcastGiftMessage_InteractiveGiftInfo> = {
  encode(message: WebcastGiftMessage_InteractiveGiftInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.crossScreenDelay !== "0") {
      writer.uint32(8).int64(message.crossScreenDelay);
    }
    if (message.crossScreenRole !== "0") {
      writer.uint32(16).int64(message.crossScreenRole);
    }
    if (message.ignoreConfig !== 0) {
      writer.uint32(24).int32(message.ignoreConfig);
    }
    if (message.uniqId !== "0") {
      writer.uint32(32).int64(message.uniqId);
    }
    if (message.toUserTeamId !== "0") {
      writer.uint32(40).int64(message.toUserTeamId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_InteractiveGiftInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_InteractiveGiftInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.crossScreenDelay = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.crossScreenRole = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.ignoreConfig = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uniqId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.toUserTeamId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_GiftIMPriority(): WebcastGiftMessage_GiftIMPriority {
  return { queueSizesList: [], selfQueuePriority: "0", priority: "0" };
}

export const WebcastGiftMessage_GiftIMPriority: MessageFns<WebcastGiftMessage_GiftIMPriority> = {
  encode(message: WebcastGiftMessage_GiftIMPriority, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.queueSizesList) {
      writer.int64(v);
    }
    writer.join();
    if (message.selfQueuePriority !== "0") {
      writer.uint32(16).int64(message.selfQueuePriority);
    }
    if (message.priority !== "0") {
      writer.uint32(24).int64(message.priority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_GiftIMPriority {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_GiftIMPriority();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.queueSizesList.push(reader.int64().toString());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.queueSizesList.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.selfQueuePriority = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.priority = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_TextEffect(): WebcastGiftMessage_TextEffect {
  return { portraitDetail: undefined, landscapeDetail: undefined };
}

export const WebcastGiftMessage_TextEffect: MessageFns<WebcastGiftMessage_TextEffect> = {
  encode(message: WebcastGiftMessage_TextEffect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.portraitDetail !== undefined) {
      WebcastGiftMessage_TextEffect_Detail.encode(message.portraitDetail, writer.uint32(10).fork()).join();
    }
    if (message.landscapeDetail !== undefined) {
      WebcastGiftMessage_TextEffect_Detail.encode(message.landscapeDetail, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_TextEffect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_TextEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.portraitDetail = WebcastGiftMessage_TextEffect_Detail.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.landscapeDetail = WebcastGiftMessage_TextEffect_Detail.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_TextEffect_Detail(): WebcastGiftMessage_TextEffect_Detail {
  return {
    text: undefined,
    textFontSize: 0,
    background: undefined,
    start: "0",
    duration: "0",
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    shadowDx: 0,
    shadowDy: 0,
    shadowRadius: 0,
    shadowColor: "",
    strokeColor: "",
    strokeWidth: 0,
  };
}

export const WebcastGiftMessage_TextEffect_Detail: MessageFns<WebcastGiftMessage_TextEffect_Detail> = {
  encode(message: WebcastGiftMessage_TextEffect_Detail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== undefined) {
      Text.encode(message.text, writer.uint32(10).fork()).join();
    }
    if (message.textFontSize !== 0) {
      writer.uint32(16).int32(message.textFontSize);
    }
    if (message.background !== undefined) {
      Image.encode(message.background, writer.uint32(26).fork()).join();
    }
    if (message.start !== "0") {
      writer.uint32(32).int64(message.start);
    }
    if (message.duration !== "0") {
      writer.uint32(40).int64(message.duration);
    }
    if (message.x !== 0) {
      writer.uint32(48).int32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(56).int32(message.y);
    }
    if (message.width !== 0) {
      writer.uint32(64).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(72).int32(message.height);
    }
    if (message.shadowDx !== 0) {
      writer.uint32(80).int32(message.shadowDx);
    }
    if (message.shadowDy !== 0) {
      writer.uint32(88).int32(message.shadowDy);
    }
    if (message.shadowRadius !== 0) {
      writer.uint32(96).int32(message.shadowRadius);
    }
    if (message.shadowColor !== "") {
      writer.uint32(106).string(message.shadowColor);
    }
    if (message.strokeColor !== "") {
      writer.uint32(114).string(message.strokeColor);
    }
    if (message.strokeWidth !== 0) {
      writer.uint32(120).int32(message.strokeWidth);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_TextEffect_Detail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_TextEffect_Detail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = Text.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.textFontSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.background = Image.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.start = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.duration = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.x = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.y = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.shadowDx = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.shadowDy = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.shadowRadius = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.shadowColor = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.strokeColor = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.strokeWidth = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_GiftTrayInfo(): WebcastGiftMessage_GiftTrayInfo {
  return {
    mDynamicImg: undefined,
    canMirror: false,
    trayNormalBgImg: undefined,
    trayNormalBgColor: [],
    traySmallBgImg: undefined,
    traySmallBgColor: [],
    rightTagText: undefined,
    rightTagBgImg: undefined,
    rightTagBgColor: [],
    trayNameTextColor: "",
    trayDescTextColor: "",
    rightTagJumpSchema: "",
  };
}

export const WebcastGiftMessage_GiftTrayInfo: MessageFns<WebcastGiftMessage_GiftTrayInfo> = {
  encode(message: WebcastGiftMessage_GiftTrayInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mDynamicImg !== undefined) {
      Image.encode(message.mDynamicImg, writer.uint32(10).fork()).join();
    }
    if (message.canMirror !== false) {
      writer.uint32(16).bool(message.canMirror);
    }
    if (message.trayNormalBgImg !== undefined) {
      Image.encode(message.trayNormalBgImg, writer.uint32(26).fork()).join();
    }
    for (const v of message.trayNormalBgColor) {
      writer.uint32(34).string(v!);
    }
    if (message.traySmallBgImg !== undefined) {
      Image.encode(message.traySmallBgImg, writer.uint32(42).fork()).join();
    }
    for (const v of message.traySmallBgColor) {
      writer.uint32(50).string(v!);
    }
    if (message.rightTagText !== undefined) {
      Text.encode(message.rightTagText, writer.uint32(58).fork()).join();
    }
    if (message.rightTagBgImg !== undefined) {
      Image.encode(message.rightTagBgImg, writer.uint32(66).fork()).join();
    }
    for (const v of message.rightTagBgColor) {
      writer.uint32(74).string(v!);
    }
    if (message.trayNameTextColor !== "") {
      writer.uint32(82).string(message.trayNameTextColor);
    }
    if (message.trayDescTextColor !== "") {
      writer.uint32(90).string(message.trayDescTextColor);
    }
    if (message.rightTagJumpSchema !== "") {
      writer.uint32(98).string(message.rightTagJumpSchema);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_GiftTrayInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_GiftTrayInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mDynamicImg = Image.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.canMirror = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.trayNormalBgImg = Image.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.trayNormalBgColor.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.traySmallBgImg = Image.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.traySmallBgColor.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rightTagText = Text.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.rightTagBgImg = Image.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.rightTagBgColor.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.trayNameTextColor = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.trayDescTextColor = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.rightTagJumpSchema = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_GiftMonitorInfo(): WebcastGiftMessage_GiftMonitorInfo {
  return {
    anchorId: "0",
    profitApiMessageDur: "0",
    sendGiftProfitApiStartMs: "0",
    sendGiftProfitCoreStartMs: "0",
    sendGiftReqStartMs: "0",
    sendGiftSendMessageSuccessMs: "0",
    sendProfitApiDur: "0",
    toUserId: "0",
    sendGiftStartClientLocalMs: "0",
    fromPlatform: "",
    fromVersion: "",
  };
}

export const WebcastGiftMessage_GiftMonitorInfo: MessageFns<WebcastGiftMessage_GiftMonitorInfo> = {
  encode(message: WebcastGiftMessage_GiftMonitorInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.anchorId !== "0") {
      writer.uint32(8).int64(message.anchorId);
    }
    if (message.profitApiMessageDur !== "0") {
      writer.uint32(16).int64(message.profitApiMessageDur);
    }
    if (message.sendGiftProfitApiStartMs !== "0") {
      writer.uint32(24).int64(message.sendGiftProfitApiStartMs);
    }
    if (message.sendGiftProfitCoreStartMs !== "0") {
      writer.uint32(32).int64(message.sendGiftProfitCoreStartMs);
    }
    if (message.sendGiftReqStartMs !== "0") {
      writer.uint32(40).int64(message.sendGiftReqStartMs);
    }
    if (message.sendGiftSendMessageSuccessMs !== "0") {
      writer.uint32(48).int64(message.sendGiftSendMessageSuccessMs);
    }
    if (message.sendProfitApiDur !== "0") {
      writer.uint32(56).int64(message.sendProfitApiDur);
    }
    if (message.toUserId !== "0") {
      writer.uint32(64).int64(message.toUserId);
    }
    if (message.sendGiftStartClientLocalMs !== "0") {
      writer.uint32(72).int64(message.sendGiftStartClientLocalMs);
    }
    if (message.fromPlatform !== "") {
      writer.uint32(82).string(message.fromPlatform);
    }
    if (message.fromVersion !== "") {
      writer.uint32(90).string(message.fromVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_GiftMonitorInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_GiftMonitorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.anchorId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.profitApiMessageDur = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sendGiftProfitApiStartMs = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sendGiftProfitCoreStartMs = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sendGiftReqStartMs = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sendGiftSendMessageSuccessMs = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.sendProfitApiDur = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.toUserId = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.sendGiftStartClientLocalMs = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.fromPlatform = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.fromVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_MatchInfo(): WebcastGiftMessage_MatchInfo {
  return { critical: "0", effectCardInUse: false, multiplierType: 0, multiplierValue: "0" };
}

export const WebcastGiftMessage_MatchInfo: MessageFns<WebcastGiftMessage_MatchInfo> = {
  encode(message: WebcastGiftMessage_MatchInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.critical !== "0") {
      writer.uint32(8).int64(message.critical);
    }
    if (message.effectCardInUse !== false) {
      writer.uint32(16).bool(message.effectCardInUse);
    }
    if (message.multiplierType !== 0) {
      writer.uint32(24).int32(message.multiplierType);
    }
    if (message.multiplierValue !== "0") {
      writer.uint32(32).int64(message.multiplierValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_MatchInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_MatchInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.critical = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.effectCardInUse = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.multiplierType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.multiplierValue = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_GiftsBoxInfo(): WebcastGiftMessage_GiftsBoxInfo {
  return { gifts: [] };
}

export const WebcastGiftMessage_GiftsBoxInfo: MessageFns<WebcastGiftMessage_GiftsBoxInfo> = {
  encode(message: WebcastGiftMessage_GiftsBoxInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.gifts) {
      WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_GiftsBoxInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_GiftsBoxInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gifts.push(WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox(): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox {
  return { giftId: "0", effectId: "0", colorId: "0", remainTimes: 0, asset: undefined };
}

export const WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox: MessageFns<WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox> =
  {
    encode(
      message: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.giftId !== "0") {
        writer.uint32(8).int64(message.giftId);
      }
      if (message.effectId !== "0") {
        writer.uint32(16).int64(message.effectId);
      }
      if (message.colorId !== "0") {
        writer.uint32(24).int64(message.colorId);
      }
      if (message.remainTimes !== 0) {
        writer.uint32(32).int32(message.remainTimes);
      }
      if (message.asset !== undefined) {
        WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel.encode(message.asset, writer.uint32(42).fork())
          .join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.giftId = reader.int64().toString();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.effectId = reader.int64().toString();
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.colorId = reader.int64().toString();
            continue;
          }
          case 4: {
            if (tag !== 32) {
              break;
            }

            message.remainTimes = reader.int32();
            continue;
          }
          case 5: {
            if (tag !== 42) {
              break;
            }

            message.asset = WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel(): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel {
  return {
    name: "",
    resourceUri: "",
    resourceModel: undefined,
    describe: "",
    id: "0",
    resourceType: 0,
    md5: "",
    size: "0",
    lokiExtraContent: undefined,
    downloadType: 0,
    resourceByteVC1Model: undefined,
    bytevc1Md5: "",
    videoResourceList: [],
    faceRecognitionArchiveMeta: undefined,
    lynxUrlSettingsKey: "",
    downgradeResourceType: 0,
    assetExtra: undefined,
    stickerAssetVariant: 0,
    immediateDownload: false,
    stickerAssetVariantReason: 0,
  };
}

export const WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel: MessageFns<
  WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel
> = {
  encode(
    message: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.resourceUri !== "") {
      writer.uint32(18).string(message.resourceUri);
    }
    if (message.resourceModel !== undefined) {
      WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel.encode(
        message.resourceModel,
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.describe !== "") {
      writer.uint32(42).string(message.describe);
    }
    if (message.id !== "0") {
      writer.uint32(48).int64(message.id);
    }
    if (message.resourceType !== 0) {
      writer.uint32(56).int32(message.resourceType);
    }
    if (message.md5 !== "") {
      writer.uint32(66).string(message.md5);
    }
    if (message.size !== "0") {
      writer.uint32(72).int64(message.size);
    }
    if (message.lokiExtraContent !== undefined) {
      WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent.encode(
        message.lokiExtraContent,
        writer.uint32(82).fork(),
      ).join();
    }
    if (message.downloadType !== 0) {
      writer.uint32(208).int32(message.downloadType);
    }
    if (message.resourceByteVC1Model !== undefined) {
      WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel.encode(
        message.resourceByteVC1Model,
        writer.uint32(226).fork(),
      ).join();
    }
    if (message.bytevc1Md5 !== "") {
      writer.uint32(234).string(message.bytevc1Md5);
    }
    for (const v of message.videoResourceList) {
      WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource.encode(v!, writer.uint32(242).fork())
        .join();
    }
    if (message.faceRecognitionArchiveMeta !== undefined) {
      WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta.encode(
        message.faceRecognitionArchiveMeta,
        writer.uint32(250).fork(),
      ).join();
    }
    if (message.lynxUrlSettingsKey !== "") {
      writer.uint32(258).string(message.lynxUrlSettingsKey);
    }
    if (message.downgradeResourceType !== 0) {
      writer.uint32(264).int32(message.downgradeResourceType);
    }
    if (message.assetExtra !== undefined) {
      WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra.encode(
        message.assetExtra,
        writer.uint32(274).fork(),
      ).join();
    }
    if (message.stickerAssetVariant !== 0) {
      writer.uint32(280).int32(message.stickerAssetVariant);
    }
    if (message.immediateDownload !== false) {
      writer.uint32(288).bool(message.immediateDownload);
    }
    if (message.stickerAssetVariantReason !== 0) {
      writer.uint32(296).int32(message.stickerAssetVariantReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resourceUri = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.resourceModel = WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.describe = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.resourceType = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.md5 = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.size = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.lokiExtraContent = WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.downloadType = reader.int32();
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.resourceByteVC1Model = WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.bytevc1Md5 = reader.string();
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.videoResourceList.push(
            WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.faceRecognitionArchiveMeta =
            WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta.decode(
              reader,
              reader.uint32(),
            );
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.lynxUrlSettingsKey = reader.string();
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.downgradeResourceType = reader.int32();
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.assetExtra = WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.stickerAssetVariant = reader.int32();
          continue;
        }
        case 36: {
          if (tag !== 288) {
            break;
          }

          message.immediateDownload = reader.bool();
          continue;
        }
        case 37: {
          if (tag !== 296) {
            break;
          }

          message.stickerAssetVariantReason = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra(): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra {
  return { effectStarlingKey: "" };
}

export const WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra: MessageFns<
  WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra
> = {
  encode(
    message: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.effectStarlingKey !== "") {
      writer.uint32(10).string(message.effectStarlingKey);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.effectStarlingKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel(): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel {
  return { urlList: [], uri: "" };
}

export const WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel: MessageFns<
  WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel
> = {
  encode(
    message: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.urlList) {
      writer.uint32(10).string(v!);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.urlList.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent(): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent {
  return {
    giftType: "",
    giftDuration: "0",
    needScreenShot: false,
    ismultiFrame: false,
    viewOverlay: "",
    befViewRenderSize: undefined,
    befViewRenderFPS: 0,
    befViewFitMode: 0,
    modelNames: "",
    requirements: [],
  };
}

export const WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent: MessageFns<
  WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent
> = {
  encode(
    message: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.giftType !== "") {
      writer.uint32(10).string(message.giftType);
    }
    if (message.giftDuration !== "0") {
      writer.uint32(16).int64(message.giftDuration);
    }
    if (message.needScreenShot !== false) {
      writer.uint32(24).bool(message.needScreenShot);
    }
    if (message.ismultiFrame !== false) {
      writer.uint32(32).bool(message.ismultiFrame);
    }
    if (message.viewOverlay !== "") {
      writer.uint32(42).string(message.viewOverlay);
    }
    if (message.befViewRenderSize !== undefined) {
      WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize.encode(
        message.befViewRenderSize,
        writer.uint32(50).fork(),
      ).join();
    }
    if (message.befViewRenderFPS !== 0) {
      writer.uint32(56).int32(message.befViewRenderFPS);
    }
    if (message.befViewFitMode !== 0) {
      writer.uint32(64).int32(message.befViewFitMode);
    }
    if (message.modelNames !== "") {
      writer.uint32(74).string(message.modelNames);
    }
    for (const v of message.requirements) {
      writer.uint32(82).string(v!);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.giftType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.giftDuration = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.needScreenShot = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ismultiFrame = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.viewOverlay = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.befViewRenderSize =
            WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize.decode(
              reader,
              reader.uint32(),
            );
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.befViewRenderFPS = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.befViewFitMode = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.modelNames = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.requirements.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize(): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize {
  return { with: 0, height: 0 };
}

export const WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize: MessageFns<
  WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize
> = {
  encode(
    message: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.with !== 0) {
      writer.uint32(8).int32(message.with);
    }
    if (message.height !== 0) {
      writer.uint32(16).int32(message.height);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message =
      createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.with = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource(): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource {
  return { videoTypeName: "", videoUrl: undefined, videoMd5: "" };
}

export const WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource: MessageFns<
  WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource
> = {
  encode(
    message: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.videoTypeName !== "") {
      writer.uint32(10).string(message.videoTypeName);
    }
    if (message.videoUrl !== undefined) {
      WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel.encode(
        message.videoUrl,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.videoMd5 !== "") {
      writer.uint32(26).string(message.videoMd5);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.videoTypeName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.videoUrl = WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.videoMd5 = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta(): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta {
  return { version: "", requirements: [], modelNames: "", sdkExtra: "" };
}

export const WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta: MessageFns<
  WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta
> = {
  encode(
    message: WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    for (const v of message.requirements) {
      writer.uint32(18).string(v!);
    }
    if (message.modelNames !== "") {
      writer.uint32(26).string(message.modelNames);
    }
    if (message.sdkExtra !== "") {
      writer.uint32(34).string(message.sdkExtra);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requirements.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelNames = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sdkExtra = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_AssetsModel(): WebcastGiftMessage_AssetsModel {
  return {
    name: "",
    resourceUri: "",
    resourceModel: undefined,
    describe: "",
    id: "0",
    resourceType: 0,
    md5: "",
    size: "0",
    lokiExtraContent: undefined,
    downloadType: 0,
    resourceByteVC1Model: undefined,
    bytevc1Md5: "",
    videoResourceList: [],
    faceRecognitionArchiveMeta: undefined,
    lynxUrlSettingsKey: "",
    downgradeResourceType: 0,
    assetExtra: undefined,
    stickerAssetVariant: 0,
    immediateDownload: false,
    stickerAssetVariantReason: 0,
  };
}

export const WebcastGiftMessage_AssetsModel: MessageFns<WebcastGiftMessage_AssetsModel> = {
  encode(message: WebcastGiftMessage_AssetsModel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.resourceUri !== "") {
      writer.uint32(18).string(message.resourceUri);
    }
    if (message.resourceModel !== undefined) {
      WebcastGiftMessage_AssetsModel_ResourceModel.encode(message.resourceModel, writer.uint32(34).fork()).join();
    }
    if (message.describe !== "") {
      writer.uint32(42).string(message.describe);
    }
    if (message.id !== "0") {
      writer.uint32(48).int64(message.id);
    }
    if (message.resourceType !== 0) {
      writer.uint32(56).int32(message.resourceType);
    }
    if (message.md5 !== "") {
      writer.uint32(66).string(message.md5);
    }
    if (message.size !== "0") {
      writer.uint32(72).int64(message.size);
    }
    if (message.lokiExtraContent !== undefined) {
      WebcastGiftMessage_AssetsModel_LokiExtraContent.encode(message.lokiExtraContent, writer.uint32(82).fork()).join();
    }
    if (message.downloadType !== 0) {
      writer.uint32(208).int32(message.downloadType);
    }
    if (message.resourceByteVC1Model !== undefined) {
      WebcastGiftMessage_AssetsModel_ResourceModel.encode(message.resourceByteVC1Model, writer.uint32(226).fork())
        .join();
    }
    if (message.bytevc1Md5 !== "") {
      writer.uint32(234).string(message.bytevc1Md5);
    }
    for (const v of message.videoResourceList) {
      WebcastGiftMessage_AssetsModel_VideoResource.encode(v!, writer.uint32(242).fork()).join();
    }
    if (message.faceRecognitionArchiveMeta !== undefined) {
      WebcastGiftMessage_AssetsModel_FaceRecognitionMeta.encode(
        message.faceRecognitionArchiveMeta,
        writer.uint32(250).fork(),
      ).join();
    }
    if (message.lynxUrlSettingsKey !== "") {
      writer.uint32(258).string(message.lynxUrlSettingsKey);
    }
    if (message.downgradeResourceType !== 0) {
      writer.uint32(264).int32(message.downgradeResourceType);
    }
    if (message.assetExtra !== undefined) {
      WebcastGiftMessage_AssetsModel_AssetExtra.encode(message.assetExtra, writer.uint32(274).fork()).join();
    }
    if (message.stickerAssetVariant !== 0) {
      writer.uint32(280).int32(message.stickerAssetVariant);
    }
    if (message.immediateDownload !== false) {
      writer.uint32(288).bool(message.immediateDownload);
    }
    if (message.stickerAssetVariantReason !== 0) {
      writer.uint32(296).int32(message.stickerAssetVariantReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_AssetsModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_AssetsModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resourceUri = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.resourceModel = WebcastGiftMessage_AssetsModel_ResourceModel.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.describe = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.resourceType = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.md5 = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.size = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.lokiExtraContent = WebcastGiftMessage_AssetsModel_LokiExtraContent.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.downloadType = reader.int32();
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.resourceByteVC1Model = WebcastGiftMessage_AssetsModel_ResourceModel.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.bytevc1Md5 = reader.string();
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.videoResourceList.push(WebcastGiftMessage_AssetsModel_VideoResource.decode(reader, reader.uint32()));
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.faceRecognitionArchiveMeta = WebcastGiftMessage_AssetsModel_FaceRecognitionMeta.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.lynxUrlSettingsKey = reader.string();
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.downgradeResourceType = reader.int32();
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.assetExtra = WebcastGiftMessage_AssetsModel_AssetExtra.decode(reader, reader.uint32());
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.stickerAssetVariant = reader.int32();
          continue;
        }
        case 36: {
          if (tag !== 288) {
            break;
          }

          message.immediateDownload = reader.bool();
          continue;
        }
        case 37: {
          if (tag !== 296) {
            break;
          }

          message.stickerAssetVariantReason = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_AssetsModel_AssetExtra(): WebcastGiftMessage_AssetsModel_AssetExtra {
  return { effectStarlingKey: "" };
}

export const WebcastGiftMessage_AssetsModel_AssetExtra: MessageFns<WebcastGiftMessage_AssetsModel_AssetExtra> = {
  encode(message: WebcastGiftMessage_AssetsModel_AssetExtra, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.effectStarlingKey !== "") {
      writer.uint32(10).string(message.effectStarlingKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_AssetsModel_AssetExtra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_AssetsModel_AssetExtra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.effectStarlingKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_AssetsModel_ResourceModel(): WebcastGiftMessage_AssetsModel_ResourceModel {
  return { urlList: [], uri: "" };
}

export const WebcastGiftMessage_AssetsModel_ResourceModel: MessageFns<WebcastGiftMessage_AssetsModel_ResourceModel> = {
  encode(
    message: WebcastGiftMessage_AssetsModel_ResourceModel,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.urlList) {
      writer.uint32(10).string(v!);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_AssetsModel_ResourceModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_AssetsModel_ResourceModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.urlList.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_AssetsModel_LokiExtraContent(): WebcastGiftMessage_AssetsModel_LokiExtraContent {
  return {
    giftType: "",
    giftDuration: "0",
    needScreenShot: false,
    ismultiFrame: false,
    viewOverlay: "",
    befViewRenderSize: undefined,
    befViewRenderFPS: 0,
    befViewFitMode: 0,
    modelNames: "",
    requirements: [],
  };
}

export const WebcastGiftMessage_AssetsModel_LokiExtraContent: MessageFns<
  WebcastGiftMessage_AssetsModel_LokiExtraContent
> = {
  encode(
    message: WebcastGiftMessage_AssetsModel_LokiExtraContent,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.giftType !== "") {
      writer.uint32(10).string(message.giftType);
    }
    if (message.giftDuration !== "0") {
      writer.uint32(16).int64(message.giftDuration);
    }
    if (message.needScreenShot !== false) {
      writer.uint32(24).bool(message.needScreenShot);
    }
    if (message.ismultiFrame !== false) {
      writer.uint32(32).bool(message.ismultiFrame);
    }
    if (message.viewOverlay !== "") {
      writer.uint32(42).string(message.viewOverlay);
    }
    if (message.befViewRenderSize !== undefined) {
      WebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize.encode(
        message.befViewRenderSize,
        writer.uint32(50).fork(),
      ).join();
    }
    if (message.befViewRenderFPS !== 0) {
      writer.uint32(56).int32(message.befViewRenderFPS);
    }
    if (message.befViewFitMode !== 0) {
      writer.uint32(64).int32(message.befViewFitMode);
    }
    if (message.modelNames !== "") {
      writer.uint32(74).string(message.modelNames);
    }
    for (const v of message.requirements) {
      writer.uint32(82).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_AssetsModel_LokiExtraContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_AssetsModel_LokiExtraContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.giftType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.giftDuration = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.needScreenShot = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ismultiFrame = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.viewOverlay = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.befViewRenderSize = WebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.befViewRenderFPS = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.befViewFitMode = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.modelNames = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.requirements.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize(): WebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize {
  return { with: 0, height: 0 };
}

export const WebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize: MessageFns<
  WebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize
> = {
  encode(
    message: WebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.with !== 0) {
      writer.uint32(8).int32(message.with);
    }
    if (message.height !== 0) {
      writer.uint32(16).int32(message.height);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.with = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_AssetsModel_VideoResource(): WebcastGiftMessage_AssetsModel_VideoResource {
  return { videoTypeName: "", videoUrl: undefined, videoMd5: "" };
}

export const WebcastGiftMessage_AssetsModel_VideoResource: MessageFns<WebcastGiftMessage_AssetsModel_VideoResource> = {
  encode(
    message: WebcastGiftMessage_AssetsModel_VideoResource,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.videoTypeName !== "") {
      writer.uint32(10).string(message.videoTypeName);
    }
    if (message.videoUrl !== undefined) {
      WebcastGiftMessage_AssetsModel_ResourceModel.encode(message.videoUrl, writer.uint32(18).fork()).join();
    }
    if (message.videoMd5 !== "") {
      writer.uint32(26).string(message.videoMd5);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_AssetsModel_VideoResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_AssetsModel_VideoResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.videoTypeName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.videoUrl = WebcastGiftMessage_AssetsModel_ResourceModel.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.videoMd5 = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_AssetsModel_FaceRecognitionMeta(): WebcastGiftMessage_AssetsModel_FaceRecognitionMeta {
  return { version: "", requirements: [], modelNames: "", sdkExtra: "" };
}

export const WebcastGiftMessage_AssetsModel_FaceRecognitionMeta: MessageFns<
  WebcastGiftMessage_AssetsModel_FaceRecognitionMeta
> = {
  encode(
    message: WebcastGiftMessage_AssetsModel_FaceRecognitionMeta,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    for (const v of message.requirements) {
      writer.uint32(18).string(v!);
    }
    if (message.modelNames !== "") {
      writer.uint32(26).string(message.modelNames);
    }
    if (message.sdkExtra !== "") {
      writer.uint32(34).string(message.sdkExtra);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_AssetsModel_FaceRecognitionMeta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_AssetsModel_FaceRecognitionMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requirements.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelNames = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sdkExtra = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_LynxGiftExtra(): WebcastGiftMessage_LynxGiftExtra {
  return { id: "0", code: "0", type: "0", params: [], extra: "" };
}

export const WebcastGiftMessage_LynxGiftExtra: MessageFns<WebcastGiftMessage_LynxGiftExtra> = {
  encode(message: WebcastGiftMessage_LynxGiftExtra, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.code !== "0") {
      writer.uint32(16).int64(message.code);
    }
    if (message.type !== "0") {
      writer.uint32(24).int64(message.type);
    }
    for (const v of message.params) {
      writer.uint32(34).string(v!);
    }
    if (message.extra !== "") {
      writer.uint32(42).string(message.extra);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_LynxGiftExtra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_LynxGiftExtra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.code = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.params.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.extra = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_FlyingMicResources(): WebcastGiftMessage_FlyingMicResources {
  return { pathImage: undefined, micImage: undefined, transitionConfigs: [] };
}

export const WebcastGiftMessage_FlyingMicResources: MessageFns<WebcastGiftMessage_FlyingMicResources> = {
  encode(message: WebcastGiftMessage_FlyingMicResources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pathImage !== undefined) {
      Image.encode(message.pathImage, writer.uint32(10).fork()).join();
    }
    if (message.micImage !== undefined) {
      Image.encode(message.micImage, writer.uint32(18).fork()).join();
    }
    for (const v of message.transitionConfigs) {
      WebcastGiftMessage_FlyingMicResources_TransitionConfig.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_FlyingMicResources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_FlyingMicResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pathImage = Image.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.micImage = Image.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transitionConfigs.push(
            WebcastGiftMessage_FlyingMicResources_TransitionConfig.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_FlyingMicResources_TransitionConfig(): WebcastGiftMessage_FlyingMicResources_TransitionConfig {
  return { configId: "0", resourceImage: undefined };
}

export const WebcastGiftMessage_FlyingMicResources_TransitionConfig: MessageFns<
  WebcastGiftMessage_FlyingMicResources_TransitionConfig
> = {
  encode(
    message: WebcastGiftMessage_FlyingMicResources_TransitionConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.configId !== "0") {
      writer.uint32(8).int64(message.configId);
    }
    if (message.resourceImage !== undefined) {
      Image.encode(message.resourceImage, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_FlyingMicResources_TransitionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_FlyingMicResources_TransitionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.configId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resourceImage = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGiftMessage_SponsorshipInfo(): WebcastGiftMessage_SponsorshipInfo {
  return {
    giftId: "0",
    sponsorId: "0",
    lightGiftUp: false,
    unlightedGiftIcon: "",
    giftGalleryDetailPageSchemeUrl: "",
    giftGalleryClickSponsor: false,
    becomeAllSponsored: false,
  };
}

export const WebcastGiftMessage_SponsorshipInfo: MessageFns<WebcastGiftMessage_SponsorshipInfo> = {
  encode(message: WebcastGiftMessage_SponsorshipInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftId !== "0") {
      writer.uint32(8).int64(message.giftId);
    }
    if (message.sponsorId !== "0") {
      writer.uint32(16).int64(message.sponsorId);
    }
    if (message.lightGiftUp !== false) {
      writer.uint32(24).bool(message.lightGiftUp);
    }
    if (message.unlightedGiftIcon !== "") {
      writer.uint32(34).string(message.unlightedGiftIcon);
    }
    if (message.giftGalleryDetailPageSchemeUrl !== "") {
      writer.uint32(42).string(message.giftGalleryDetailPageSchemeUrl);
    }
    if (message.giftGalleryClickSponsor !== false) {
      writer.uint32(48).bool(message.giftGalleryClickSponsor);
    }
    if (message.becomeAllSponsored !== false) {
      writer.uint32(168).bool(message.becomeAllSponsored);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGiftMessage_SponsorshipInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGiftMessage_SponsorshipInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.giftId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sponsorId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lightGiftUp = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.unlightedGiftIcon = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.giftGalleryDetailPageSchemeUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.giftGalleryClickSponsor = reader.bool();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.becomeAllSponsored = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle(): WebcastLinkMicBattle {
  return {
    common: undefined,
    battleId: "0",
    battleSetting: undefined,
    action: 0,
    battleResult: {},
    mBattleDisplayConfig: undefined,
    inviteeGiftPermissionType: 0,
    armies: {},
    anchorInfo: {},
    bubbleText: "",
    supportedActions: [],
    battleCombos: {},
    teamUsers: [],
    inviteeGiftPermissionTypes: [],
    actionByUserId: "0",
    teamBattleResult: [],
    teamArmies: [],
    abtestSettings: [],
    teamMatchCampaign: undefined,
    fuzzyDisplayConfigV2: undefined,
  };
}

export const WebcastLinkMicBattle: MessageFns<WebcastLinkMicBattle> = {
  encode(message: WebcastLinkMicBattle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.battleId !== "0") {
      writer.uint32(16).int64(message.battleId);
    }
    if (message.battleSetting !== undefined) {
      BattleSetting.encode(message.battleSetting, writer.uint32(26).fork()).join();
    }
    if (message.action !== 0) {
      writer.uint32(32).int32(message.action);
    }
    Object.entries(message.battleResult).forEach(([key, value]) => {
      WebcastLinkMicBattle_BattleResultEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.mBattleDisplayConfig !== undefined) {
      WebcastLinkMicBattle_BattleDisplayConfig.encode(message.mBattleDisplayConfig, writer.uint32(50).fork()).join();
    }
    if (message.inviteeGiftPermissionType !== 0) {
      writer.uint32(64).int32(message.inviteeGiftPermissionType);
    }
    Object.entries(message.armies).forEach(([key, value]) => {
      WebcastLinkMicBattle_ArmiesEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    Object.entries(message.anchorInfo).forEach(([key, value]) => {
      WebcastLinkMicBattle_AnchorInfoEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    if (message.bubbleText !== "") {
      writer.uint32(90).string(message.bubbleText);
    }
    for (const v of message.supportedActions) {
      WebcastLinkMicBattle_SupportedActionsWrapper.encode(v!, writer.uint32(98).fork()).join();
    }
    Object.entries(message.battleCombos).forEach(([key, value]) => {
      WebcastLinkMicBattle_BattleCombosEntry.encode({ key: key as any, value }, writer.uint32(106).fork()).join();
    });
    for (const v of message.teamUsers) {
      WebcastLinkMicBattle_TeamUsersInfo.encode(v!, writer.uint32(114).fork()).join();
    }
    for (const v of message.inviteeGiftPermissionTypes) {
      WebcastLinkMicBattle_BattleInviteeGiftPermission.encode(v!, writer.uint32(122).fork()).join();
    }
    if (message.actionByUserId !== "0") {
      writer.uint32(128).int64(message.actionByUserId);
    }
    for (const v of message.teamBattleResult) {
      WebcastLinkMicBattle_BattleTeamResult.encode(v!, writer.uint32(138).fork()).join();
    }
    for (const v of message.teamArmies) {
      BattleTeamUserArmies.encode(v!, writer.uint32(146).fork()).join();
    }
    for (const v of message.abtestSettings) {
      WebcastLinkMicBattle_BattleABTestSetting.encode(v!, writer.uint32(154).fork()).join();
    }
    if (message.teamMatchCampaign !== undefined) {
      WebcastLinkMicBattle_TeamMatchCampaign.encode(message.teamMatchCampaign, writer.uint32(162).fork()).join();
    }
    if (message.fuzzyDisplayConfigV2 !== undefined) {
      HighScoreControlCfg.encode(message.fuzzyDisplayConfigV2, writer.uint32(170).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.battleId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.battleSetting = BattleSetting.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = WebcastLinkMicBattle_BattleResultEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.battleResult[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.mBattleDisplayConfig = WebcastLinkMicBattle_BattleDisplayConfig.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.inviteeGiftPermissionType = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = WebcastLinkMicBattle_ArmiesEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.armies[entry9.key] = entry9.value;
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = WebcastLinkMicBattle_AnchorInfoEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.anchorInfo[entry10.key] = entry10.value;
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.bubbleText = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.supportedActions.push(WebcastLinkMicBattle_SupportedActionsWrapper.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          const entry13 = WebcastLinkMicBattle_BattleCombosEntry.decode(reader, reader.uint32());
          if (entry13.value !== undefined) {
            message.battleCombos[entry13.key] = entry13.value;
          }
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.teamUsers.push(WebcastLinkMicBattle_TeamUsersInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.inviteeGiftPermissionTypes.push(
            WebcastLinkMicBattle_BattleInviteeGiftPermission.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.actionByUserId = reader.int64().toString();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.teamBattleResult.push(WebcastLinkMicBattle_BattleTeamResult.decode(reader, reader.uint32()));
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.teamArmies.push(BattleTeamUserArmies.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.abtestSettings.push(WebcastLinkMicBattle_BattleABTestSetting.decode(reader, reader.uint32()));
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.teamMatchCampaign = WebcastLinkMicBattle_TeamMatchCampaign.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.fuzzyDisplayConfigV2 = HighScoreControlCfg.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleResultEntry(): WebcastLinkMicBattle_BattleResultEntry {
  return { key: "0", value: undefined };
}

export const WebcastLinkMicBattle_BattleResultEntry: MessageFns<WebcastLinkMicBattle_BattleResultEntry> = {
  encode(message: WebcastLinkMicBattle_BattleResultEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== undefined) {
      WebcastLinkMicBattle_BattleResult.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleResultEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleResultEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = WebcastLinkMicBattle_BattleResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_ArmiesEntry(): WebcastLinkMicBattle_ArmiesEntry {
  return { key: "0", value: undefined };
}

export const WebcastLinkMicBattle_ArmiesEntry: MessageFns<WebcastLinkMicBattle_ArmiesEntry> = {
  encode(message: WebcastLinkMicBattle_ArmiesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== undefined) {
      BattleUserArmies.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_ArmiesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_ArmiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = BattleUserArmies.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_AnchorInfoEntry(): WebcastLinkMicBattle_AnchorInfoEntry {
  return { key: "0", value: undefined };
}

export const WebcastLinkMicBattle_AnchorInfoEntry: MessageFns<WebcastLinkMicBattle_AnchorInfoEntry> = {
  encode(message: WebcastLinkMicBattle_AnchorInfoEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== undefined) {
      WebcastLinkMicBattle_BattleUserInfo.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_AnchorInfoEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_AnchorInfoEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = WebcastLinkMicBattle_BattleUserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleCombosEntry(): WebcastLinkMicBattle_BattleCombosEntry {
  return { key: "0", value: undefined };
}

export const WebcastLinkMicBattle_BattleCombosEntry: MessageFns<WebcastLinkMicBattle_BattleCombosEntry> = {
  encode(message: WebcastLinkMicBattle_BattleCombosEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== undefined) {
      WebcastLinkMicBattle_BattleComboInfo.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleCombosEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleCombosEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = WebcastLinkMicBattle_BattleComboInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_TeamMatchCampaign(): WebcastLinkMicBattle_TeamMatchCampaign {
  return { bestTeammateRelation: [], startSfxTeamId: [], hasTeamMatchMvpSfx: false };
}

export const WebcastLinkMicBattle_TeamMatchCampaign: MessageFns<WebcastLinkMicBattle_TeamMatchCampaign> = {
  encode(message: WebcastLinkMicBattle_TeamMatchCampaign, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.bestTeammateRelation) {
      WebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation.encode(v!, writer.uint32(10).fork()).join();
    }
    writer.uint32(18).fork();
    for (const v of message.startSfxTeamId) {
      writer.int64(v);
    }
    writer.join();
    if (message.hasTeamMatchMvpSfx !== false) {
      writer.uint32(24).bool(message.hasTeamMatchMvpSfx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_TeamMatchCampaign {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_TeamMatchCampaign();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bestTeammateRelation.push(
            WebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.startSfxTeamId.push(reader.int64().toString());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.startSfxTeamId.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hasTeamMatchMvpSfx = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation(): WebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation {
  return { userId: "0", bestTeammateId: "0" };
}

export const WebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation: MessageFns<
  WebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation
> = {
  encode(
    message: WebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.bestTeammateId !== "0") {
      writer.uint32(16).int64(message.bestTeammateId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.bestTeammateId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleTeamResult(): WebcastLinkMicBattle_BattleTeamResult {
  return { teamId: "0", teamUsers: [], result: 0, totalScore: "0" };
}

export const WebcastLinkMicBattle_BattleTeamResult: MessageFns<WebcastLinkMicBattle_BattleTeamResult> = {
  encode(message: WebcastLinkMicBattle_BattleTeamResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.teamId !== "0") {
      writer.uint32(8).int64(message.teamId);
    }
    for (const v of message.teamUsers) {
      BattleTeamUser.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.result !== 0) {
      writer.uint32(24).int32(message.result);
    }
    if (message.totalScore !== "0") {
      writer.uint32(32).int64(message.totalScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleTeamResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleTeamResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.teamId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.teamUsers.push(BattleTeamUser.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.result = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalScore = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleInviteeGiftPermission(): WebcastLinkMicBattle_BattleInviteeGiftPermission {
  return { userId: "0", giftPermissionType: 0 };
}

export const WebcastLinkMicBattle_BattleInviteeGiftPermission: MessageFns<
  WebcastLinkMicBattle_BattleInviteeGiftPermission
> = {
  encode(
    message: WebcastLinkMicBattle_BattleInviteeGiftPermission,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.giftPermissionType !== 0) {
      writer.uint32(16).int32(message.giftPermissionType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleInviteeGiftPermission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleInviteeGiftPermission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.giftPermissionType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_SupportedActionsWrapper(): WebcastLinkMicBattle_SupportedActionsWrapper {
  return { actionType: "0" };
}

export const WebcastLinkMicBattle_SupportedActionsWrapper: MessageFns<WebcastLinkMicBattle_SupportedActionsWrapper> = {
  encode(
    message: WebcastLinkMicBattle_SupportedActionsWrapper,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.actionType !== "0") {
      writer.uint32(8).int64(message.actionType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_SupportedActionsWrapper {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_SupportedActionsWrapper();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.actionType = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_TeamUsersInfo(): WebcastLinkMicBattle_TeamUsersInfo {
  return { teamId: "0", userIds: [] };
}

export const WebcastLinkMicBattle_TeamUsersInfo: MessageFns<WebcastLinkMicBattle_TeamUsersInfo> = {
  encode(message: WebcastLinkMicBattle_TeamUsersInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.teamId !== "0") {
      writer.uint32(8).int64(message.teamId);
    }
    writer.uint32(18).fork();
    for (const v of message.userIds) {
      writer.int64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_TeamUsersInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_TeamUsersInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.teamId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.userIds.push(reader.int64().toString());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.userIds.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleComboInfo(): WebcastLinkMicBattle_BattleComboInfo {
  return { userId: "0", comboStatus: "0", comboCount: "0", comboIconUrl: "", comboType: 0, comboRuleGuideSchema: "" };
}

export const WebcastLinkMicBattle_BattleComboInfo: MessageFns<WebcastLinkMicBattle_BattleComboInfo> = {
  encode(message: WebcastLinkMicBattle_BattleComboInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.comboStatus !== "0") {
      writer.uint32(16).int64(message.comboStatus);
    }
    if (message.comboCount !== "0") {
      writer.uint32(24).int64(message.comboCount);
    }
    if (message.comboIconUrl !== "") {
      writer.uint32(34).string(message.comboIconUrl);
    }
    if (message.comboType !== 0) {
      writer.uint32(40).int32(message.comboType);
    }
    if (message.comboRuleGuideSchema !== "") {
      writer.uint32(50).string(message.comboRuleGuideSchema);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleComboInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleComboInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.comboStatus = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.comboCount = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.comboIconUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.comboType = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.comboRuleGuideSchema = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleResult(): WebcastLinkMicBattle_BattleResult {
  return { userId: "0", result: 0, score: "0" };
}

export const WebcastLinkMicBattle_BattleResult: MessageFns<WebcastLinkMicBattle_BattleResult> = {
  encode(message: WebcastLinkMicBattle_BattleResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.result !== 0) {
      writer.uint32(16).int32(message.result);
    }
    if (message.score !== "0") {
      writer.uint32(24).int64(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.score = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleDisplayConfig(): WebcastLinkMicBattle_BattleDisplayConfig {
  return { threshold: 0, text: "", diffThreshold: 0, diffText: "", exemptStrategy: undefined };
}

export const WebcastLinkMicBattle_BattleDisplayConfig: MessageFns<WebcastLinkMicBattle_BattleDisplayConfig> = {
  encode(message: WebcastLinkMicBattle_BattleDisplayConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.threshold !== 0) {
      writer.uint32(8).int32(message.threshold);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    if (message.diffThreshold !== 0) {
      writer.uint32(24).int32(message.diffThreshold);
    }
    if (message.diffText !== "") {
      writer.uint32(34).string(message.diffText);
    }
    if (message.exemptStrategy !== undefined) {
      WebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy.encode(message.exemptStrategy, writer.uint32(42).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleDisplayConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleDisplayConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.threshold = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.diffThreshold = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.diffText = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.exemptStrategy = WebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy(): WebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy {
  return { exemptBothHost: false, exemptAudienceTop: 0 };
}

export const WebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy: MessageFns<
  WebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy
> = {
  encode(
    message: WebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.exemptBothHost !== false) {
      writer.uint32(8).bool(message.exemptBothHost);
    }
    if (message.exemptAudienceTop !== 0) {
      writer.uint32(16).int32(message.exemptAudienceTop);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.exemptBothHost = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.exemptAudienceTop = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleUserInfo(): WebcastLinkMicBattle_BattleUserInfo {
  return { user: undefined, tags: [] };
}

export const WebcastLinkMicBattle_BattleUserInfo: MessageFns<WebcastLinkMicBattle_BattleUserInfo> = {
  encode(message: WebcastLinkMicBattle_BattleUserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      WebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo.encode(message.user, writer.uint32(10).fork()).join();
    }
    for (const v of message.tags) {
      WebcastLinkMicBattle_BattleUserInfo_BattleRivalTag.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleUserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = WebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tags.push(WebcastLinkMicBattle_BattleUserInfo_BattleRivalTag.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo(): WebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo {
  return { userId: "0", nickName: "", avatarThumb: undefined, displayId: "" };
}

export const WebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo: MessageFns<
  WebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo
> = {
  encode(
    message: WebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.userId !== "0") {
      writer.uint32(8).int64(message.userId);
    }
    if (message.nickName !== "") {
      writer.uint32(18).string(message.nickName);
    }
    if (message.avatarThumb !== undefined) {
      Image.encode(message.avatarThumb, writer.uint32(26).fork()).join();
    }
    if (message.displayId !== "") {
      writer.uint32(34).string(message.displayId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nickName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.avatarThumb = Image.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.displayId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleUserInfo_BattleRivalTag(): WebcastLinkMicBattle_BattleUserInfo_BattleRivalTag {
  return { bgImage: undefined, iconImage: undefined, content: "" };
}

export const WebcastLinkMicBattle_BattleUserInfo_BattleRivalTag: MessageFns<
  WebcastLinkMicBattle_BattleUserInfo_BattleRivalTag
> = {
  encode(
    message: WebcastLinkMicBattle_BattleUserInfo_BattleRivalTag,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.bgImage !== undefined) {
      Image.encode(message.bgImage, writer.uint32(10).fork()).join();
    }
    if (message.iconImage !== undefined) {
      Image.encode(message.iconImage, writer.uint32(18).fork()).join();
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleUserInfo_BattleRivalTag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleUserInfo_BattleRivalTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bgImage = Image.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.iconImage = Image.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleABTestSetting(): WebcastLinkMicBattle_BattleABTestSetting {
  return { uid: "0", abTestList: undefined };
}

export const WebcastLinkMicBattle_BattleABTestSetting: MessageFns<WebcastLinkMicBattle_BattleABTestSetting> = {
  encode(message: WebcastLinkMicBattle_BattleABTestSetting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== "0") {
      writer.uint32(8).int64(message.uid);
    }
    if (message.abTestList !== undefined) {
      WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList.encode(message.abTestList, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleABTestSetting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleABTestSetting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uid = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.abTestList = WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleABTestSetting_BattleABTestList(): WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList {
  return { abTestList: [] };
}

export const WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList: MessageFns<
  WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList
> = {
  encode(
    message: WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.abTestList) {
      WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest.encode(v!, writer.uint32(10).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleABTestSetting_BattleABTestList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.abTestList.push(
            WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest(): WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest {
  return { abTestType: 0, group: 0 };
}

export const WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest: MessageFns<
  WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest
> = {
  encode(
    message: WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.abTestType !== 0) {
      writer.uint32(8).int32(message.abTestType);
    }
    if (message.group !== 0) {
      writer.uint32(16).int32(message.group);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.abTestType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.group = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicArmies(): WebcastLinkMicArmies {
  return {
    common: undefined,
    battleId: "0",
    battleItems: {},
    channelId: "0",
    giftSentTime: "0",
    scoreUpdateTime: "0",
    battleStatus: 0,
    fromUserId: "0",
    giftId: "0",
    giftCount: 0,
    gifIconImage: undefined,
    totalDiamondCount: 0,
    repeatCount: 0,
    teamArmies: [],
    triggerCriticalStrike: false,
    hasTeamMatchMvpSfx: false,
    logId: "",
    battleSettings: undefined,
    fuzzyDisplayConfigV2: undefined,
  };
}

export const WebcastLinkMicArmies: MessageFns<WebcastLinkMicArmies> = {
  encode(message: WebcastLinkMicArmies, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.battleId !== "0") {
      writer.uint32(16).int64(message.battleId);
    }
    Object.entries(message.battleItems).forEach(([key, value]) => {
      WebcastLinkMicArmies_BattleItemsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.channelId !== "0") {
      writer.uint32(32).int64(message.channelId);
    }
    if (message.giftSentTime !== "0") {
      writer.uint32(40).int64(message.giftSentTime);
    }
    if (message.scoreUpdateTime !== "0") {
      writer.uint32(48).int64(message.scoreUpdateTime);
    }
    if (message.battleStatus !== 0) {
      writer.uint32(56).int32(message.battleStatus);
    }
    if (message.fromUserId !== "0") {
      writer.uint32(64).int64(message.fromUserId);
    }
    if (message.giftId !== "0") {
      writer.uint32(72).int64(message.giftId);
    }
    if (message.giftCount !== 0) {
      writer.uint32(80).int32(message.giftCount);
    }
    if (message.gifIconImage !== undefined) {
      Image.encode(message.gifIconImage, writer.uint32(90).fork()).join();
    }
    if (message.totalDiamondCount !== 0) {
      writer.uint32(96).int32(message.totalDiamondCount);
    }
    if (message.repeatCount !== 0) {
      writer.uint32(104).int32(message.repeatCount);
    }
    for (const v of message.teamArmies) {
      BattleTeamUserArmies.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.triggerCriticalStrike !== false) {
      writer.uint32(120).bool(message.triggerCriticalStrike);
    }
    if (message.hasTeamMatchMvpSfx !== false) {
      writer.uint32(128).bool(message.hasTeamMatchMvpSfx);
    }
    if (message.logId !== "") {
      writer.uint32(138).string(message.logId);
    }
    if (message.battleSettings !== undefined) {
      BattleSetting.encode(message.battleSettings, writer.uint32(146).fork()).join();
    }
    if (message.fuzzyDisplayConfigV2 !== undefined) {
      HighScoreControlCfg.encode(message.fuzzyDisplayConfigV2, writer.uint32(154).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicArmies {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicArmies();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.battleId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = WebcastLinkMicArmies_BattleItemsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.battleItems[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.channelId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.giftSentTime = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.scoreUpdateTime = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.battleStatus = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.fromUserId = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.giftId = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.giftCount = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.gifIconImage = Image.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.totalDiamondCount = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.repeatCount = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.teamArmies.push(BattleTeamUserArmies.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.triggerCriticalStrike = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.hasTeamMatchMvpSfx = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.logId = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.battleSettings = BattleSetting.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.fuzzyDisplayConfigV2 = HighScoreControlCfg.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicArmies_BattleItemsEntry(): WebcastLinkMicArmies_BattleItemsEntry {
  return { key: "0", value: undefined };
}

export const WebcastLinkMicArmies_BattleItemsEntry: MessageFns<WebcastLinkMicArmies_BattleItemsEntry> = {
  encode(message: WebcastLinkMicArmies_BattleItemsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== undefined) {
      BattleUserArmies.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicArmies_BattleItemsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicArmies_BattleItemsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = BattleUserArmies.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicArmiesItems(): WebcastLinkMicArmiesItems {
  return { hostUserId: "0", battleGroups: [] };
}

export const WebcastLinkMicArmiesItems: MessageFns<WebcastLinkMicArmiesItems> = {
  encode(message: WebcastLinkMicArmiesItems, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostUserId !== "0") {
      writer.uint32(8).uint64(message.hostUserId);
    }
    for (const v of message.battleGroups) {
      WebcastLinkMicArmiesGroup.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicArmiesItems {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicArmiesItems();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hostUserId = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.battleGroups.push(WebcastLinkMicArmiesGroup.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicArmiesGroup(): WebcastLinkMicArmiesGroup {
  return { users: [], points: 0 };
}

export const WebcastLinkMicArmiesGroup: MessageFns<WebcastLinkMicArmiesGroup> = {
  encode(message: WebcastLinkMicArmiesGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.users) {
      User.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.points !== 0) {
      writer.uint32(16).int32(message.points);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicArmiesGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicArmiesGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.points = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastSocialMessage(): WebcastSocialMessage {
  return {
    common: undefined,
    user: undefined,
    shareType: "0",
    action: "0",
    shareTarget: "",
    followCount: 0,
    shareDisplayStyle: "0",
    shareCount: 0,
    publicAreaMessageCommon: undefined,
    signature: "",
    signatureVersion: "",
    showDurationMs: "0",
  };
}

export const WebcastSocialMessage: MessageFns<WebcastSocialMessage> = {
  encode(message: WebcastSocialMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.shareType !== "0") {
      writer.uint32(24).int64(message.shareType);
    }
    if (message.action !== "0") {
      writer.uint32(32).int64(message.action);
    }
    if (message.shareTarget !== "") {
      writer.uint32(42).string(message.shareTarget);
    }
    if (message.followCount !== 0) {
      writer.uint32(48).int32(message.followCount);
    }
    if (message.shareDisplayStyle !== "0") {
      writer.uint32(56).int64(message.shareDisplayStyle);
    }
    if (message.shareCount !== 0) {
      writer.uint32(64).int32(message.shareCount);
    }
    if (message.publicAreaMessageCommon !== undefined) {
      PublicAreaMessageCommon.encode(message.publicAreaMessageCommon, writer.uint32(74).fork()).join();
    }
    if (message.signature !== "") {
      writer.uint32(82).string(message.signature);
    }
    if (message.signatureVersion !== "") {
      writer.uint32(90).string(message.signatureVersion);
    }
    if (message.showDurationMs !== "0") {
      writer.uint32(96).int64(message.showDurationMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastSocialMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastSocialMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.shareType = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.action = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.shareTarget = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.followCount = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.shareDisplayStyle = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.shareCount = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.publicAreaMessageCommon = PublicAreaMessageCommon.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.signatureVersion = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.showDurationMs = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLikeMessage(): WebcastLikeMessage {
  return {
    common: undefined,
    likeCount: 0,
    totalLikeCount: 0,
    color: 0,
    user: undefined,
    icon: "",
    icons: [],
    specifiedDisplayText: [],
    effectCnt: "0",
    likeEffect: [],
    publicAreaMessageCommon: undefined,
    roomMessageHeatLevel: "0",
  };
}

export const WebcastLikeMessage: MessageFns<WebcastLikeMessage> = {
  encode(message: WebcastLikeMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.likeCount !== 0) {
      writer.uint32(16).int32(message.likeCount);
    }
    if (message.totalLikeCount !== 0) {
      writer.uint32(24).int32(message.totalLikeCount);
    }
    if (message.color !== 0) {
      writer.uint32(32).int32(message.color);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.icon !== "") {
      writer.uint32(50).string(message.icon);
    }
    for (const v of message.icons) {
      Image.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.specifiedDisplayText) {
      SpecifiedDisplayText.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.effectCnt !== "0") {
      writer.uint32(72).int64(message.effectCnt);
    }
    for (const v of message.likeEffect) {
      LikeEffect.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.publicAreaMessageCommon !== undefined) {
      PublicAreaMessageCommon.encode(message.publicAreaMessageCommon, writer.uint32(90).fork()).join();
    }
    if (message.roomMessageHeatLevel !== "0") {
      writer.uint32(96).int64(message.roomMessageHeatLevel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLikeMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLikeMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.likeCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalLikeCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.color = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.icon = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.icons.push(Image.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.specifiedDisplayText.push(SpecifiedDisplayText.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.effectCnt = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.likeEffect.push(LikeEffect.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.publicAreaMessageCommon = PublicAreaMessageCommon.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.roomMessageHeatLevel = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSpecifiedDisplayText(): SpecifiedDisplayText {
  return { uid: "0", displayText: undefined };
}

export const SpecifiedDisplayText: MessageFns<SpecifiedDisplayText> = {
  encode(message: SpecifiedDisplayText, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== "0") {
      writer.uint32(8).int64(message.uid);
    }
    if (message.displayText !== undefined) {
      Text.encode(message.displayText, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpecifiedDisplayText {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpecifiedDisplayText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uid = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayText = Text.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLikeEffect(): LikeEffect {
  return { version: "0", effectCnt: "0", effectIntervalMs: "0", level: "0" };
}

export const LikeEffect: MessageFns<LikeEffect> = {
  encode(message: LikeEffect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "0") {
      writer.uint32(8).int64(message.version);
    }
    if (message.effectCnt !== "0") {
      writer.uint32(16).int64(message.effectCnt);
    }
    if (message.effectIntervalMs !== "0") {
      writer.uint32(24).int64(message.effectIntervalMs);
    }
    if (message.level !== "0") {
      writer.uint32(32).int64(message.level);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LikeEffect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLikeEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.effectCnt = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.effectIntervalMs = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.level = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastQuestionNewMessage(): WebcastQuestionNewMessage {
  return { common: undefined, details: undefined };
}

export const WebcastQuestionNewMessage: MessageFns<WebcastQuestionNewMessage> = {
  encode(message: WebcastQuestionNewMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.details !== undefined) {
      WebcastQuestionNewMessage_Question.encode(message.details, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastQuestionNewMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastQuestionNewMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.details = WebcastQuestionNewMessage_Question.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastQuestionNewMessage_Question(): WebcastQuestionNewMessage_Question {
  return {
    questionId: "0",
    questionText: "",
    answerStatus: 0,
    createTime: "0",
    user: undefined,
    createFrom: 0,
    answerFrom: 0,
  };
}

export const WebcastQuestionNewMessage_Question: MessageFns<WebcastQuestionNewMessage_Question> = {
  encode(message: WebcastQuestionNewMessage_Question, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.questionId !== "0") {
      writer.uint32(8).int64(message.questionId);
    }
    if (message.questionText !== "") {
      writer.uint32(18).string(message.questionText);
    }
    if (message.answerStatus !== 0) {
      writer.uint32(24).int32(message.answerStatus);
    }
    if (message.createTime !== "0") {
      writer.uint32(32).int64(message.createTime);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.createFrom !== 0) {
      writer.uint32(160).int32(message.createFrom);
    }
    if (message.answerFrom !== 0) {
      writer.uint32(168).int32(message.answerFrom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastQuestionNewMessage_Question {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastQuestionNewMessage_Question();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.questionId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.questionText = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.answerStatus = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.createTime = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.createFrom = reader.int32();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.answerFrom = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastMessageEventDetails(): WebcastMessageEventDetails {
  return { displayType: "", label: "" };
}

export const WebcastMessageEventDetails: MessageFns<WebcastMessageEventDetails> = {
  encode(message: WebcastMessageEventDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayType !== "") {
      writer.uint32(10).string(message.displayType);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMessageEventDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMessageEventDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLiveIntroMessage(): WebcastLiveIntroMessage {
  return {
    common: undefined,
    roomId: "0",
    auditStatus: 0,
    description: "",
    host: undefined,
    introMode: 0,
    badges: [],
    language: "",
  };
}

export const WebcastLiveIntroMessage: MessageFns<WebcastLiveIntroMessage> = {
  encode(message: WebcastLiveIntroMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.roomId !== "0") {
      writer.uint32(16).int64(message.roomId);
    }
    if (message.auditStatus !== 0) {
      writer.uint32(24).int32(message.auditStatus);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.host !== undefined) {
      User.encode(message.host, writer.uint32(42).fork()).join();
    }
    if (message.introMode !== 0) {
      writer.uint32(48).int32(message.introMode);
    }
    for (const v of message.badges) {
      BadgeStruct.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.language !== "") {
      writer.uint32(66).string(message.language);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLiveIntroMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLiveIntroMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.roomId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.auditStatus = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.host = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.introMode = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.badges.push(BadgeStruct.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.language = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSystemMessage(): SystemMessage {
  return { description: "" };
}

export const SystemMessage: MessageFns<SystemMessage> = {
  encode(message: SystemMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SystemMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRankItem(): RankItem {
  return { colour: "", id: "0" };
}

export const RankItem: MessageFns<RankItem> = {
  encode(message: RankItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.colour !== "") {
      writer.uint32(10).string(message.colour);
    }
    if (message.id !== "0") {
      writer.uint32(32).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RankItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRankItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.colour = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.id = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastHourlyRankMessage(): WebcastHourlyRankMessage {
  return { data: undefined, common: undefined, data2: 0 };
}

export const WebcastHourlyRankMessage: MessageFns<WebcastHourlyRankMessage> = {
  encode(message: WebcastHourlyRankMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      WebcastHourlyRankMessage_RankContainer.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.data2 !== 0) {
      writer.uint32(24).uint32(message.data2);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastHourlyRankMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastHourlyRankMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = WebcastHourlyRankMessage_RankContainer.decode(reader, reader.uint32());
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.data2 = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastHourlyRankMessage_RankContainer(): WebcastHourlyRankMessage_RankContainer {
  return {
    data1: 0,
    rankingData: undefined,
    data2: 0,
    rankings: undefined,
    rankingData2: undefined,
    data3: 0,
    data4: 0,
  };
}

export const WebcastHourlyRankMessage_RankContainer: MessageFns<WebcastHourlyRankMessage_RankContainer> = {
  encode(message: WebcastHourlyRankMessage_RankContainer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data1 !== 0) {
      writer.uint32(8).uint32(message.data1);
    }
    if (message.rankingData !== undefined) {
      WebcastHourlyRankMessage_RankContainer_RankingData.encode(message.rankingData, writer.uint32(18).fork()).join();
    }
    if (message.data2 !== 0) {
      writer.uint32(24).uint32(message.data2);
    }
    if (message.rankings !== undefined) {
      Ranking.encode(message.rankings, writer.uint32(34).fork()).join();
    }
    if (message.rankingData2 !== undefined) {
      WebcastHourlyRankMessage_RankContainer_RankingData2.encode(message.rankingData2, writer.uint32(42).fork()).join();
    }
    if (message.data3 !== 0) {
      writer.uint32(48).uint32(message.data3);
    }
    if (message.data4 !== 0) {
      writer.uint32(56).uint32(message.data4);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastHourlyRankMessage_RankContainer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastHourlyRankMessage_RankContainer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.data1 = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rankingData = WebcastHourlyRankMessage_RankContainer_RankingData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.data2 = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rankings = Ranking.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rankingData2 = WebcastHourlyRankMessage_RankContainer_RankingData2.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.data3 = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.data4 = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastHourlyRankMessage_RankContainer_RankingData(): WebcastHourlyRankMessage_RankContainer_RankingData {
  return { data1: 0, rankdata: undefined, data2: "" };
}

export const WebcastHourlyRankMessage_RankContainer_RankingData: MessageFns<
  WebcastHourlyRankMessage_RankContainer_RankingData
> = {
  encode(
    message: WebcastHourlyRankMessage_RankContainer_RankingData,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.data1 !== 0) {
      writer.uint32(8).uint32(message.data1);
    }
    if (message.rankdata !== undefined) {
      Ranking.encode(message.rankdata, writer.uint32(18).fork()).join();
    }
    if (message.data2 !== "") {
      writer.uint32(26).string(message.data2);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastHourlyRankMessage_RankContainer_RankingData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastHourlyRankMessage_RankContainer_RankingData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.data1 = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rankdata = Ranking.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data2 = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastHourlyRankMessage_RankContainer_RankingData2(): WebcastHourlyRankMessage_RankContainer_RankingData2 {
  return { data1: 0, data2: 0, rankdata: undefined, data3: "", data4: 0, data5: 0 };
}

export const WebcastHourlyRankMessage_RankContainer_RankingData2: MessageFns<
  WebcastHourlyRankMessage_RankContainer_RankingData2
> = {
  encode(
    message: WebcastHourlyRankMessage_RankContainer_RankingData2,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.data1 !== 0) {
      writer.uint32(8).uint32(message.data1);
    }
    if (message.data2 !== 0) {
      writer.uint32(16).uint32(message.data2);
    }
    if (message.rankdata !== undefined) {
      Ranking.encode(message.rankdata, writer.uint32(26).fork()).join();
    }
    if (message.data3 !== "") {
      writer.uint32(34).string(message.data3);
    }
    if (message.data4 !== 0) {
      writer.uint32(40).uint32(message.data4);
    }
    if (message.data5 !== 0) {
      writer.uint32(48).uint32(message.data5);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastHourlyRankMessage_RankContainer_RankingData2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastHourlyRankMessage_RankContainer_RankingData2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.data1 = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.data2 = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rankdata = Ranking.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data3 = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.data4 = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.data5 = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEmoteDetails(): EmoteDetails {
  return { emoteId: "", image: undefined };
}

export const EmoteDetails: MessageFns<EmoteDetails> = {
  encode(message: EmoteDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.emoteId !== "") {
      writer.uint32(10).string(message.emoteId);
    }
    if (message.image !== undefined) {
      EmoteImage.encode(message.image, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmoteDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmoteDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.emoteId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.image = EmoteImage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEmoteImage(): EmoteImage {
  return { imageUrl: "" };
}

export const EmoteImage: MessageFns<EmoteImage> = {
  encode(message: EmoteImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageUrl !== "") {
      writer.uint32(10).string(message.imageUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmoteImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmoteImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastEnvelopeMessage(): WebcastEnvelopeMessage {
  return { common: undefined, envelopeInfo: undefined, display: 0 };
}

export const WebcastEnvelopeMessage: MessageFns<WebcastEnvelopeMessage> = {
  encode(message: WebcastEnvelopeMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.envelopeInfo !== undefined) {
      WebcastEnvelopeMessage_EnvelopeInfo.encode(message.envelopeInfo, writer.uint32(18).fork()).join();
    }
    if (message.display !== 0) {
      writer.uint32(24).int32(message.display);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastEnvelopeMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastEnvelopeMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.envelopeInfo = WebcastEnvelopeMessage_EnvelopeInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.display = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastEnvelopeMessage_EnvelopeInfo(): WebcastEnvelopeMessage_EnvelopeInfo {
  return {
    envelopeId: "",
    businessType: 0,
    envelopeIdc: "",
    sendUserName: "",
    diamondCount: 0,
    peopleCount: 0,
    unpackAt: 0,
    sendUserId: "",
    sendUserAvatar: undefined,
    createAt: "",
    roomId: "",
    followShowStatus: 0,
    skinId: 0,
  };
}

export const WebcastEnvelopeMessage_EnvelopeInfo: MessageFns<WebcastEnvelopeMessage_EnvelopeInfo> = {
  encode(message: WebcastEnvelopeMessage_EnvelopeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.envelopeId !== "") {
      writer.uint32(10).string(message.envelopeId);
    }
    if (message.businessType !== 0) {
      writer.uint32(16).int32(message.businessType);
    }
    if (message.envelopeIdc !== "") {
      writer.uint32(26).string(message.envelopeIdc);
    }
    if (message.sendUserName !== "") {
      writer.uint32(34).string(message.sendUserName);
    }
    if (message.diamondCount !== 0) {
      writer.uint32(40).int32(message.diamondCount);
    }
    if (message.peopleCount !== 0) {
      writer.uint32(48).int32(message.peopleCount);
    }
    if (message.unpackAt !== 0) {
      writer.uint32(56).int32(message.unpackAt);
    }
    if (message.sendUserId !== "") {
      writer.uint32(66).string(message.sendUserId);
    }
    if (message.sendUserAvatar !== undefined) {
      Image.encode(message.sendUserAvatar, writer.uint32(74).fork()).join();
    }
    if (message.createAt !== "") {
      writer.uint32(82).string(message.createAt);
    }
    if (message.roomId !== "") {
      writer.uint32(90).string(message.roomId);
    }
    if (message.followShowStatus !== 0) {
      writer.uint32(96).int32(message.followShowStatus);
    }
    if (message.skinId !== 0) {
      writer.uint32(104).int32(message.skinId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastEnvelopeMessage_EnvelopeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastEnvelopeMessage_EnvelopeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.envelopeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.businessType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.envelopeIdc = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sendUserName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.diamondCount = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.peopleCount = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.unpackAt = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.sendUserId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.sendUserAvatar = Image.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.roomId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.followShowStatus = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.skinId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTreasureBoxData(): TreasureBoxData {
  return { coins: 0, canOpen: 0, timestamp: "0" };
}

export const TreasureBoxData: MessageFns<TreasureBoxData> = {
  encode(message: TreasureBoxData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coins !== 0) {
      writer.uint32(40).uint32(message.coins);
    }
    if (message.canOpen !== 0) {
      writer.uint32(48).uint32(message.canOpen);
    }
    if (message.timestamp !== "0") {
      writer.uint32(56).uint64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreasureBoxData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreasureBoxData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.coins = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.canOpen = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.timestamp = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastSubNotifyMessage(): WebcastSubNotifyMessage {
  return {
    common: undefined,
    user: undefined,
    exhibitionType: 0,
    subMonth: "0",
    subscribeType: 0,
    oldSubscribeStatus: 0,
    subscribeMessageType: undefined,
    subscribingStatus: 0,
    isSend: false,
    isCustom: false,
    giftSource: 0,
    messageDisplayStyle: 0,
    publicAreaMessageCommon: undefined,
    packageId: "",
    eventTracking: undefined,
  };
}

export const WebcastSubNotifyMessage: MessageFns<WebcastSubNotifyMessage> = {
  encode(message: WebcastSubNotifyMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.exhibitionType !== 0) {
      writer.uint32(24).int32(message.exhibitionType);
    }
    if (message.subMonth !== "0") {
      writer.uint32(32).int64(message.subMonth);
    }
    if (message.subscribeType !== 0) {
      writer.uint32(40).int32(message.subscribeType);
    }
    if (message.oldSubscribeStatus !== 0) {
      writer.uint32(48).int32(message.oldSubscribeStatus);
    }
    if (message.subscribeMessageType !== undefined) {
      writer.uint32(56).int32(message.subscribeMessageType);
    }
    if (message.subscribingStatus !== 0) {
      writer.uint32(64).int32(message.subscribingStatus);
    }
    if (message.isSend !== false) {
      writer.uint32(72).bool(message.isSend);
    }
    if (message.isCustom !== false) {
      writer.uint32(80).bool(message.isCustom);
    }
    if (message.giftSource !== 0) {
      writer.uint32(88).int32(message.giftSource);
    }
    if (message.messageDisplayStyle !== 0) {
      writer.uint32(96).int32(message.messageDisplayStyle);
    }
    if (message.publicAreaMessageCommon !== undefined) {
      PublicAreaMessageCommon.encode(message.publicAreaMessageCommon, writer.uint32(106).fork()).join();
    }
    if (message.packageId !== "") {
      writer.uint32(114).string(message.packageId);
    }
    if (message.eventTracking !== undefined) {
      WebcastSubNotifyMessage_EventTracking.encode(message.eventTracking, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastSubNotifyMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastSubNotifyMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.exhibitionType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.subMonth = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.subscribeType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.oldSubscribeStatus = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.subscribeMessageType = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.subscribingStatus = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isSend = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isCustom = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.giftSource = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.messageDisplayStyle = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.publicAreaMessageCommon = PublicAreaMessageCommon.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.packageId = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.eventTracking = WebcastSubNotifyMessage_EventTracking.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastSubNotifyMessage_EventTracking(): WebcastSubNotifyMessage_EventTracking {
  return { giftSubSenderId: "0", giftSubReceiverId: "0", anchorId: "0", giftSubOrderCreateTime: "0" };
}

export const WebcastSubNotifyMessage_EventTracking: MessageFns<WebcastSubNotifyMessage_EventTracking> = {
  encode(message: WebcastSubNotifyMessage_EventTracking, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.giftSubSenderId !== "0") {
      writer.uint32(8).int64(message.giftSubSenderId);
    }
    if (message.giftSubReceiverId !== "0") {
      writer.uint32(16).int64(message.giftSubReceiverId);
    }
    if (message.anchorId !== "0") {
      writer.uint32(24).int64(message.anchorId);
    }
    if (message.giftSubOrderCreateTime !== "0") {
      writer.uint32(32).int64(message.giftSubOrderCreateTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastSubNotifyMessage_EventTracking {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastSubNotifyMessage_EventTracking();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.giftSubSenderId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.giftSubReceiverId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.anchorId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.giftSubOrderCreateTime = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseFollowInfo(): FollowInfo {
  return { followingCount: 0, followerCount: 0, followStatus: 0, pushStatus: 0 };
}

export const FollowInfo: MessageFns<FollowInfo> = {
  encode(message: FollowInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.followingCount !== 0) {
      writer.uint32(8).int32(message.followingCount);
    }
    if (message.followerCount !== 0) {
      writer.uint32(16).int32(message.followerCount);
    }
    if (message.followStatus !== 0) {
      writer.uint32(24).int32(message.followStatus);
    }
    if (message.pushStatus !== 0) {
      writer.uint32(32).int32(message.pushStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FollowInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFollowInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.followingCount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.followerCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.followStatus = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pushStatus = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProfilePicture(): ProfilePicture {
  return { urls: [] };
}

export const ProfilePicture: MessageFns<ProfilePicture> = {
  encode(message: ProfilePicture, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.urls) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProfilePicture {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProfilePicture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.urls.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUserBadgesAttributes(): UserBadgesAttributes {
  return { badgeSceneType: 0, imageBadges: [], badges: [], privilegeLogExtra: undefined };
}

export const UserBadgesAttributes: MessageFns<UserBadgesAttributes> = {
  encode(message: UserBadgesAttributes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.badgeSceneType !== 0) {
      writer.uint32(24).int32(message.badgeSceneType);
    }
    for (const v of message.imageBadges) {
      UserImageBadge.encode(v!, writer.uint32(162).fork()).join();
    }
    for (const v of message.badges) {
      UserBadge.encode(v!, writer.uint32(170).fork()).join();
    }
    if (message.privilegeLogExtra !== undefined) {
      PrivilegeLogExtra.encode(message.privilegeLogExtra, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserBadgesAttributes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserBadgesAttributes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.badgeSceneType = reader.int32();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.imageBadges.push(UserImageBadge.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.badges.push(UserBadge.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.privilegeLogExtra = PrivilegeLogExtra.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUserBadge(): UserBadge {
  return { type: "", name: "" };
}

export const UserBadge: MessageFns<UserBadge> = {
  encode(message: UserBadge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserBadge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserBadge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUserImageBadge(): UserImageBadge {
  return { displayType: 0, image: undefined };
}

export const UserImageBadge: MessageFns<UserImageBadge> = {
  encode(message: UserImageBadge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayType !== 0) {
      writer.uint32(8).int32(message.displayType);
    }
    if (message.image !== undefined) {
      UserImageBadgeImage.encode(message.image, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserImageBadge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserImageBadge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.displayType = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.image = UserImageBadgeImage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUserImageBadgeImage(): UserImageBadgeImage {
  return { url: "" };
}

export const UserImageBadgeImage: MessageFns<UserImageBadgeImage> = {
  encode(message: UserImageBadgeImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserImageBadgeImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserImageBadgeImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebSocketAckMessage(): WebSocketAckMessage {
  return { id: "0", type: "" };
}

export const WebSocketAckMessage: MessageFns<WebSocketAckMessage> = {
  encode(message: WebSocketAckMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(16).uint64(message.id);
    }
    if (message.type !== "") {
      writer.uint32(58).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebSocketAckMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebSocketAckMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.uint64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.type = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseHeartbeatFrameRoomInfo(): HeartbeatFrameRoomInfo {
  return { roomId: "0" };
}

export const HeartbeatFrameRoomInfo: MessageFns<HeartbeatFrameRoomInfo> = {
  encode(message: HeartbeatFrameRoomInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== "0") {
      writer.uint32(8).uint64(message.roomId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartbeatFrameRoomInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatFrameRoomInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.roomId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseHeartbeatFrameMetadataField6(): HeartbeatFrameMetadataField6 {
  return { unknown1: 0 };
}

export const HeartbeatFrameMetadataField6: MessageFns<HeartbeatFrameMetadataField6> = {
  encode(message: HeartbeatFrameMetadataField6, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unknown1 !== 0) {
      writer.uint32(112).uint32(message.unknown1);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartbeatFrameMetadataField6 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatFrameMetadataField6();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.unknown1 = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseHeartbeatFrameMetadataField7(): HeartbeatFrameMetadataField7 {
  return { unknown1: 0 };
}

export const HeartbeatFrameMetadataField7: MessageFns<HeartbeatFrameMetadataField7> = {
  encode(message: HeartbeatFrameMetadataField7, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unknown1 !== 0) {
      writer.uint32(104).uint32(message.unknown1);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartbeatFrameMetadataField7 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatFrameMetadataField7();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.unknown1 = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseHeartbeatFrame(): HeartbeatFrame {
  return { metadataField6: undefined, metadataField7: undefined, roomInfo: undefined };
}

export const HeartbeatFrame: MessageFns<HeartbeatFrame> = {
  encode(message: HeartbeatFrame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadataField6 !== undefined) {
      HeartbeatFrameMetadataField6.encode(message.metadataField6, writer.uint32(50).fork()).join();
    }
    if (message.metadataField7 !== undefined) {
      HeartbeatFrameMetadataField7.encode(message.metadataField7, writer.uint32(58).fork()).join();
    }
    if (message.roomInfo !== undefined) {
      HeartbeatFrameRoomInfo.encode(message.roomInfo, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartbeatFrame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadataField6 = HeartbeatFrameMetadataField6.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.metadataField7 = HeartbeatFrameMetadataField7.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.roomInfo = HeartbeatFrameRoomInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseImEnterRoomMessagePushFrame(): ImEnterRoomMessagePushFrame {
  return { metadata: undefined, payloadType: "", payload: undefined };
}

export const ImEnterRoomMessagePushFrame: MessageFns<ImEnterRoomMessagePushFrame> = {
  encode(message: ImEnterRoomMessagePushFrame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      ImEnterRoomMessagePushFrame_Metadata.encode(message.metadata, writer.uint32(50).fork()).join();
    }
    if (message.payloadType !== "") {
      writer.uint32(58).string(message.payloadType);
    }
    if (message.payload !== undefined) {
      ImEnterRoomMessagePushFrame_ImEnterRoomMessage.encode(message.payload, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImEnterRoomMessagePushFrame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImEnterRoomMessagePushFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = ImEnterRoomMessagePushFrame_Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.payloadType = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.payload = ImEnterRoomMessagePushFrame_ImEnterRoomMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseImEnterRoomMessagePushFrame_Metadata(): ImEnterRoomMessagePushFrame_Metadata {
  return { unknown1: 0 };
}

export const ImEnterRoomMessagePushFrame_Metadata: MessageFns<ImEnterRoomMessagePushFrame_Metadata> = {
  encode(message: ImEnterRoomMessagePushFrame_Metadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unknown1 !== 0) {
      writer.uint32(112).uint32(message.unknown1);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImEnterRoomMessagePushFrame_Metadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImEnterRoomMessagePushFrame_Metadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.unknown1 = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseImEnterRoomMessagePushFrame_ImEnterRoomMessage(): ImEnterRoomMessagePushFrame_ImEnterRoomMessage {
  return { roomId: "0", unknown1: 0, role: "", cursor: "", unknown2: undefined, unknown3: "", unknown4: undefined };
}

export const ImEnterRoomMessagePushFrame_ImEnterRoomMessage: MessageFns<
  ImEnterRoomMessagePushFrame_ImEnterRoomMessage
> = {
  encode(
    message: ImEnterRoomMessagePushFrame_ImEnterRoomMessage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.roomId !== "0") {
      writer.uint32(8).uint64(message.roomId);
    }
    if (message.unknown1 !== 0) {
      writer.uint32(32).uint32(message.unknown1);
    }
    if (message.role !== "") {
      writer.uint32(42).string(message.role);
    }
    if (message.cursor !== "") {
      writer.uint32(50).string(message.cursor);
    }
    if (message.unknown2 !== undefined) {
      writer.uint32(56).int32(message.unknown2);
    }
    if (message.unknown3 !== "") {
      writer.uint32(74).string(message.unknown3);
    }
    if (message.unknown4 !== undefined) {
      writer.uint32(80).int32(message.unknown4);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImEnterRoomMessagePushFrame_ImEnterRoomMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImEnterRoomMessagePushFrame_ImEnterRoomMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.roomId = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.unknown1 = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cursor = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.unknown2 = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.unknown3 = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.unknown4 = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage(): WebcastBarrageMessage {
  return {
    common: undefined,
    event: undefined,
    msgType: undefined,
    icon: undefined,
    duration: "0",
    backGround: undefined,
    rightIcon: undefined,
    displayConfig: 0,
    galleryGiftId: "0",
    useMarquee: false,
    showType: undefined,
    renderType: undefined,
    leftIconDisplayType: undefined,
    ribbonAnimation: undefined,
    hybridUrl: "",
    schema: "",
    subType: "",
    privilegeLogExtra: undefined,
    content: undefined,
    scene: 0,
    control: undefined,
    rightLabel: undefined,
    badge: undefined,
    animationData: undefined,
    commonBarrageContent: undefined,
    userGradeParam: undefined,
    fansLevelParam: undefined,
    subscribeGiftParam: undefined,
    giftGalleryParams: undefined,
  };
}

export const WebcastBarrageMessage: MessageFns<WebcastBarrageMessage> = {
  encode(message: WebcastBarrageMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.event !== undefined) {
      WebcastBarrageMessage_BarrageEvent.encode(message.event, writer.uint32(18).fork()).join();
    }
    if (message.msgType !== undefined) {
      writer.uint32(24).int32(message.msgType);
    }
    if (message.icon !== undefined) {
      ImageModel.encode(message.icon, writer.uint32(34).fork()).join();
    }
    if (message.duration !== "0") {
      writer.uint32(48).int64(message.duration);
    }
    if (message.backGround !== undefined) {
      ImageModel.encode(message.backGround, writer.uint32(58).fork()).join();
    }
    if (message.rightIcon !== undefined) {
      ImageModel.encode(message.rightIcon, writer.uint32(66).fork()).join();
    }
    if (message.displayConfig !== 0) {
      writer.uint32(72).int32(message.displayConfig);
    }
    if (message.galleryGiftId !== "0") {
      writer.uint32(80).int64(message.galleryGiftId);
    }
    if (message.useMarquee !== false) {
      writer.uint32(112).bool(message.useMarquee);
    }
    if (message.showType !== undefined) {
      writer.uint32(120).int32(message.showType);
    }
    if (message.renderType !== undefined) {
      writer.uint32(136).int32(message.renderType);
    }
    if (message.leftIconDisplayType !== undefined) {
      writer.uint32(144).int32(message.leftIconDisplayType);
    }
    if (message.ribbonAnimation !== undefined) {
      ImageModel.encode(message.ribbonAnimation, writer.uint32(154).fork()).join();
    }
    if (message.hybridUrl !== "") {
      writer.uint32(170).string(message.hybridUrl);
    }
    if (message.schema !== "") {
      writer.uint32(178).string(message.schema);
    }
    if (message.subType !== "") {
      writer.uint32(186).string(message.subType);
    }
    if (message.privilegeLogExtra !== undefined) {
      PrivilegeLogExtra.encode(message.privilegeLogExtra, writer.uint32(826).fork()).join();
    }
    if (message.content !== undefined) {
      Text.encode(message.content, writer.uint32(42).fork()).join();
    }
    if (message.scene !== 0) {
      writer.uint32(88).int32(message.scene);
    }
    if (message.control !== undefined) {
      WebcastBarrageMessage_DisplayControl.encode(message.control, writer.uint32(98).fork()).join();
    }
    if (message.rightLabel !== undefined) {
      WebcastBarrageMessage_RightLabel.encode(message.rightLabel, writer.uint32(106).fork()).join();
    }
    if (message.badge !== undefined) {
      BadgeStruct.encode(message.badge, writer.uint32(130).fork()).join();
    }
    if (message.animationData !== undefined) {
      WebcastBarrageMessage_AnimationData.encode(message.animationData, writer.uint32(162).fork()).join();
    }
    if (message.commonBarrageContent !== undefined) {
      Text.encode(message.commonBarrageContent, writer.uint32(194).fork()).join();
    }
    if (message.userGradeParam !== undefined) {
      WebcastBarrageMessage_BarrageTypeUserGradeParam.encode(message.userGradeParam, writer.uint32(802).fork()).join();
    }
    if (message.fansLevelParam !== undefined) {
      WebcastBarrageMessage_BarrageTypeFansLevelParam.encode(message.fansLevelParam, writer.uint32(810).fork()).join();
    }
    if (message.subscribeGiftParam !== undefined) {
      WebcastBarrageMessage_BarrageTypeSubscribeGiftParam.encode(message.subscribeGiftParam, writer.uint32(818).fork())
        .join();
    }
    if (message.giftGalleryParams !== undefined) {
      WebcastBarrageMessage_BarrageTypeGiftGalleryParam.encode(message.giftGalleryParams, writer.uint32(834).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.event = WebcastBarrageMessage_BarrageEvent.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.msgType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.icon = ImageModel.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.duration = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.backGround = ImageModel.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.rightIcon = ImageModel.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.displayConfig = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.galleryGiftId = reader.int64().toString();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.useMarquee = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.showType = reader.int32() as any;
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.renderType = reader.int32() as any;
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.leftIconDisplayType = reader.int32() as any;
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.ribbonAnimation = ImageModel.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.hybridUrl = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.subType = reader.string();
          continue;
        }
        case 103: {
          if (tag !== 826) {
            break;
          }

          message.privilegeLogExtra = PrivilegeLogExtra.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.content = Text.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.scene = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.control = WebcastBarrageMessage_DisplayControl.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.rightLabel = WebcastBarrageMessage_RightLabel.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.badge = BadgeStruct.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.animationData = WebcastBarrageMessage_AnimationData.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.commonBarrageContent = Text.decode(reader, reader.uint32());
          continue;
        }
        case 100: {
          if (tag !== 802) {
            break;
          }

          message.userGradeParam = WebcastBarrageMessage_BarrageTypeUserGradeParam.decode(reader, reader.uint32());
          continue;
        }
        case 101: {
          if (tag !== 810) {
            break;
          }

          message.fansLevelParam = WebcastBarrageMessage_BarrageTypeFansLevelParam.decode(reader, reader.uint32());
          continue;
        }
        case 102: {
          if (tag !== 818) {
            break;
          }

          message.subscribeGiftParam = WebcastBarrageMessage_BarrageTypeSubscribeGiftParam.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 104: {
          if (tag !== 834) {
            break;
          }

          message.giftGalleryParams = WebcastBarrageMessage_BarrageTypeGiftGalleryParam.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage_BarrageEvent(): WebcastBarrageMessage_BarrageEvent {
  return { eventName: "", params: {} };
}

export const WebcastBarrageMessage_BarrageEvent: MessageFns<WebcastBarrageMessage_BarrageEvent> = {
  encode(message: WebcastBarrageMessage_BarrageEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventName !== "") {
      writer.uint32(10).string(message.eventName);
    }
    Object.entries(message.params).forEach(([key, value]) => {
      WebcastBarrageMessage_BarrageEvent_ParamsEntry.encode({ key: key as any, value }, writer.uint32(18).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage_BarrageEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_BarrageEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = WebcastBarrageMessage_BarrageEvent_ParamsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.params[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage_BarrageEvent_ParamsEntry(): WebcastBarrageMessage_BarrageEvent_ParamsEntry {
  return { key: "", value: "" };
}

export const WebcastBarrageMessage_BarrageEvent_ParamsEntry: MessageFns<
  WebcastBarrageMessage_BarrageEvent_ParamsEntry
> = {
  encode(
    message: WebcastBarrageMessage_BarrageEvent_ParamsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage_BarrageEvent_ParamsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_BarrageEvent_ParamsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage_BarrageTypeUserGradeParam(): WebcastBarrageMessage_BarrageTypeUserGradeParam {
  return { currentGrade: 0, displayConfig: 0, userId: "", user: undefined };
}

export const WebcastBarrageMessage_BarrageTypeUserGradeParam: MessageFns<
  WebcastBarrageMessage_BarrageTypeUserGradeParam
> = {
  encode(
    message: WebcastBarrageMessage_BarrageTypeUserGradeParam,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.currentGrade !== 0) {
      writer.uint32(8).int32(message.currentGrade);
    }
    if (message.displayConfig !== 0) {
      writer.uint32(16).int32(message.displayConfig);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage_BarrageTypeUserGradeParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_BarrageTypeUserGradeParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.currentGrade = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.displayConfig = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage_BarrageTypeFansLevelParam(): WebcastBarrageMessage_BarrageTypeFansLevelParam {
  return { currentGrade: 0, displayConfig: 0, user: undefined };
}

export const WebcastBarrageMessage_BarrageTypeFansLevelParam: MessageFns<
  WebcastBarrageMessage_BarrageTypeFansLevelParam
> = {
  encode(
    message: WebcastBarrageMessage_BarrageTypeFansLevelParam,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.currentGrade !== 0) {
      writer.uint32(8).int32(message.currentGrade);
    }
    if (message.displayConfig !== 0) {
      writer.uint32(16).int32(message.displayConfig);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage_BarrageTypeFansLevelParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_BarrageTypeFansLevelParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.currentGrade = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.displayConfig = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage_BarrageTypeSubscribeGiftParam(): WebcastBarrageMessage_BarrageTypeSubscribeGiftParam {
  return { giftSubCount: "0", showGiftSubCount: false };
}

export const WebcastBarrageMessage_BarrageTypeSubscribeGiftParam: MessageFns<
  WebcastBarrageMessage_BarrageTypeSubscribeGiftParam
> = {
  encode(
    message: WebcastBarrageMessage_BarrageTypeSubscribeGiftParam,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.giftSubCount !== "0") {
      writer.uint32(8).int64(message.giftSubCount);
    }
    if (message.showGiftSubCount !== false) {
      writer.uint32(16).bool(message.showGiftSubCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage_BarrageTypeSubscribeGiftParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_BarrageTypeSubscribeGiftParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.giftSubCount = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.showGiftSubCount = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage_AnimationData(): WebcastBarrageMessage_AnimationData {
  return { geckoChannelName: "", fileName: "", height: "0", width: "0", rightOffset: "0" };
}

export const WebcastBarrageMessage_AnimationData: MessageFns<WebcastBarrageMessage_AnimationData> = {
  encode(message: WebcastBarrageMessage_AnimationData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.geckoChannelName !== "") {
      writer.uint32(10).string(message.geckoChannelName);
    }
    if (message.fileName !== "") {
      writer.uint32(18).string(message.fileName);
    }
    if (message.height !== "0") {
      writer.uint32(24).int64(message.height);
    }
    if (message.width !== "0") {
      writer.uint32(32).int64(message.width);
    }
    if (message.rightOffset !== "0") {
      writer.uint32(40).int64(message.rightOffset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage_AnimationData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_AnimationData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.geckoChannelName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.height = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.width = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.rightOffset = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage_BarrageTypeGiftGalleryParam(): WebcastBarrageMessage_BarrageTypeGiftGalleryParam {
  return { fromUserId: "0", toUserId: "0" };
}

export const WebcastBarrageMessage_BarrageTypeGiftGalleryParam: MessageFns<
  WebcastBarrageMessage_BarrageTypeGiftGalleryParam
> = {
  encode(
    message: WebcastBarrageMessage_BarrageTypeGiftGalleryParam,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.fromUserId !== "0") {
      writer.uint32(8).int64(message.fromUserId);
    }
    if (message.toUserId !== "0") {
      writer.uint32(16).int64(message.toUserId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage_BarrageTypeGiftGalleryParam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_BarrageTypeGiftGalleryParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromUserId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.toUserId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage_DisplayControl(): WebcastBarrageMessage_DisplayControl {
  return { priority: 0, duration: "0", targetGroupShowRst: {}, horizontalTriggerType: 0 };
}

export const WebcastBarrageMessage_DisplayControl: MessageFns<WebcastBarrageMessage_DisplayControl> = {
  encode(message: WebcastBarrageMessage_DisplayControl, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.priority !== 0) {
      writer.uint32(8).int32(message.priority);
    }
    if (message.duration !== "0") {
      writer.uint32(16).int64(message.duration);
    }
    Object.entries(message.targetGroupShowRst).forEach(([key, value]) => {
      WebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry.encode(
        { key: key as any, value },
        writer.uint32(26).fork(),
      ).join();
    });
    if (message.horizontalTriggerType !== 0) {
      writer.uint32(32).int32(message.horizontalTriggerType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage_DisplayControl {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_DisplayControl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.duration = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = WebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.targetGroupShowRst[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.horizontalTriggerType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry(): WebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry {
  return { key: 0, value: undefined };
}

export const WebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry: MessageFns<
  WebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry
> = {
  encode(
    message: WebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== undefined) {
      WebcastBarrageMessage_DisplayControl_ShowResult.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = WebcastBarrageMessage_DisplayControl_ShowResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage_DisplayControl_ShowResult(): WebcastBarrageMessage_DisplayControl_ShowResult {
  return { banned: false };
}

export const WebcastBarrageMessage_DisplayControl_ShowResult: MessageFns<
  WebcastBarrageMessage_DisplayControl_ShowResult
> = {
  encode(
    message: WebcastBarrageMessage_DisplayControl_ShowResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.banned !== false) {
      writer.uint32(8).bool(message.banned);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage_DisplayControl_ShowResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_DisplayControl_ShowResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.banned = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastBarrageMessage_RightLabel(): WebcastBarrageMessage_RightLabel {
  return { backgroundColor: "", content: undefined, height: "0" };
}

export const WebcastBarrageMessage_RightLabel: MessageFns<WebcastBarrageMessage_RightLabel> = {
  encode(message: WebcastBarrageMessage_RightLabel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.backgroundColor !== "") {
      writer.uint32(10).string(message.backgroundColor);
    }
    if (message.content !== undefined) {
      Text.encode(message.content, writer.uint32(18).fork()).join();
    }
    if (message.height !== "0") {
      writer.uint32(24).int64(message.height);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastBarrageMessage_RightLabel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastBarrageMessage_RightLabel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.backgroundColor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = Text.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.height = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastPushFrame(): WebcastPushFrame {
  return {
    seqId: "0",
    id: "0",
    service: "0",
    method: "0",
    headers: {},
    payloadEncoding: "",
    type: "",
    binary: new Uint8Array(0),
  };
}

export const WebcastPushFrame: MessageFns<WebcastPushFrame> = {
  encode(message: WebcastPushFrame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.seqId !== "0") {
      writer.uint32(8).int64(message.seqId);
    }
    if (message.id !== "0") {
      writer.uint32(16).int64(message.id);
    }
    if (message.service !== "0") {
      writer.uint32(24).int64(message.service);
    }
    if (message.method !== "0") {
      writer.uint32(32).int64(message.method);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      WebcastPushFrame_HeadersEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.payloadEncoding !== "") {
      writer.uint32(50).string(message.payloadEncoding);
    }
    if (message.type !== "") {
      writer.uint32(58).string(message.type);
    }
    if (message.binary.length !== 0) {
      writer.uint32(66).bytes(message.binary);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastPushFrame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastPushFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.seqId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.service = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.method = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = WebcastPushFrame_HeadersEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.headers[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.payloadEncoding = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.binary = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastPushFrame_HeadersEntry(): WebcastPushFrame_HeadersEntry {
  return { key: "", value: "" };
}

export const WebcastPushFrame_HeadersEntry: MessageFns<WebcastPushFrame_HeadersEntry> = {
  encode(message: WebcastPushFrame_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastPushFrame_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastPushFrame_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProtoMessageFetchResult(): ProtoMessageFetchResult {
  return {
    messages: [],
    cursor: "",
    fetchInterval: "0",
    now: "0",
    internalExt: "",
    fetchType: 0,
    wsParams: {},
    heartBeatDuration: "0",
    needsAck: false,
    wsUrl: "",
    isFirst: false,
    historyCommentCursor: "",
    historyNoMore: false,
  };
}

export const ProtoMessageFetchResult: MessageFns<ProtoMessageFetchResult> = {
  encode(message: ProtoMessageFetchResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      BaseProtoMessage.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.cursor !== "") {
      writer.uint32(18).string(message.cursor);
    }
    if (message.fetchInterval !== "0") {
      writer.uint32(24).int64(message.fetchInterval);
    }
    if (message.now !== "0") {
      writer.uint32(32).int64(message.now);
    }
    if (message.internalExt !== "") {
      writer.uint32(42).string(message.internalExt);
    }
    if (message.fetchType !== 0) {
      writer.uint32(48).int32(message.fetchType);
    }
    Object.entries(message.wsParams).forEach(([key, value]) => {
      ProtoMessageFetchResult_WsParamsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.heartBeatDuration !== "0") {
      writer.uint32(64).int64(message.heartBeatDuration);
    }
    if (message.needsAck !== false) {
      writer.uint32(72).bool(message.needsAck);
    }
    if (message.wsUrl !== "") {
      writer.uint32(82).string(message.wsUrl);
    }
    if (message.isFirst !== false) {
      writer.uint32(88).bool(message.isFirst);
    }
    if (message.historyCommentCursor !== "") {
      writer.uint32(98).string(message.historyCommentCursor);
    }
    if (message.historyNoMore !== false) {
      writer.uint32(104).bool(message.historyNoMore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoMessageFetchResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoMessageFetchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messages.push(BaseProtoMessage.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cursor = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fetchInterval = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.now = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.internalExt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.fetchType = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = ProtoMessageFetchResult_WsParamsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.wsParams[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.heartBeatDuration = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.needsAck = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.wsUrl = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.isFirst = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.historyCommentCursor = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.historyNoMore = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProtoMessageFetchResult_WsParamsEntry(): ProtoMessageFetchResult_WsParamsEntry {
  return { key: "", value: "" };
}

export const ProtoMessageFetchResult_WsParamsEntry: MessageFns<ProtoMessageFetchResult_WsParamsEntry> = {
  encode(message: ProtoMessageFetchResult_WsParamsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoMessageFetchResult_WsParamsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoMessageFetchResult_WsParamsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBaseProtoMessage(): BaseProtoMessage {
  return { type: "", payload: new Uint8Array(0), msgId: "0", msgType: 0, offset: "0", isHistory: false };
}

export const BaseProtoMessage: MessageFns<BaseProtoMessage> = {
  encode(message: BaseProtoMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    if (message.msgId !== "0") {
      writer.uint32(24).int64(message.msgId);
    }
    if (message.msgType !== 0) {
      writer.uint32(32).int32(message.msgType);
    }
    if (message.offset !== "0") {
      writer.uint32(40).int64(message.offset);
    }
    if (message.isHistory !== false) {
      writer.uint32(48).bool(message.isHistory);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BaseProtoMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaseProtoMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.msgId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.msgType = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.offset = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isHistory = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastRoomMessage(): WebcastRoomMessage {
  return {
    common: undefined,
    content: "",
    supportLandscape: false,
    source: "0",
    icon: undefined,
    scene: 0,
    isWelcome: false,
    publicAreaCommon: undefined,
    showDurationMs: "0",
    subScene: "",
  };
}

export const WebcastRoomMessage: MessageFns<WebcastRoomMessage> = {
  encode(message: WebcastRoomMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    if (message.supportLandscape !== false) {
      writer.uint32(24).bool(message.supportLandscape);
    }
    if (message.source !== "0") {
      writer.uint32(32).int64(message.source);
    }
    if (message.icon !== undefined) {
      Image.encode(message.icon, writer.uint32(42).fork()).join();
    }
    if (message.scene !== 0) {
      writer.uint32(48).int32(message.scene);
    }
    if (message.isWelcome !== false) {
      writer.uint32(56).bool(message.isWelcome);
    }
    if (message.publicAreaCommon !== undefined) {
      PublicAreaMessageCommon.encode(message.publicAreaCommon, writer.uint32(66).fork()).join();
    }
    if (message.showDurationMs !== "0") {
      writer.uint32(72).int64(message.showDurationMs);
    }
    if (message.subScene !== "") {
      writer.uint32(82).string(message.subScene);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastRoomMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastRoomMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.supportLandscape = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.source = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.icon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.scene = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isWelcome = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.publicAreaCommon = PublicAreaMessageCommon.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.showDurationMs = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.subScene = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastCaptionMessage(): WebcastCaptionMessage {
  return {
    common: undefined,
    timestampMs: "0",
    durationMs: "0",
    content: [],
    sentenceId: "0",
    sequenceId: "0",
    definite: false,
  };
}

export const WebcastCaptionMessage: MessageFns<WebcastCaptionMessage> = {
  encode(message: WebcastCaptionMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.timestampMs !== "0") {
      writer.uint32(16).int64(message.timestampMs);
    }
    if (message.durationMs !== "0") {
      writer.uint32(24).int64(message.durationMs);
    }
    for (const v of message.content) {
      WebcastCaptionMessage_CaptionContent.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.sentenceId !== "0") {
      writer.uint32(40).int64(message.sentenceId);
    }
    if (message.sequenceId !== "0") {
      writer.uint32(48).int64(message.sequenceId);
    }
    if (message.definite !== false) {
      writer.uint32(56).bool(message.definite);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastCaptionMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastCaptionMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestampMs = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.durationMs = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.content.push(WebcastCaptionMessage_CaptionContent.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sentenceId = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sequenceId = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.definite = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastCaptionMessage_CaptionContent(): WebcastCaptionMessage_CaptionContent {
  return { lang: "", content: "" };
}

export const WebcastCaptionMessage_CaptionContent: MessageFns<WebcastCaptionMessage_CaptionContent> = {
  encode(message: WebcastCaptionMessage_CaptionContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lang !== "") {
      writer.uint32(10).string(message.lang);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastCaptionMessage_CaptionContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastCaptionMessage_CaptionContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lang = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastControlMessage(): WebcastControlMessage {
  return {
    common: undefined,
    action: 0,
    tips: "",
    extra: undefined,
    perceptionDialog: undefined,
    perceptionAudienceText: undefined,
    punishInfo: undefined,
    floatText: undefined,
    floatStyle: 0,
  };
}

export const WebcastControlMessage: MessageFns<WebcastControlMessage> = {
  encode(message: WebcastControlMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.action !== 0) {
      writer.uint32(16).int32(message.action);
    }
    if (message.tips !== "") {
      writer.uint32(26).string(message.tips);
    }
    if (message.extra !== undefined) {
      WebcastControlMessage_Extra.encode(message.extra, writer.uint32(34).fork()).join();
    }
    if (message.perceptionDialog !== undefined) {
      WebcastControlMessage_PerceptionDialogInfo.encode(message.perceptionDialog, writer.uint32(42).fork()).join();
    }
    if (message.perceptionAudienceText !== undefined) {
      Text.encode(message.perceptionAudienceText, writer.uint32(50).fork()).join();
    }
    if (message.punishInfo !== undefined) {
      PunishEventInfo.encode(message.punishInfo, writer.uint32(58).fork()).join();
    }
    if (message.floatText !== undefined) {
      Text.encode(message.floatText, writer.uint32(66).fork()).join();
    }
    if (message.floatStyle !== 0) {
      writer.uint32(72).int32(message.floatStyle);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastControlMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastControlMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tips = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.extra = WebcastControlMessage_Extra.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.perceptionDialog = WebcastControlMessage_PerceptionDialogInfo.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.perceptionAudienceText = Text.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.punishInfo = PunishEventInfo.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.floatText = Text.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.floatStyle = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastControlMessage_Extra(): WebcastControlMessage_Extra {
  return {
    banInfoUrl: "",
    reasonNo: "0",
    title: undefined,
    violationReason: undefined,
    content: undefined,
    gotItButton: undefined,
    banDetailButton: undefined,
    source: "",
  };
}

export const WebcastControlMessage_Extra: MessageFns<WebcastControlMessage_Extra> = {
  encode(message: WebcastControlMessage_Extra, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.banInfoUrl !== "") {
      writer.uint32(10).string(message.banInfoUrl);
    }
    if (message.reasonNo !== "0") {
      writer.uint32(16).int64(message.reasonNo);
    }
    if (message.title !== undefined) {
      Text.encode(message.title, writer.uint32(26).fork()).join();
    }
    if (message.violationReason !== undefined) {
      Text.encode(message.violationReason, writer.uint32(34).fork()).join();
    }
    if (message.content !== undefined) {
      Text.encode(message.content, writer.uint32(42).fork()).join();
    }
    if (message.gotItButton !== undefined) {
      Text.encode(message.gotItButton, writer.uint32(50).fork()).join();
    }
    if (message.banDetailButton !== undefined) {
      Text.encode(message.banDetailButton, writer.uint32(58).fork()).join();
    }
    if (message.source !== "") {
      writer.uint32(66).string(message.source);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastControlMessage_Extra {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastControlMessage_Extra();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.banInfoUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.reasonNo = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = Text.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.violationReason = Text.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.content = Text.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.gotItButton = Text.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.banDetailButton = Text.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.source = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastControlMessage_PerceptionDialogInfo(): WebcastControlMessage_PerceptionDialogInfo {
  return {
    iconType: 0,
    title: undefined,
    subTitle: undefined,
    adviceActionText: undefined,
    defaultActionText: undefined,
    violationDetailUrl: "",
    scene: 0,
    targetUserId: "0",
    targetRoomId: "0",
    countDownTime: "0",
    showFeedback: false,
    feedbackOptions: [],
    policyTip: "0",
    appealPopup: 0,
  };
}

export const WebcastControlMessage_PerceptionDialogInfo: MessageFns<WebcastControlMessage_PerceptionDialogInfo> = {
  encode(message: WebcastControlMessage_PerceptionDialogInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iconType !== 0) {
      writer.uint32(8).int32(message.iconType);
    }
    if (message.title !== undefined) {
      Text.encode(message.title, writer.uint32(18).fork()).join();
    }
    if (message.subTitle !== undefined) {
      Text.encode(message.subTitle, writer.uint32(26).fork()).join();
    }
    if (message.adviceActionText !== undefined) {
      Text.encode(message.adviceActionText, writer.uint32(34).fork()).join();
    }
    if (message.defaultActionText !== undefined) {
      Text.encode(message.defaultActionText, writer.uint32(42).fork()).join();
    }
    if (message.violationDetailUrl !== "") {
      writer.uint32(50).string(message.violationDetailUrl);
    }
    if (message.scene !== 0) {
      writer.uint32(56).int32(message.scene);
    }
    if (message.targetUserId !== "0") {
      writer.uint32(64).int64(message.targetUserId);
    }
    if (message.targetRoomId !== "0") {
      writer.uint32(72).int64(message.targetRoomId);
    }
    if (message.countDownTime !== "0") {
      writer.uint32(80).int64(message.countDownTime);
    }
    if (message.showFeedback !== false) {
      writer.uint32(88).bool(message.showFeedback);
    }
    for (const v of message.feedbackOptions) {
      WebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.policyTip !== "0") {
      writer.uint32(104).int64(message.policyTip);
    }
    if (message.appealPopup !== 0) {
      writer.uint32(112).int32(message.appealPopup);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastControlMessage_PerceptionDialogInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastControlMessage_PerceptionDialogInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.iconType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = Text.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subTitle = Text.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.adviceActionText = Text.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.defaultActionText = Text.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.violationDetailUrl = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.scene = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.targetUserId = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.targetRoomId = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.countDownTime = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.showFeedback = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.feedbackOptions.push(
            WebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.policyTip = reader.int64().toString();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.appealPopup = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption(): WebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption {
  return { id: "0", contentKey: "" };
}

export const WebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption: MessageFns<
  WebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption
> = {
  encode(
    message: WebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "0") {
      writer.uint32(8).int64(message.id);
    }
    if (message.contentKey !== "") {
      writer.uint32(18).string(message.contentKey);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contentKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGoalUpdateMessage(): WebcastGoalUpdateMessage {
  return {
    common: undefined,
    indicator: undefined,
    goal: undefined,
    contributorId: "0",
    contributorAvatar: undefined,
    contributorDisplayId: "",
    contributeSubgoal: undefined,
    contributeCount: "0",
    contributeScore: "0",
    giftRepeatCount: "0",
    contributorIdStr: "",
    pin: false,
    unpin: false,
    pinInfo: undefined,
    updateSource: 0,
    goalExtra: "",
  };
}

export const WebcastGoalUpdateMessage: MessageFns<WebcastGoalUpdateMessage> = {
  encode(message: WebcastGoalUpdateMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.indicator !== undefined) {
      LiveStreamGoalIndicator.encode(message.indicator, writer.uint32(18).fork()).join();
    }
    if (message.goal !== undefined) {
      LiveStreamGoal.encode(message.goal, writer.uint32(26).fork()).join();
    }
    if (message.contributorId !== "0") {
      writer.uint32(32).int64(message.contributorId);
    }
    if (message.contributorAvatar !== undefined) {
      Image.encode(message.contributorAvatar, writer.uint32(42).fork()).join();
    }
    if (message.contributorDisplayId !== "") {
      writer.uint32(50).string(message.contributorDisplayId);
    }
    if (message.contributeSubgoal !== undefined) {
      WebcastGoalUpdateMessage_LiveStreamSubGoal.encode(message.contributeSubgoal, writer.uint32(58).fork()).join();
    }
    if (message.contributeCount !== "0") {
      writer.uint32(72).int64(message.contributeCount);
    }
    if (message.contributeScore !== "0") {
      writer.uint32(80).int64(message.contributeScore);
    }
    if (message.giftRepeatCount !== "0") {
      writer.uint32(88).int64(message.giftRepeatCount);
    }
    if (message.contributorIdStr !== "") {
      writer.uint32(98).string(message.contributorIdStr);
    }
    if (message.pin !== false) {
      writer.uint32(104).bool(message.pin);
    }
    if (message.unpin !== false) {
      writer.uint32(112).bool(message.unpin);
    }
    if (message.pinInfo !== undefined) {
      WebcastGoalUpdateMessage_GoalPinInfo.encode(message.pinInfo, writer.uint32(122).fork()).join();
    }
    if (message.updateSource !== 0) {
      writer.uint32(128).int32(message.updateSource);
    }
    if (message.goalExtra !== "") {
      writer.uint32(138).string(message.goalExtra);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGoalUpdateMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGoalUpdateMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.indicator = LiveStreamGoalIndicator.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.goal = LiveStreamGoal.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.contributorId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contributorAvatar = Image.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.contributorDisplayId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.contributeSubgoal = WebcastGoalUpdateMessage_LiveStreamSubGoal.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.contributeCount = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.contributeScore = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.giftRepeatCount = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.contributorIdStr = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.pin = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.unpin = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.pinInfo = WebcastGoalUpdateMessage_GoalPinInfo.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.updateSource = reader.int32() as any;
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.goalExtra = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGoalUpdateMessage_LiveStreamSubGoal(): WebcastGoalUpdateMessage_LiveStreamSubGoal {
  return {
    type: 0,
    id: "0",
    progress: "0",
    target: "0",
    gift: undefined,
    idStr: "",
    pinInfo: undefined,
    source: 0,
    recommendedText: "",
    recommendedCommon: "",
  };
}

export const WebcastGoalUpdateMessage_LiveStreamSubGoal: MessageFns<WebcastGoalUpdateMessage_LiveStreamSubGoal> = {
  encode(message: WebcastGoalUpdateMessage_LiveStreamSubGoal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.id !== "0") {
      writer.uint32(16).int64(message.id);
    }
    if (message.progress !== "0") {
      writer.uint32(24).int64(message.progress);
    }
    if (message.target !== "0") {
      writer.uint32(32).int64(message.target);
    }
    if (message.gift !== undefined) {
      WebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift.encode(message.gift, writer.uint32(42).fork())
        .join();
    }
    if (message.idStr !== "") {
      writer.uint32(50).string(message.idStr);
    }
    if (message.pinInfo !== undefined) {
      WebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo.encode(message.pinInfo, writer.uint32(58).fork())
        .join();
    }
    if (message.source !== 0) {
      writer.uint32(64).int32(message.source);
    }
    if (message.recommendedText !== "") {
      writer.uint32(74).string(message.recommendedText);
    }
    if (message.recommendedCommon !== "") {
      writer.uint32(82).string(message.recommendedCommon);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGoalUpdateMessage_LiveStreamSubGoal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGoalUpdateMessage_LiveStreamSubGoal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.progress = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.target = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.gift = WebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.idStr = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.pinInfo = WebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.source = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.recommendedText = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.recommendedCommon = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift(): WebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift {
  return { name: "", icon: undefined, diamondCount: "0", type: 0 };
}

export const WebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift: MessageFns<
  WebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift
> = {
  encode(
    message: WebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.icon !== undefined) {
      Image.encode(message.icon, writer.uint32(18).fork()).join();
    }
    if (message.diamondCount !== "0") {
      writer.uint32(24).int64(message.diamondCount);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.icon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.diamondCount = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo(): WebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo {
  return { pinStartTime: "0", pinEndTime: "0", pinReadyTime: "0" };
}

export const WebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo: MessageFns<
  WebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo
> = {
  encode(
    message: WebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.pinStartTime !== "0") {
      writer.uint32(8).int64(message.pinStartTime);
    }
    if (message.pinEndTime !== "0") {
      writer.uint32(16).int64(message.pinEndTime);
    }
    if (message.pinReadyTime !== "0") {
      writer.uint32(24).int64(message.pinReadyTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pinStartTime = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pinEndTime = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pinReadyTime = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastGoalUpdateMessage_GoalPinInfo(): WebcastGoalUpdateMessage_GoalPinInfo {
  return { pin: false, unpin: false, pinEndTime: "0", subGoalId: "0", subGoalIdStr: "" };
}

export const WebcastGoalUpdateMessage_GoalPinInfo: MessageFns<WebcastGoalUpdateMessage_GoalPinInfo> = {
  encode(message: WebcastGoalUpdateMessage_GoalPinInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pin !== false) {
      writer.uint32(8).bool(message.pin);
    }
    if (message.unpin !== false) {
      writer.uint32(16).bool(message.unpin);
    }
    if (message.pinEndTime !== "0") {
      writer.uint32(24).int64(message.pinEndTime);
    }
    if (message.subGoalId !== "0") {
      writer.uint32(32).int64(message.subGoalId);
    }
    if (message.subGoalIdStr !== "") {
      writer.uint32(42).string(message.subGoalIdStr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastGoalUpdateMessage_GoalPinInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastGoalUpdateMessage_GoalPinInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pin = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.unpin = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pinEndTime = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.subGoalId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.subGoalIdStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastImDeleteMessage(): WebcastImDeleteMessage {
  return { common: undefined, deleteMsgIdsList: [], deleteUserIdsList: [] };
}

export const WebcastImDeleteMessage: MessageFns<WebcastImDeleteMessage> = {
  encode(message: WebcastImDeleteMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    writer.uint32(18).fork();
    for (const v of message.deleteMsgIdsList) {
      writer.int64(v);
    }
    writer.join();
    writer.uint32(26).fork();
    for (const v of message.deleteUserIdsList) {
      writer.int64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastImDeleteMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastImDeleteMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.deleteMsgIdsList.push(reader.int64().toString());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.deleteMsgIdsList.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag === 24) {
            message.deleteUserIdsList.push(reader.int64().toString());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.deleteUserIdsList.push(reader.int64().toString());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastInRoomBannerMessage(): WebcastInRoomBannerMessage {
  return { common: undefined, data: {}, position: 0, actionType: 0 };
}

export const WebcastInRoomBannerMessage: MessageFns<WebcastInRoomBannerMessage> = {
  encode(message: WebcastInRoomBannerMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    Object.entries(message.data).forEach(([key, value]) => {
      WebcastInRoomBannerMessage_DataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.position !== 0) {
      writer.uint32(24).int32(message.position);
    }
    if (message.actionType !== 0) {
      writer.uint32(32).int32(message.actionType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastInRoomBannerMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastInRoomBannerMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = WebcastInRoomBannerMessage_DataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.data[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.position = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.actionType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastInRoomBannerMessage_DataEntry(): WebcastInRoomBannerMessage_DataEntry {
  return { key: "", value: "" };
}

export const WebcastInRoomBannerMessage_DataEntry: MessageFns<WebcastInRoomBannerMessage_DataEntry> = {
  encode(message: WebcastInRoomBannerMessage_DataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastInRoomBannerMessage_DataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastInRoomBannerMessage_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastRankUpdateMessage(): WebcastRankUpdateMessage {
  return {
    common: undefined,
    updatesList: [],
    groupType: "0",
    priority: "0",
    tabsList: [],
    isAnimationLoopPlay: false,
    animationLoopForOff: false,
    unionAnimation: [],
    tabInfo: [],
  };
}

export const WebcastRankUpdateMessage: MessageFns<WebcastRankUpdateMessage> = {
  encode(message: WebcastRankUpdateMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    for (const v of message.updatesList) {
      WebcastRankUpdateMessage_RankUpdate.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.groupType !== "0") {
      writer.uint32(24).int64(message.groupType);
    }
    if (message.priority !== "0") {
      writer.uint32(40).int64(message.priority);
    }
    for (const v of message.tabsList) {
      WebcastRankUpdateMessage_RankTabInfo.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.isAnimationLoopPlay !== false) {
      writer.uint32(56).bool(message.isAnimationLoopPlay);
    }
    if (message.animationLoopForOff !== false) {
      writer.uint32(64).bool(message.animationLoopForOff);
    }
    for (const v of message.unionAnimation) {
      WebcastRankUpdateMessage_UnionAnimationInfo.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.tabInfo) {
      WebcastRankUpdateMessage_RankListTabInfo.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastRankUpdateMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastRankUpdateMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updatesList.push(WebcastRankUpdateMessage_RankUpdate.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.groupType = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.priority = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tabsList.push(WebcastRankUpdateMessage_RankTabInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isAnimationLoopPlay = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.animationLoopForOff = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.unionAnimation.push(WebcastRankUpdateMessage_UnionAnimationInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.tabInfo.push(WebcastRankUpdateMessage_RankListTabInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastRankUpdateMessage_UnionAnimationInfo(): WebcastRankUpdateMessage_UnionAnimationInfo {
  return { unionType: 0, rankTypeArray: 0, supportedVersion: "0" };
}

export const WebcastRankUpdateMessage_UnionAnimationInfo: MessageFns<WebcastRankUpdateMessage_UnionAnimationInfo> = {
  encode(
    message: WebcastRankUpdateMessage_UnionAnimationInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.unionType !== 0) {
      writer.uint32(8).int32(message.unionType);
    }
    if (message.rankTypeArray !== 0) {
      writer.uint32(16).int32(message.rankTypeArray);
    }
    if (message.supportedVersion !== "0") {
      writer.uint32(24).int64(message.supportedVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastRankUpdateMessage_UnionAnimationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastRankUpdateMessage_UnionAnimationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.unionType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rankTypeArray = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.supportedVersion = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastRankUpdateMessage_RankListTabInfo(): WebcastRankUpdateMessage_RankListTabInfo {
  return { tabs: [], supportedVersion: "0" };
}

export const WebcastRankUpdateMessage_RankListTabInfo: MessageFns<WebcastRankUpdateMessage_RankListTabInfo> = {
  encode(message: WebcastRankUpdateMessage_RankListTabInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tabs) {
      WebcastRankUpdateMessage_RankTabInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.supportedVersion !== "0") {
      writer.uint32(16).int64(message.supportedVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastRankUpdateMessage_RankListTabInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastRankUpdateMessage_RankListTabInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tabs.push(WebcastRankUpdateMessage_RankTabInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.supportedVersion = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastRankUpdateMessage_RankTabInfo(): WebcastRankUpdateMessage_RankTabInfo {
  return { rankType: 0, title: "", titleText: undefined, listLynxType: "0" };
}

export const WebcastRankUpdateMessage_RankTabInfo: MessageFns<WebcastRankUpdateMessage_RankTabInfo> = {
  encode(message: WebcastRankUpdateMessage_RankTabInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rankType !== 0) {
      writer.uint32(8).int32(message.rankType);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.titleText !== undefined) {
      Text.encode(message.titleText, writer.uint32(26).fork()).join();
    }
    if (message.listLynxType !== "0") {
      writer.uint32(32).int64(message.listLynxType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastRankUpdateMessage_RankTabInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastRankUpdateMessage_RankTabInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rankType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.titleText = Text.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.listLynxType = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastRankUpdateMessage_RankUpdate(): WebcastRankUpdateMessage_RankUpdate {
  return {
    rankType: "0",
    ownerRank: "0",
    defaultContent: undefined,
    showEntranceAnimation: false,
    countdown: "0",
    relatedTabRankType: "0",
    requestFirstShowType: "0",
    supportedVersion: "0",
    owneronrank: false,
  };
}

export const WebcastRankUpdateMessage_RankUpdate: MessageFns<WebcastRankUpdateMessage_RankUpdate> = {
  encode(message: WebcastRankUpdateMessage_RankUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rankType !== "0") {
      writer.uint32(8).int64(message.rankType);
    }
    if (message.ownerRank !== "0") {
      writer.uint32(16).int64(message.ownerRank);
    }
    if (message.defaultContent !== undefined) {
      Text.encode(message.defaultContent, writer.uint32(26).fork()).join();
    }
    if (message.showEntranceAnimation !== false) {
      writer.uint32(40).bool(message.showEntranceAnimation);
    }
    if (message.countdown !== "0") {
      writer.uint32(48).int64(message.countdown);
    }
    if (message.relatedTabRankType !== "0") {
      writer.uint32(64).int64(message.relatedTabRankType);
    }
    if (message.requestFirstShowType !== "0") {
      writer.uint32(72).int64(message.requestFirstShowType);
    }
    if (message.supportedVersion !== "0") {
      writer.uint32(80).int64(message.supportedVersion);
    }
    if (message.owneronrank !== false) {
      writer.uint32(88).bool(message.owneronrank);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastRankUpdateMessage_RankUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastRankUpdateMessage_RankUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rankType = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ownerRank = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.defaultContent = Text.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.showEntranceAnimation = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.countdown = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.relatedTabRankType = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.requestFirstShowType = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.supportedVersion = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.owneronrank = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastPollMessage(): WebcastPollMessage {
  return {
    common: undefined,
    messageType: 0,
    pollId: "0",
    startContent: undefined,
    endContent: undefined,
    updateContent: undefined,
    pollKind: 0,
    pollBasicInfo: undefined,
    templateContent: undefined,
  };
}

export const WebcastPollMessage: MessageFns<WebcastPollMessage> = {
  encode(message: WebcastPollMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.messageType !== 0) {
      writer.uint32(16).int32(message.messageType);
    }
    if (message.pollId !== "0") {
      writer.uint32(24).int64(message.pollId);
    }
    if (message.startContent !== undefined) {
      PollStartContent.encode(message.startContent, writer.uint32(34).fork()).join();
    }
    if (message.endContent !== undefined) {
      PollEndContent.encode(message.endContent, writer.uint32(42).fork()).join();
    }
    if (message.updateContent !== undefined) {
      PollUpdateVotesContent.encode(message.updateContent, writer.uint32(50).fork()).join();
    }
    if (message.pollKind !== 0) {
      writer.uint32(56).int32(message.pollKind);
    }
    if (message.pollBasicInfo !== undefined) {
      WebcastPollMessage_PollBasicInfo.encode(message.pollBasicInfo, writer.uint32(66).fork()).join();
    }
    if (message.templateContent !== undefined) {
      WebcastPollMessage_TemplateContent.encode(message.templateContent, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastPollMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastPollMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.messageType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pollId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.startContent = PollStartContent.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.endContent = PollEndContent.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updateContent = PollUpdateVotesContent.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.pollKind = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.pollBasicInfo = WebcastPollMessage_PollBasicInfo.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.templateContent = WebcastPollMessage_TemplateContent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastPollMessage_TemplateContent(): WebcastPollMessage_TemplateContent {
  return { templateId: "0", templateIdStr: "", status: 0, pollKind: 0, appealStatus: 0, violationIdStr: "" };
}

export const WebcastPollMessage_TemplateContent: MessageFns<WebcastPollMessage_TemplateContent> = {
  encode(message: WebcastPollMessage_TemplateContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.templateId !== "0") {
      writer.uint32(8).int64(message.templateId);
    }
    if (message.templateIdStr !== "") {
      writer.uint32(18).string(message.templateIdStr);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.pollKind !== 0) {
      writer.uint32(32).int32(message.pollKind);
    }
    if (message.appealStatus !== 0) {
      writer.uint32(40).int32(message.appealStatus);
    }
    if (message.violationIdStr !== "") {
      writer.uint32(50).string(message.violationIdStr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastPollMessage_TemplateContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastPollMessage_TemplateContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.templateId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.templateIdStr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pollKind = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.appealStatus = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.violationIdStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastPollMessage_PollBasicInfo(): WebcastPollMessage_PollBasicInfo {
  return {
    pollSponsor: "",
    giftId: "0",
    title: "",
    isSuggestedQuestion: false,
    userCnt: "0",
    gift: undefined,
    pollIdStr: "",
    suggestedQuestionKey: "",
    pollDuration: "0",
    timeRemain: "0",
    pollIndex: "0",
    templateId: "0",
  };
}

export const WebcastPollMessage_PollBasicInfo: MessageFns<WebcastPollMessage_PollBasicInfo> = {
  encode(message: WebcastPollMessage_PollBasicInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pollSponsor !== "") {
      writer.uint32(10).string(message.pollSponsor);
    }
    if (message.giftId !== "0") {
      writer.uint32(16).int64(message.giftId);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.isSuggestedQuestion !== false) {
      writer.uint32(32).bool(message.isSuggestedQuestion);
    }
    if (message.userCnt !== "0") {
      writer.uint32(40).int64(message.userCnt);
    }
    if (message.gift !== undefined) {
      Gift.encode(message.gift, writer.uint32(50).fork()).join();
    }
    if (message.pollIdStr !== "") {
      writer.uint32(58).string(message.pollIdStr);
    }
    if (message.suggestedQuestionKey !== "") {
      writer.uint32(66).string(message.suggestedQuestionKey);
    }
    if (message.pollDuration !== "0") {
      writer.uint32(72).int64(message.pollDuration);
    }
    if (message.timeRemain !== "0") {
      writer.uint32(80).int64(message.timeRemain);
    }
    if (message.pollIndex !== "0") {
      writer.uint32(88).int64(message.pollIndex);
    }
    if (message.templateId !== "0") {
      writer.uint32(96).int64(message.templateId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastPollMessage_PollBasicInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastPollMessage_PollBasicInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pollSponsor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.giftId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isSuggestedQuestion = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.userCnt = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.gift = Gift.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.pollIdStr = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.suggestedQuestionKey = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.pollDuration = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.timeRemain = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.pollIndex = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.templateId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastRankTextMessage(): WebcastRankTextMessage {
  return {
    common: undefined,
    scene: 0,
    ownerIdxBeforeUpdate: "0",
    ownerIdxAfterUpdate: "0",
    selfGetBadgeMsg: undefined,
    otherGetBadgeMsg: undefined,
    curUserId: "0",
  };
}

export const WebcastRankTextMessage: MessageFns<WebcastRankTextMessage> = {
  encode(message: WebcastRankTextMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.scene !== 0) {
      writer.uint32(16).int32(message.scene);
    }
    if (message.ownerIdxBeforeUpdate !== "0") {
      writer.uint32(24).int64(message.ownerIdxBeforeUpdate);
    }
    if (message.ownerIdxAfterUpdate !== "0") {
      writer.uint32(32).int64(message.ownerIdxAfterUpdate);
    }
    if (message.selfGetBadgeMsg !== undefined) {
      Text.encode(message.selfGetBadgeMsg, writer.uint32(42).fork()).join();
    }
    if (message.otherGetBadgeMsg !== undefined) {
      Text.encode(message.otherGetBadgeMsg, writer.uint32(50).fork()).join();
    }
    if (message.curUserId !== "0") {
      writer.uint32(56).int64(message.curUserId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastRankTextMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastRankTextMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.scene = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.ownerIdxBeforeUpdate = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ownerIdxAfterUpdate = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.selfGetBadgeMsg = Text.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.otherGetBadgeMsg = Text.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.curUserId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicBattlePunishFinish(): WebcastLinkMicBattlePunishFinish {
  return { common: undefined, channelId: "0", opUid: "0", reason: 0, battleId: "0", battleSettings: undefined };
}

export const WebcastLinkMicBattlePunishFinish: MessageFns<WebcastLinkMicBattlePunishFinish> = {
  encode(message: WebcastLinkMicBattlePunishFinish, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.channelId !== "0") {
      writer.uint32(16).int64(message.channelId);
    }
    if (message.opUid !== "0") {
      writer.uint32(24).int64(message.opUid);
    }
    if (message.reason !== 0) {
      writer.uint32(32).int32(message.reason);
    }
    if (message.battleId !== "0") {
      writer.uint32(40).int64(message.battleId);
    }
    if (message.battleSettings !== undefined) {
      BattleSetting.encode(message.battleSettings, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicBattlePunishFinish {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicBattlePunishFinish();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.channelId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.opUid = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.reason = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.battleId = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.battleSettings = BattleSetting.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage(): WebcastLinkmicBattleTaskMessage {
  return {
    common: undefined,
    battleTaskMessageType: 0,
    taskStart: undefined,
    taskUpdate: undefined,
    taskSettle: undefined,
    rewardSettle: undefined,
    battleId: "0",
  };
}

export const WebcastLinkmicBattleTaskMessage: MessageFns<WebcastLinkmicBattleTaskMessage> = {
  encode(message: WebcastLinkmicBattleTaskMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.battleTaskMessageType !== 0) {
      writer.uint32(16).int32(message.battleTaskMessageType);
    }
    if (message.taskStart !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattleTaskStart.encode(message.taskStart, writer.uint32(26).fork()).join();
    }
    if (message.taskUpdate !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattleTaskUpdate.encode(message.taskUpdate, writer.uint32(34).fork()).join();
    }
    if (message.taskSettle !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattleTaskSettle.encode(message.taskSettle, writer.uint32(42).fork()).join();
    }
    if (message.rewardSettle !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattleRewardSettle.encode(message.rewardSettle, writer.uint32(50).fork()).join();
    }
    if (message.battleId !== "0") {
      writer.uint32(160).int64(message.battleId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkmicBattleTaskMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.battleTaskMessageType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.taskStart = WebcastLinkmicBattleTaskMessage_BattleTaskStart.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.taskUpdate = WebcastLinkmicBattleTaskMessage_BattleTaskUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.taskSettle = WebcastLinkmicBattleTaskMessage_BattleTaskSettle.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rewardSettle = WebcastLinkmicBattleTaskMessage_BattleRewardSettle.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.battleId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattlePrompt(): WebcastLinkmicBattleTaskMessage_BattlePrompt {
  return { promptKey: "", promptElements: [] };
}

export const WebcastLinkmicBattleTaskMessage_BattlePrompt: MessageFns<WebcastLinkmicBattleTaskMessage_BattlePrompt> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattlePrompt,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.promptKey !== "") {
      writer.uint32(10).string(message.promptKey);
    }
    for (const v of message.promptElements) {
      WebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkmicBattleTaskMessage_BattlePrompt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage_BattlePrompt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.promptKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.promptElements.push(
            WebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem(): WebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem {
  return { promptFieldKey: "", promptFieldValue: "" };
}

export const WebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem: MessageFns<
  WebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem
> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.promptFieldKey !== "") {
      writer.uint32(10).string(message.promptFieldKey);
    }
    if (message.promptFieldValue !== "") {
      writer.uint32(18).string(message.promptFieldValue);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.promptFieldKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.promptFieldValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart(): WebcastLinkmicBattleTaskMessage_BattleTaskStart {
  return { battleBonusConfig: undefined };
}

export const WebcastLinkmicBattleTaskMessage_BattleTaskStart: MessageFns<
  WebcastLinkmicBattleTaskMessage_BattleTaskStart
> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattleTaskStart,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.battleBonusConfig !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig.encode(
        message.battleBonusConfig,
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkmicBattleTaskMessage_BattleTaskStart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.battleBonusConfig = WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig(): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig {
  return {
    previewStartTime: "0",
    previewPeriodConfig: [],
    taskPeriodConfig: undefined,
    rewardPeriodConfig: undefined,
    taskGiftGuide: {},
    previewStartTimestamp: "0",
    previewClickActionSchemaUrl: "",
  };
}

export const WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig: MessageFns<
  WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig
> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.previewStartTime !== "0") {
      writer.uint32(8).int64(message.previewStartTime);
    }
    for (const v of message.previewPeriodConfig) {
      WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod.encode(
        v!,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.taskPeriodConfig !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig.encode(
        message.taskPeriodConfig,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.rewardPeriodConfig !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig.encode(
        message.rewardPeriodConfig,
        writer.uint32(34).fork(),
      ).join();
    }
    Object.entries(message.taskGiftGuide).forEach(([key, value]) => {
      WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry.encode({
        key: key as any,
        value,
      }, writer.uint32(42).fork()).join();
    });
    if (message.previewStartTimestamp !== "0") {
      writer.uint32(48).int64(message.previewStartTimestamp);
    }
    if (message.previewClickActionSchemaUrl !== "") {
      writer.uint32(58).string(message.previewClickActionSchemaUrl);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.previewStartTime = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.previewPeriodConfig.push(
            WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod.decode(
              reader,
              reader.uint32(),
            ),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.taskPeriodConfig = WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig
            .decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rewardPeriodConfig =
            WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig.decode(
              reader,
              reader.uint32(),
            );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry5.value !== undefined) {
            message.taskGiftGuide[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.previewStartTimestamp = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.previewClickActionSchemaUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry(): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry {
  return { key: "0", value: undefined };
}

export const WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry: MessageFns<
  WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry
> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "0") {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide.encode(
        message.value,
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide
            .decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod(): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod {
  return { duration: "0", promot: undefined, icon: undefined };
}

export const WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod: MessageFns<
  WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod
> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.duration !== "0") {
      writer.uint32(8).int64(message.duration);
    }
    if (message.promot !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattlePrompt.encode(message.promot, writer.uint32(18).fork()).join();
    }
    if (message.icon !== undefined) {
      Image.encode(message.icon, writer.uint32(202).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.duration = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.promot = WebcastLinkmicBattleTaskMessage_BattlePrompt.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.icon = Image.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig(): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig {
  return {
    taskStartTime: "0",
    duration: "0",
    targetStartTimestamp: "0",
    clickAction: 0,
    clickToastPrompt: undefined,
    promptType: 0,
    taskStaticPrompt: undefined,
    progressTarget: "0",
    targetType: 0,
    icon: undefined,
    clickActionSchemaUrl: "",
  };
}

export const WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig: MessageFns<
  WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig
> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.taskStartTime !== "0") {
      writer.uint32(8).int64(message.taskStartTime);
    }
    if (message.duration !== "0") {
      writer.uint32(16).int64(message.duration);
    }
    if (message.targetStartTimestamp !== "0") {
      writer.uint32(24).int64(message.targetStartTimestamp);
    }
    if (message.clickAction !== 0) {
      writer.uint32(88).int32(message.clickAction);
    }
    if (message.clickToastPrompt !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattlePrompt.encode(message.clickToastPrompt, writer.uint32(98).fork()).join();
    }
    if (message.promptType !== 0) {
      writer.uint32(168).int32(message.promptType);
    }
    if (message.taskStaticPrompt !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattlePrompt.encode(message.taskStaticPrompt, writer.uint32(178).fork()).join();
    }
    if (message.progressTarget !== "0") {
      writer.uint32(184).int64(message.progressTarget);
    }
    if (message.targetType !== 0) {
      writer.uint32(192).int32(message.targetType);
    }
    if (message.icon !== undefined) {
      Image.encode(message.icon, writer.uint32(202).fork()).join();
    }
    if (message.clickActionSchemaUrl !== "") {
      writer.uint32(210).string(message.clickActionSchemaUrl);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.taskStartTime = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.duration = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.targetStartTimestamp = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.clickAction = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.clickToastPrompt = WebcastLinkmicBattleTaskMessage_BattlePrompt.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.promptType = reader.int32();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.taskStaticPrompt = WebcastLinkmicBattleTaskMessage_BattlePrompt.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.progressTarget = reader.int64().toString();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.targetType = reader.int32();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.icon = Image.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.clickActionSchemaUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig(): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig {
  return {
    rewardStartTime: "0",
    duration: "0",
    rewardMultiple: 0,
    rewardStartTimestamp: "0",
    rewardPraparePrompt: undefined,
    rewardingPrompt: undefined,
    clickPrompt: undefined,
  };
}

export const WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig: MessageFns<
  WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig
> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.rewardStartTime !== "0") {
      writer.uint32(8).int64(message.rewardStartTime);
    }
    if (message.duration !== "0") {
      writer.uint32(16).int64(message.duration);
    }
    if (message.rewardMultiple !== 0) {
      writer.uint32(24).int32(message.rewardMultiple);
    }
    if (message.rewardStartTimestamp !== "0") {
      writer.uint32(32).int64(message.rewardStartTimestamp);
    }
    if (message.rewardPraparePrompt !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattlePrompt.encode(message.rewardPraparePrompt, writer.uint32(90).fork()).join();
    }
    if (message.rewardingPrompt !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattlePrompt.encode(message.rewardingPrompt, writer.uint32(98).fork()).join();
    }
    if (message.clickPrompt !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattlePrompt.encode(message.clickPrompt, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rewardStartTime = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.duration = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rewardMultiple = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rewardStartTimestamp = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.rewardPraparePrompt = WebcastLinkmicBattleTaskMessage_BattlePrompt.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.rewardingPrompt = WebcastLinkmicBattleTaskMessage_BattlePrompt.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.clickPrompt = WebcastLinkmicBattleTaskMessage_BattlePrompt.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide(): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide {
  return {
    guidePrompt: undefined,
    promptType: 0,
    disappearDuration: 0,
    iconImage: undefined,
    giftImage: undefined,
    recommendGiftId: "0",
    recommendGiftCount: 0,
    guideContent: undefined,
  };
}

export const WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide: MessageFns<
  WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide
> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.guidePrompt !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattlePrompt.encode(message.guidePrompt, writer.uint32(10).fork()).join();
    }
    if (message.promptType !== 0) {
      writer.uint32(16).int32(message.promptType);
    }
    if (message.disappearDuration !== 0) {
      writer.uint32(24).int32(message.disappearDuration);
    }
    if (message.iconImage !== undefined) {
      Image.encode(message.iconImage, writer.uint32(90).fork()).join();
    }
    if (message.giftImage !== undefined) {
      Image.encode(message.giftImage, writer.uint32(98).fork()).join();
    }
    if (message.recommendGiftId !== "0") {
      writer.uint32(168).int64(message.recommendGiftId);
    }
    if (message.recommendGiftCount !== 0) {
      writer.uint32(176).int32(message.recommendGiftCount);
    }
    if (message.guideContent !== undefined) {
      Text.encode(message.guideContent, writer.uint32(186).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message =
      createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.guidePrompt = WebcastLinkmicBattleTaskMessage_BattlePrompt.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.promptType = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.disappearDuration = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.iconImage = Image.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.giftImage = Image.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.recommendGiftId = reader.int64().toString();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.recommendGiftCount = reader.int32();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.guideContent = Text.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskUpdate(): WebcastLinkmicBattleTaskMessage_BattleTaskUpdate {
  return { taskProgress: "0", fromUserUid: "0", promptKey: "", logId: "" };
}

export const WebcastLinkmicBattleTaskMessage_BattleTaskUpdate: MessageFns<
  WebcastLinkmicBattleTaskMessage_BattleTaskUpdate
> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattleTaskUpdate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.taskProgress !== "0") {
      writer.uint32(8).int64(message.taskProgress);
    }
    if (message.fromUserUid !== "0") {
      writer.uint32(16).int64(message.fromUserUid);
    }
    if (message.promptKey !== "") {
      writer.uint32(26).string(message.promptKey);
    }
    if (message.logId !== "") {
      writer.uint32(170).string(message.logId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkmicBattleTaskMessage_BattleTaskUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.taskProgress = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fromUserUid = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.promptKey = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.logId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskSettle(): WebcastLinkmicBattleTaskMessage_BattleTaskSettle {
  return { taskResult: 0, rewardStartTime: "0", rewardStartTimestamp: "0" };
}

export const WebcastLinkmicBattleTaskMessage_BattleTaskSettle: MessageFns<
  WebcastLinkmicBattleTaskMessage_BattleTaskSettle
> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattleTaskSettle,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.taskResult !== 0) {
      writer.uint32(8).int32(message.taskResult);
    }
    if (message.rewardStartTime !== "0") {
      writer.uint32(16).int64(message.rewardStartTime);
    }
    if (message.rewardStartTimestamp !== "0") {
      writer.uint32(24).int64(message.rewardStartTimestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkmicBattleTaskMessage_BattleTaskSettle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskSettle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.taskResult = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rewardStartTime = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rewardStartTimestamp = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkmicBattleTaskMessage_BattleRewardSettle(): WebcastLinkmicBattleTaskMessage_BattleRewardSettle {
  return { rewardSettlePrompt: undefined, status: 0 };
}

export const WebcastLinkmicBattleTaskMessage_BattleRewardSettle: MessageFns<
  WebcastLinkmicBattleTaskMessage_BattleRewardSettle
> = {
  encode(
    message: WebcastLinkmicBattleTaskMessage_BattleRewardSettle,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.rewardSettlePrompt !== undefined) {
      WebcastLinkmicBattleTaskMessage_BattlePrompt.encode(message.rewardSettlePrompt, writer.uint32(10).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkmicBattleTaskMessage_BattleRewardSettle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkmicBattleTaskMessage_BattleRewardSettle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rewardSettlePrompt = WebcastLinkmicBattleTaskMessage_BattlePrompt.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicFanTicketMethod(): WebcastLinkMicFanTicketMethod {
  return { common: undefined, FanTicketRoomNotice: undefined };
}

export const WebcastLinkMicFanTicketMethod: MessageFns<WebcastLinkMicFanTicketMethod> = {
  encode(message: WebcastLinkMicFanTicketMethod, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.FanTicketRoomNotice !== undefined) {
      FanTicketRoomNoticeContent.encode(message.FanTicketRoomNotice, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicFanTicketMethod {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicFanTicketMethod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.FanTicketRoomNotice = FanTicketRoomNoticeContent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMicMethod(): WebcastLinkMicMethod {
  return {
    common: undefined,
    messageType: 0,
    accessKey: "",
    anchorLinkmicId: "0",
    userId: "0",
    fanTicket: "0",
    totalLinkMicFanTicket: "0",
    channelId: "0",
    layout: "0",
    vendor: "0",
    dimension: "0",
    theme: "",
    inviteUid: "0",
    reply: 0,
    duration: 0,
    matchType: 0,
    win: false,
    prompts: "",
    toUserId: "0",
    tips: "",
    startTimeMs: "0",
    confluenceType: 0,
    fromRoomId: "0",
    inviteType: 0,
    subType: "0",
    rtcExtInfo: "",
    appId: "",
    appSign: "",
    anchorLinkMicIdStr: "",
    rivalAnchorId: "0",
    rivalLinkmicId: 0,
    rivalLinkmicIdStr: "",
    shouldShowPopup: false,
    rtcJoinChannel: false,
    fanTicketType: 0,
  };
}

export const WebcastLinkMicMethod: MessageFns<WebcastLinkMicMethod> = {
  encode(message: WebcastLinkMicMethod, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.messageType !== 0) {
      writer.uint32(16).int32(message.messageType);
    }
    if (message.accessKey !== "") {
      writer.uint32(26).string(message.accessKey);
    }
    if (message.anchorLinkmicId !== "0") {
      writer.uint32(32).int64(message.anchorLinkmicId);
    }
    if (message.userId !== "0") {
      writer.uint32(40).int64(message.userId);
    }
    if (message.fanTicket !== "0") {
      writer.uint32(48).int64(message.fanTicket);
    }
    if (message.totalLinkMicFanTicket !== "0") {
      writer.uint32(56).int64(message.totalLinkMicFanTicket);
    }
    if (message.channelId !== "0") {
      writer.uint32(64).int64(message.channelId);
    }
    if (message.layout !== "0") {
      writer.uint32(72).int64(message.layout);
    }
    if (message.vendor !== "0") {
      writer.uint32(80).int64(message.vendor);
    }
    if (message.dimension !== "0") {
      writer.uint32(88).int64(message.dimension);
    }
    if (message.theme !== "") {
      writer.uint32(98).string(message.theme);
    }
    if (message.inviteUid !== "0") {
      writer.uint32(104).int64(message.inviteUid);
    }
    if (message.reply !== 0) {
      writer.uint32(112).int32(message.reply);
    }
    if (message.duration !== 0) {
      writer.uint32(128).int32(message.duration);
    }
    if (message.matchType !== 0) {
      writer.uint32(144).int32(message.matchType);
    }
    if (message.win !== false) {
      writer.uint32(152).bool(message.win);
    }
    if (message.prompts !== "") {
      writer.uint32(162).string(message.prompts);
    }
    if (message.toUserId !== "0") {
      writer.uint32(168).int64(message.toUserId);
    }
    if (message.tips !== "") {
      writer.uint32(202).string(message.tips);
    }
    if (message.startTimeMs !== "0") {
      writer.uint32(208).int64(message.startTimeMs);
    }
    if (message.confluenceType !== 0) {
      writer.uint32(216).int32(message.confluenceType);
    }
    if (message.fromRoomId !== "0") {
      writer.uint32(224).int64(message.fromRoomId);
    }
    if (message.inviteType !== 0) {
      writer.uint32(232).int32(message.inviteType);
    }
    if (message.subType !== "0") {
      writer.uint32(240).int64(message.subType);
    }
    if (message.rtcExtInfo !== "") {
      writer.uint32(258).string(message.rtcExtInfo);
    }
    if (message.appId !== "") {
      writer.uint32(274).string(message.appId);
    }
    if (message.appSign !== "") {
      writer.uint32(282).string(message.appSign);
    }
    if (message.anchorLinkMicIdStr !== "") {
      writer.uint32(298).string(message.anchorLinkMicIdStr);
    }
    if (message.rivalAnchorId !== "0") {
      writer.uint32(304).int64(message.rivalAnchorId);
    }
    if (message.rivalLinkmicId !== 0) {
      writer.uint32(312).int32(message.rivalLinkmicId);
    }
    if (message.rivalLinkmicIdStr !== "") {
      writer.uint32(322).string(message.rivalLinkmicIdStr);
    }
    if (message.shouldShowPopup !== false) {
      writer.uint32(328).bool(message.shouldShowPopup);
    }
    if (message.rtcJoinChannel !== false) {
      writer.uint32(408).bool(message.rtcJoinChannel);
    }
    if (message.fanTicketType !== 0) {
      writer.uint32(416).int32(message.fanTicketType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMicMethod {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMicMethod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.messageType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.accessKey = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.anchorLinkmicId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.userId = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.fanTicket = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalLinkMicFanTicket = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.channelId = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.layout = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.vendor = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.dimension = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.theme = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.inviteUid = reader.int64().toString();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.reply = reader.int32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.duration = reader.int32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.matchType = reader.int32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.win = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.prompts = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.toUserId = reader.int64().toString();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.tips = reader.string();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.startTimeMs = reader.int64().toString();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.confluenceType = reader.int32();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.fromRoomId = reader.int64().toString();
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.inviteType = reader.int32();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.subType = reader.int64().toString();
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.rtcExtInfo = reader.string();
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.appId = reader.string();
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.appSign = reader.string();
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.anchorLinkMicIdStr = reader.string();
          continue;
        }
        case 38: {
          if (tag !== 304) {
            break;
          }

          message.rivalAnchorId = reader.int64().toString();
          continue;
        }
        case 39: {
          if (tag !== 312) {
            break;
          }

          message.rivalLinkmicId = reader.int32();
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.rivalLinkmicIdStr = reader.string();
          continue;
        }
        case 41: {
          if (tag !== 328) {
            break;
          }

          message.shouldShowPopup = reader.bool();
          continue;
        }
        case 51: {
          if (tag !== 408) {
            break;
          }

          message.rtcJoinChannel = reader.bool();
          continue;
        }
        case 52: {
          if (tag !== 416) {
            break;
          }

          message.fanTicketType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastUnauthorizedMemberMessage(): WebcastUnauthorizedMemberMessage {
  return {
    common: undefined,
    action: 0,
    nickNamePrefix: undefined,
    nickName: "",
    enterText: undefined,
    publicAreaCommon: undefined,
  };
}

export const WebcastUnauthorizedMemberMessage: MessageFns<WebcastUnauthorizedMemberMessage> = {
  encode(message: WebcastUnauthorizedMemberMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.action !== 0) {
      writer.uint32(16).int32(message.action);
    }
    if (message.nickNamePrefix !== undefined) {
      Text.encode(message.nickNamePrefix, writer.uint32(26).fork()).join();
    }
    if (message.nickName !== "") {
      writer.uint32(34).string(message.nickName);
    }
    if (message.enterText !== undefined) {
      Text.encode(message.enterText, writer.uint32(42).fork()).join();
    }
    if (message.publicAreaCommon !== undefined) {
      PublicAreaMessageCommon.encode(message.publicAreaCommon, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastUnauthorizedMemberMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastUnauthorizedMemberMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.action = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nickNamePrefix = Text.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nickName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.enterText = Text.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.publicAreaCommon = PublicAreaMessageCommon.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastMsgDetectMessage(): WebcastMsgDetectMessage {
  return {
    common: undefined,
    detectType: 0,
    triggerCondition: undefined,
    timeInfo: undefined,
    triggerBy: 0,
    fromRegion: "",
  };
}

export const WebcastMsgDetectMessage: MessageFns<WebcastMsgDetectMessage> = {
  encode(message: WebcastMsgDetectMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.detectType !== 0) {
      writer.uint32(16).int32(message.detectType);
    }
    if (message.triggerCondition !== undefined) {
      WebcastMsgDetectMessage_TriggerCondition.encode(message.triggerCondition, writer.uint32(26).fork()).join();
    }
    if (message.timeInfo !== undefined) {
      WebcastMsgDetectMessage_TimeInfo.encode(message.timeInfo, writer.uint32(34).fork()).join();
    }
    if (message.triggerBy !== 0) {
      writer.uint32(40).int32(message.triggerBy);
    }
    if (message.fromRegion !== "") {
      writer.uint32(50).string(message.fromRegion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMsgDetectMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMsgDetectMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.detectType = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.triggerCondition = WebcastMsgDetectMessage_TriggerCondition.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timeInfo = WebcastMsgDetectMessage_TimeInfo.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.triggerBy = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fromRegion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastMsgDetectMessage_TimeInfo(): WebcastMsgDetectMessage_TimeInfo {
  return { clientStartMs: "0", apiRecvTimeMs: "0", apiSendToGoimMs: "0" };
}

export const WebcastMsgDetectMessage_TimeInfo: MessageFns<WebcastMsgDetectMessage_TimeInfo> = {
  encode(message: WebcastMsgDetectMessage_TimeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientStartMs !== "0") {
      writer.uint32(8).int64(message.clientStartMs);
    }
    if (message.apiRecvTimeMs !== "0") {
      writer.uint32(16).int64(message.apiRecvTimeMs);
    }
    if (message.apiSendToGoimMs !== "0") {
      writer.uint32(24).int64(message.apiSendToGoimMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMsgDetectMessage_TimeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMsgDetectMessage_TimeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.clientStartMs = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.apiRecvTimeMs = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.apiSendToGoimMs = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastMsgDetectMessage_TriggerCondition(): WebcastMsgDetectMessage_TriggerCondition {
  return {
    uplinkDetectHttp: false,
    uplinkDetectWebSocket: false,
    detectP2PMsg: false,
    detectRoomMsg: false,
    httpOptimize: false,
  };
}

export const WebcastMsgDetectMessage_TriggerCondition: MessageFns<WebcastMsgDetectMessage_TriggerCondition> = {
  encode(message: WebcastMsgDetectMessage_TriggerCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uplinkDetectHttp !== false) {
      writer.uint32(8).bool(message.uplinkDetectHttp);
    }
    if (message.uplinkDetectWebSocket !== false) {
      writer.uint32(16).bool(message.uplinkDetectWebSocket);
    }
    if (message.detectP2PMsg !== false) {
      writer.uint32(24).bool(message.detectP2PMsg);
    }
    if (message.detectRoomMsg !== false) {
      writer.uint32(32).bool(message.detectRoomMsg);
    }
    if (message.httpOptimize !== false) {
      writer.uint32(40).bool(message.httpOptimize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastMsgDetectMessage_TriggerCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastMsgDetectMessage_TriggerCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.uplinkDetectHttp = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uplinkDetectWebSocket = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.detectP2PMsg = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.detectRoomMsg = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.httpOptimize = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastOecLiveShoppingMessage(): WebcastOecLiveShoppingMessage {
  return { common: undefined, data1: 0, shopData: undefined, shopTimings: undefined, details: undefined };
}

export const WebcastOecLiveShoppingMessage: MessageFns<WebcastOecLiveShoppingMessage> = {
  encode(message: WebcastOecLiveShoppingMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.data1 !== 0) {
      writer.uint32(16).uint32(message.data1);
    }
    if (message.shopData !== undefined) {
      WebcastOecLiveShoppingMessage_LiveShoppingData.encode(message.shopData, writer.uint32(34).fork()).join();
    }
    if (message.shopTimings !== undefined) {
      TimeStampContainer.encode(message.shopTimings, writer.uint32(42).fork()).join();
    }
    if (message.details !== undefined) {
      WebcastOecLiveShoppingMessage_LiveShoppingDetails.encode(message.details, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastOecLiveShoppingMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastOecLiveShoppingMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.data1 = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shopData = WebcastOecLiveShoppingMessage_LiveShoppingData.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.shopTimings = TimeStampContainer.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.details = WebcastOecLiveShoppingMessage_LiveShoppingDetails.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastOecLiveShoppingMessage_LiveShoppingData(): WebcastOecLiveShoppingMessage_LiveShoppingData {
  return {
    title: "",
    priceString: "",
    imageUrl: "",
    shopUrl: "",
    data1: "0",
    shopName: "",
    data2: "0",
    shopUrl2: "",
    data3: "0",
    data4: "0",
  };
}

export const WebcastOecLiveShoppingMessage_LiveShoppingData: MessageFns<
  WebcastOecLiveShoppingMessage_LiveShoppingData
> = {
  encode(
    message: WebcastOecLiveShoppingMessage_LiveShoppingData,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.priceString !== "") {
      writer.uint32(18).string(message.priceString);
    }
    if (message.imageUrl !== "") {
      writer.uint32(26).string(message.imageUrl);
    }
    if (message.shopUrl !== "") {
      writer.uint32(34).string(message.shopUrl);
    }
    if (message.data1 !== "0") {
      writer.uint32(48).uint64(message.data1);
    }
    if (message.shopName !== "") {
      writer.uint32(58).string(message.shopName);
    }
    if (message.data2 !== "0") {
      writer.uint32(64).uint64(message.data2);
    }
    if (message.shopUrl2 !== "") {
      writer.uint32(74).string(message.shopUrl2);
    }
    if (message.data3 !== "0") {
      writer.uint32(80).uint64(message.data3);
    }
    if (message.data4 !== "0") {
      writer.uint32(88).uint64(message.data4);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastOecLiveShoppingMessage_LiveShoppingData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastOecLiveShoppingMessage_LiveShoppingData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.priceString = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shopUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.data1 = reader.uint64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.shopName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.data2 = reader.uint64().toString();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.shopUrl2 = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.data3 = reader.uint64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.data4 = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastOecLiveShoppingMessage_LiveShoppingDetails(): WebcastOecLiveShoppingMessage_LiveShoppingDetails {
  return { id1: "", data1: "", data2: 0, timestamp: "0", data: undefined };
}

export const WebcastOecLiveShoppingMessage_LiveShoppingDetails: MessageFns<
  WebcastOecLiveShoppingMessage_LiveShoppingDetails
> = {
  encode(
    message: WebcastOecLiveShoppingMessage_LiveShoppingDetails,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id1 !== "") {
      writer.uint32(10).string(message.id1);
    }
    if (message.data1 !== "") {
      writer.uint32(26).string(message.data1);
    }
    if (message.data2 !== 0) {
      writer.uint32(32).uint32(message.data2);
    }
    if (message.timestamp !== "0") {
      writer.uint32(40).uint64(message.timestamp);
    }
    if (message.data !== undefined) {
      ValueLabel.encode(message.data, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastOecLiveShoppingMessage_LiveShoppingDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastOecLiveShoppingMessage_LiveShoppingDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id1 = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data1 = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.data2 = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timestamp = reader.uint64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.data = ValueLabel.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastRoomPinMessage(): WebcastRoomPinMessage {
  return {
    common: undefined,
    chatMessage: undefined,
    socialMessage: undefined,
    giftMessage: undefined,
    memberMessage: undefined,
    likeMessage: undefined,
    method: "",
    pinTime: "0",
    operator: undefined,
    action: 0,
    displayDuration: "0",
    pinId: "0",
    ecStreamerKey: "",
  };
}

export const WebcastRoomPinMessage: MessageFns<WebcastRoomPinMessage> = {
  encode(message: WebcastRoomPinMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.chatMessage !== undefined) {
      WebcastChatMessage.encode(message.chatMessage, writer.uint32(18).fork()).join();
    }
    if (message.socialMessage !== undefined) {
      WebcastSocialMessage.encode(message.socialMessage, writer.uint32(26).fork()).join();
    }
    if (message.giftMessage !== undefined) {
      WebcastGiftMessage.encode(message.giftMessage, writer.uint32(34).fork()).join();
    }
    if (message.memberMessage !== undefined) {
      WebcastMemberMessage.encode(message.memberMessage, writer.uint32(42).fork()).join();
    }
    if (message.likeMessage !== undefined) {
      WebcastLikeMessage.encode(message.likeMessage, writer.uint32(50).fork()).join();
    }
    if (message.method !== "") {
      writer.uint32(242).string(message.method);
    }
    if (message.pinTime !== "0") {
      writer.uint32(248).int64(message.pinTime);
    }
    if (message.operator !== undefined) {
      User.encode(message.operator, writer.uint32(258).fork()).join();
    }
    if (message.action !== 0) {
      writer.uint32(264).int32(message.action);
    }
    if (message.displayDuration !== "0") {
      writer.uint32(272).int64(message.displayDuration);
    }
    if (message.pinId !== "0") {
      writer.uint32(280).int64(message.pinId);
    }
    if (message.ecStreamerKey !== "") {
      writer.uint32(290).string(message.ecStreamerKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastRoomPinMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastRoomPinMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chatMessage = WebcastChatMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.socialMessage = WebcastSocialMessage.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.giftMessage = WebcastGiftMessage.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.memberMessage = WebcastMemberMessage.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.likeMessage = WebcastLikeMessage.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.pinTime = reader.int64().toString();
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.operator = User.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.action = reader.int32();
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.displayDuration = reader.int64().toString();
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.pinId = reader.int64().toString();
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.ecStreamerKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkMessage(): WebcastLinkMessage {
  return {
    common: undefined,
    MessageType: 0,
    LinkerId: "0",
    Scene: 0,
    InviteContent: undefined,
    ReplyContent: undefined,
    CreateContent: undefined,
    CloseContent: undefined,
    EnterContent: undefined,
    LeaveContent: undefined,
    CancelContent: undefined,
    KickOutContent: undefined,
    LinkedListChangeContent: undefined,
    UpdateUserContent: undefined,
    WaitingListChangeContent: undefined,
    MuteContent: undefined,
    RandomMatchContent: undefined,
    UpdateUserSettingContent: undefined,
    MicIdxUpdateContent: undefined,
    ListChangeContent: undefined,
    CohostListChangeContent: undefined,
    MediaChangeContent: undefined,
    AcceptNoticeContent: undefined,
    SysKickOutContent: undefined,
    UserToastContent: undefined,
    extra: "",
    expireTimestamp: "0",
    transferExtra: "",
  };
}

export const WebcastLinkMessage: MessageFns<WebcastLinkMessage> = {
  encode(message: WebcastLinkMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.MessageType !== 0) {
      writer.uint32(16).int32(message.MessageType);
    }
    if (message.LinkerId !== "0") {
      writer.uint32(24).int64(message.LinkerId);
    }
    if (message.Scene !== 0) {
      writer.uint32(32).int32(message.Scene);
    }
    if (message.InviteContent !== undefined) {
      LinkerInviteContent.encode(message.InviteContent, writer.uint32(42).fork()).join();
    }
    if (message.ReplyContent !== undefined) {
      LinkerReplyContent.encode(message.ReplyContent, writer.uint32(50).fork()).join();
    }
    if (message.CreateContent !== undefined) {
      LinkerCreateContent.encode(message.CreateContent, writer.uint32(58).fork()).join();
    }
    if (message.CloseContent !== undefined) {
      LinkerCloseContent.encode(message.CloseContent, writer.uint32(66).fork()).join();
    }
    if (message.EnterContent !== undefined) {
      LinkerEnterContent.encode(message.EnterContent, writer.uint32(74).fork()).join();
    }
    if (message.LeaveContent !== undefined) {
      LinkerLeaveContent.encode(message.LeaveContent, writer.uint32(82).fork()).join();
    }
    if (message.CancelContent !== undefined) {
      LinkerCancelContent.encode(message.CancelContent, writer.uint32(90).fork()).join();
    }
    if (message.KickOutContent !== undefined) {
      LinkerKickOutContent.encode(message.KickOutContent, writer.uint32(98).fork()).join();
    }
    if (message.LinkedListChangeContent !== undefined) {
      LinkerLinkedListChangeContent.encode(message.LinkedListChangeContent, writer.uint32(106).fork()).join();
    }
    if (message.UpdateUserContent !== undefined) {
      LinkerUpdateUserContent.encode(message.UpdateUserContent, writer.uint32(114).fork()).join();
    }
    if (message.WaitingListChangeContent !== undefined) {
      LinkerWaitingListChangeContent.encode(message.WaitingListChangeContent, writer.uint32(122).fork()).join();
    }
    if (message.MuteContent !== undefined) {
      LinkerMuteContent.encode(message.MuteContent, writer.uint32(130).fork()).join();
    }
    if (message.RandomMatchContent !== undefined) {
      LinkerRandomMatchContent.encode(message.RandomMatchContent, writer.uint32(138).fork()).join();
    }
    if (message.UpdateUserSettingContent !== undefined) {
      LinkerUpdateUserSettingContent.encode(message.UpdateUserSettingContent, writer.uint32(146).fork()).join();
    }
    if (message.MicIdxUpdateContent !== undefined) {
      LinkerMicIdxUpdateContent.encode(message.MicIdxUpdateContent, writer.uint32(154).fork()).join();
    }
    if (message.ListChangeContent !== undefined) {
      LinkerListChangeContent.encode(message.ListChangeContent, writer.uint32(162).fork()).join();
    }
    if (message.CohostListChangeContent !== undefined) {
      CohostListChangeContent.encode(message.CohostListChangeContent, writer.uint32(170).fork()).join();
    }
    if (message.MediaChangeContent !== undefined) {
      LinkerMediaChangeContent.encode(message.MediaChangeContent, writer.uint32(178).fork()).join();
    }
    if (message.AcceptNoticeContent !== undefined) {
      LinkerAcceptNoticeContent.encode(message.AcceptNoticeContent, writer.uint32(186).fork()).join();
    }
    if (message.SysKickOutContent !== undefined) {
      LinkerSysKickOutContent.encode(message.SysKickOutContent, writer.uint32(810).fork()).join();
    }
    if (message.UserToastContent !== undefined) {
      LinkmicUserToastContent.encode(message.UserToastContent, writer.uint32(818).fork()).join();
    }
    if (message.extra !== "") {
      writer.uint32(1602).string(message.extra);
    }
    if (message.expireTimestamp !== "0") {
      writer.uint32(1608).int64(message.expireTimestamp);
    }
    if (message.transferExtra !== "") {
      writer.uint32(1618).string(message.transferExtra);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.MessageType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.LinkerId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.Scene = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.InviteContent = LinkerInviteContent.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.ReplyContent = LinkerReplyContent.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.CreateContent = LinkerCreateContent.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.CloseContent = LinkerCloseContent.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.EnterContent = LinkerEnterContent.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.LeaveContent = LinkerLeaveContent.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.CancelContent = LinkerCancelContent.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.KickOutContent = LinkerKickOutContent.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.LinkedListChangeContent = LinkerLinkedListChangeContent.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.UpdateUserContent = LinkerUpdateUserContent.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.WaitingListChangeContent = LinkerWaitingListChangeContent.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.MuteContent = LinkerMuteContent.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.RandomMatchContent = LinkerRandomMatchContent.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.UpdateUserSettingContent = LinkerUpdateUserSettingContent.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.MicIdxUpdateContent = LinkerMicIdxUpdateContent.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.ListChangeContent = LinkerListChangeContent.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.CohostListChangeContent = CohostListChangeContent.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.MediaChangeContent = LinkerMediaChangeContent.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.AcceptNoticeContent = LinkerAcceptNoticeContent.decode(reader, reader.uint32());
          continue;
        }
        case 101: {
          if (tag !== 810) {
            break;
          }

          message.SysKickOutContent = LinkerSysKickOutContent.decode(reader, reader.uint32());
          continue;
        }
        case 102: {
          if (tag !== 818) {
            break;
          }

          message.UserToastContent = LinkmicUserToastContent.decode(reader, reader.uint32());
          continue;
        }
        case 200: {
          if (tag !== 1602) {
            break;
          }

          message.extra = reader.string();
          continue;
        }
        case 201: {
          if (tag !== 1608) {
            break;
          }

          message.expireTimestamp = reader.int64().toString();
          continue;
        }
        case 202: {
          if (tag !== 1618) {
            break;
          }

          message.transferExtra = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWebcastLinkLayerMessage(): WebcastLinkLayerMessage {
  return {
    common: undefined,
    messageType: 0,
    channelId: "0",
    scene: 0,
    source: "",
    centerizedIdc: "",
    rtcRoomId: "0",
    createChannelContent: undefined,
    listChangeContent: undefined,
    inviteContent: undefined,
    applyContent: undefined,
    permitApplyContent: undefined,
    replyInviteContent: undefined,
    kickOutContent: undefined,
    cancelApplyContent: undefined,
    cancelInviteContent: undefined,
    leaveContent: undefined,
    finishContent: undefined,
    joinDirectContent: undefined,
    joinGroupContent: undefined,
    permitGroupContent: undefined,
    cancelGroupContent: undefined,
    leaveGroupContent: undefined,
    p2pGroupChangeContent: undefined,
    groupChangeContent: undefined,
    businessContent: undefined,
  };
}

export const WebcastLinkLayerMessage: MessageFns<WebcastLinkLayerMessage> = {
  encode(message: WebcastLinkLayerMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.messageType !== 0) {
      writer.uint32(16).int32(message.messageType);
    }
    if (message.channelId !== "0") {
      writer.uint32(24).int64(message.channelId);
    }
    if (message.scene !== 0) {
      writer.uint32(32).int32(message.scene);
    }
    if (message.source !== "") {
      writer.uint32(42).string(message.source);
    }
    if (message.centerizedIdc !== "") {
      writer.uint32(50).string(message.centerizedIdc);
    }
    if (message.rtcRoomId !== "0") {
      writer.uint32(56).int64(message.rtcRoomId);
    }
    if (message.createChannelContent !== undefined) {
      CreateChannelContent.encode(message.createChannelContent, writer.uint32(802).fork()).join();
    }
    if (message.listChangeContent !== undefined) {
      ListChangeContent.encode(message.listChangeContent, writer.uint32(818).fork()).join();
    }
    if (message.inviteContent !== undefined) {
      InviteContent.encode(message.inviteContent, writer.uint32(826).fork()).join();
    }
    if (message.applyContent !== undefined) {
      ApplyContent.encode(message.applyContent, writer.uint32(834).fork()).join();
    }
    if (message.permitApplyContent !== undefined) {
      PermitApplyContent.encode(message.permitApplyContent, writer.uint32(842).fork()).join();
    }
    if (message.replyInviteContent !== undefined) {
      ReplyInviteContent.encode(message.replyInviteContent, writer.uint32(850).fork()).join();
    }
    if (message.kickOutContent !== undefined) {
      KickOutContent.encode(message.kickOutContent, writer.uint32(858).fork()).join();
    }
    if (message.cancelApplyContent !== undefined) {
      CancelApplyContent.encode(message.cancelApplyContent, writer.uint32(866).fork()).join();
    }
    if (message.cancelInviteContent !== undefined) {
      CancelInviteContent.encode(message.cancelInviteContent, writer.uint32(874).fork()).join();
    }
    if (message.leaveContent !== undefined) {
      LeaveContent.encode(message.leaveContent, writer.uint32(882).fork()).join();
    }
    if (message.finishContent !== undefined) {
      FinishChannelContent.encode(message.finishContent, writer.uint32(890).fork()).join();
    }
    if (message.joinDirectContent !== undefined) {
      JoinDirectContent.encode(message.joinDirectContent, writer.uint32(898).fork()).join();
    }
    if (message.joinGroupContent !== undefined) {
      JoinGroupContent.encode(message.joinGroupContent, writer.uint32(906).fork()).join();
    }
    if (message.permitGroupContent !== undefined) {
      PermitJoinGroupContent.encode(message.permitGroupContent, writer.uint32(914).fork()).join();
    }
    if (message.cancelGroupContent !== undefined) {
      CancelJoinGroupContent.encode(message.cancelGroupContent, writer.uint32(922).fork()).join();
    }
    if (message.leaveGroupContent !== undefined) {
      LeaveJoinGroupContent.encode(message.leaveGroupContent, writer.uint32(930).fork()).join();
    }
    if (message.p2pGroupChangeContent !== undefined) {
      P2PGroupChangeContent.encode(message.p2pGroupChangeContent, writer.uint32(938).fork()).join();
    }
    if (message.groupChangeContent !== undefined) {
      GroupChangeContent.encode(message.groupChangeContent, writer.uint32(946).fork()).join();
    }
    if (message.businessContent !== undefined) {
      BusinessContent.encode(message.businessContent, writer.uint32(1602).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebcastLinkLayerMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebcastLinkLayerMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.messageType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.channelId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.scene = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.centerizedIdc = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.rtcRoomId = reader.int64().toString();
          continue;
        }
        case 100: {
          if (tag !== 802) {
            break;
          }

          message.createChannelContent = CreateChannelContent.decode(reader, reader.uint32());
          continue;
        }
        case 102: {
          if (tag !== 818) {
            break;
          }

          message.listChangeContent = ListChangeContent.decode(reader, reader.uint32());
          continue;
        }
        case 103: {
          if (tag !== 826) {
            break;
          }

          message.inviteContent = InviteContent.decode(reader, reader.uint32());
          continue;
        }
        case 104: {
          if (tag !== 834) {
            break;
          }

          message.applyContent = ApplyContent.decode(reader, reader.uint32());
          continue;
        }
        case 105: {
          if (tag !== 842) {
            break;
          }

          message.permitApplyContent = PermitApplyContent.decode(reader, reader.uint32());
          continue;
        }
        case 106: {
          if (tag !== 850) {
            break;
          }

          message.replyInviteContent = ReplyInviteContent.decode(reader, reader.uint32());
          continue;
        }
        case 107: {
          if (tag !== 858) {
            break;
          }

          message.kickOutContent = KickOutContent.decode(reader, reader.uint32());
          continue;
        }
        case 108: {
          if (tag !== 866) {
            break;
          }

          message.cancelApplyContent = CancelApplyContent.decode(reader, reader.uint32());
          continue;
        }
        case 109: {
          if (tag !== 874) {
            break;
          }

          message.cancelInviteContent = CancelInviteContent.decode(reader, reader.uint32());
          continue;
        }
        case 110: {
          if (tag !== 882) {
            break;
          }

          message.leaveContent = LeaveContent.decode(reader, reader.uint32());
          continue;
        }
        case 111: {
          if (tag !== 890) {
            break;
          }

          message.finishContent = FinishChannelContent.decode(reader, reader.uint32());
          continue;
        }
        case 112: {
          if (tag !== 898) {
            break;
          }

          message.joinDirectContent = JoinDirectContent.decode(reader, reader.uint32());
          continue;
        }
        case 113: {
          if (tag !== 906) {
            break;
          }

          message.joinGroupContent = JoinGroupContent.decode(reader, reader.uint32());
          continue;
        }
        case 114: {
          if (tag !== 914) {
            break;
          }

          message.permitGroupContent = PermitJoinGroupContent.decode(reader, reader.uint32());
          continue;
        }
        case 115: {
          if (tag !== 922) {
            break;
          }

          message.cancelGroupContent = CancelJoinGroupContent.decode(reader, reader.uint32());
          continue;
        }
        case 116: {
          if (tag !== 930) {
            break;
          }

          message.leaveGroupContent = LeaveJoinGroupContent.decode(reader, reader.uint32());
          continue;
        }
        case 117: {
          if (tag !== 938) {
            break;
          }

          message.p2pGroupChangeContent = P2PGroupChangeContent.decode(reader, reader.uint32());
          continue;
        }
        case 118: {
          if (tag !== 946) {
            break;
          }

          message.groupChangeContent = GroupChangeContent.decode(reader, reader.uint32());
          continue;
        }
        case 200: {
          if (tag !== 1602) {
            break;
          }

          message.businessContent = BusinessContent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRoomVerifyMessage(): RoomVerifyMessage {
  return { common: undefined, action: 0, content: "", noticeType: "0", closeRoom: false };
}

export const RoomVerifyMessage: MessageFns<RoomVerifyMessage> = {
  encode(message: RoomVerifyMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.common !== undefined) {
      CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
    }
    if (message.action !== 0) {
      writer.uint32(16).int32(message.action);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.noticeType !== "0") {
      writer.uint32(32).int64(message.noticeType);
    }
    if (message.closeRoom !== false) {
      writer.uint32(40).bool(message.closeRoom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoomVerifyMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoomVerifyMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.common = CommonMessageData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.action = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.noticeType = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.closeRoom = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
